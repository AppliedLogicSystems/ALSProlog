/*=======================================================================*
 |                      dbsetup.pro
 |		Copyright (c) 2023 Applied Logic Systems, Inc.
 |
 |	Reads a db specification and creates a database, together with
 |	prolog-level convenience code for accessing and manipulating
 |	that database.
 |
 |	Commandline options:
 |	-spec Points to a *.db_spec file to be processed
 |	-dbd  Points to folder in which to search for *.db_spec files
 |	-db   Names the file constituting the generated sql3lite database
	-tdb  Points to a folder where all created files are placed (-db overrides)
 |
 |	If no -spec ___ is present, but -dbd <DD> is present, looks for *.db_spec file(s) in <DD>
 |	If no -spec or -dbd is present, looks for *.db_spec files in the current directory
 *=======================================================================*/

%%%%%%%%%%%%%% To be moved to library (in miscatom.pro):
/*!---------------------------------------------------------------------
 |	pat_atom/3.
 |	pat_atom(Pattern, Vals, Result)
 |	pat_atom(+, +, -)
 |
 |	- creates an atom using Pattern,Vals in the style of printf
 |
 | Example:
 |		pat_atom('Name: %t -- Height: %t ft', ['George', 6]
				'Name: George -- Height: 6 ft')
 *!---------------------------------------------------------------------*/
module builtins.
export pat_atom/3.
pat_atom(Pattern, Vals, Result)
	:-
	open(atom(Result), write, S),
	printf(S, Pattern, Vals),
	close(S).
endmod.
%%%%%%%%%%%%%% Move to library (in miscatom.pro):

/*
        %% For dev: the searchdir fact finds sqlite3_intf.pro,
        %% and then finds sqlite3_intf.psl:
	%% If sqlite3_intf.[pro,psl] are in alsdir/shared,
	%% they are found, so this is unneeded.
module builtins.
searchdir('..').
endmod.
*/

	%% Found in ~alsdir/shared:
:-['sqlite3_intf.pro'].

module dbgen.
use sqlite3.

	/* 
	    For defStruct:
	    See Chapter 5 Abstract Data Types: Structure Definition in the ALSProlog manual: 
	    https://alsprolog.com/docs/guide/5-Abstract-Data-Types-Structure-Definition.html
	*/

/* ----------------------------------------------------------------- 
   Records info from the command line invoking manage_site_specs/0
* -----------------------------------------------------------------*/
:- defStruct(cmdInfo,
    [
	propertiesList =
      [
	    %% command line switches:
	spec,	% -spec : an individual *.db_spec file to be processed (may include a path)
	dbd,	% -dbd	: a folder in which to search for *.db_spec files; default = ./
	db,	% -db	: explicit file for created sqlite3 db
	tdbd,	% -tdbd	: a folder in which to place all generated files; default = ./
		%% Not a switch; used to indicate the computed src path:
	specSrc	%
      ],
	accessPred  = accessCmd,
        setPred     = setCmd,
        makePred    = makeCmdInfo,
        structLabel = cmd
    ]
   ).


/* ---------------------------------------------------------------------- 
   Records info from an individual *.db_spec file, together the relevant
   info from the invoking cmdInfo defStruct.
* ----------------------------------------------------------------------*/
:- defStruct(specDetails,
    [
	propertiesList =
      [
	name,
	arg_decls,
	dtFunc, 
	primary,
	index_fields, 
	foreign_keys/[],
        data_file,
	module,
	test_lines,
	import_to,
	srcPath,
	srcTerm,	% as read from srcPath
	srcLines,	% as read from srcTerm from srcPath			%
	dbPath,		% to sqlite3 data file
	tableName, 
	sqlColSpecs, 
	colDecls, 
	testDataTerms, 
	updateDataTerms,
	cts		% string to be passed to create the table
      ],
	accessPred  = accessSpec,
        setPred     = setSpec,
        makePred    = makeSpecStruct,
        structLabel = sp
    ]
   ).

	%% This was hand-written; needs to be auto-generated by defStruct:
dumpSpecDetails(SpecStruct)
	:-
	Properties = [ name, arg_decls, dtFunc, primary, index_fields, foreign_keys, data_file, module,
			test_lines, import_to,srcPath, srcTerm,	srcLines, dbPath, tableName, 
			sqlColSpecs, colDecls, testDataTerms, updateDataTerms],
	dumpSecDetailsProps(Properties, SpecStruct).

dumpSecDetailsProps([], SpecStruct).
dumpSecDetailsProps([Prop | Properties], SpecStruct)
	:-
	accessSpec(Prop, SpecStruct, PVal),
	write(Prop=PVal),nl,
	dumpSecDetailsProps(Properties, SpecStruct).


export m/0.
export manage_site_specs/0.

m :- manage_site_specs.

/* ---------------------------------------------------------------------- 
	Main entry point
* ----------------------------------------------------------------------*/
manage_site_specs
        :-
        catch(manage_dbsetup, dbsetup_error(ErrorInfo), dbsetup_excpetion(ErrorInfo)).

manage_dbsetup
	:-
	processCommandLine(CmdInfo),
	get_specfile_list(CmdInfo, RawSpecFileList),
	processEachSpecFile(RawSpecFileList, ListOfListsSpecDetailsStructs, CmdInfo).


	%% if a -tdbd switch is present, it must be to a folder (somewhere), and all
	%% output files (__code.pro, __data, etc.) are placed there.
	%% if no -tdbd switch is present, output files for a given source *.db_spec file
	%% are placed in the same folder as (each)(the) *.db_spec file was obtained from.

get_specfile_list(CmdInfo, [SingleSpecFilePath])
	:-
	accessCmd(spec, CmdInfo, SingleSpecFilePath),
	SingleSpecFilePath \= '',
	exists_file(SingleSpecFilePath),
	!,
	pathPlusFile(SrcFolderPath, _, SingleSpecFilePath),
	setCmd(specSrc, CmdInfo,  SrcFolderPath).
	
get_specfile_list(CmdInfo, RawSpecFileList)
	:-
	accessCmd(dbd, CmdInfo, CmdlineFolderPath),
	(CmdlineFolderPath \= '' ->
		(exists_file(CmdlineFolderPath) ->
			Path = CmdlineFolderPath,
			files(CmdlineFolderPath, '*.db_spec', InitSpecFileList),
			setCmd(specSrc, CmdInfo,  CmdlineFolderPath)
			;
			files('./', '*.db_spec', InitSpecFileList),
			Path = './',
			setCmd(specSrc, CmdInfo,  Path)
		)
		;
		Path = './',
		files('./', '*.db_spec', InitSpecFileList),
		setCmd(specSrc, CmdInfo,  Path)
	),
	attachPaths(InitSpecFileList, Path, RawSpecFileList).

attachPaths([], Path, []).
attachPaths([File | FilesList], Path, [FileWithPath | RawSpecFileList])
	:-
	pathPlusFile(Path, File, FileWithPath),
	attachPaths(InitFilesList, Path, RawSpecFileList).

	/* ----------------------------------------------------------------------------
	  processEachSpecFile/3
	  processEachSpecFile(RawSpecFileList, ListOfListsSpecDetailsStructs, CmdInfo)
	  processEachSpecFile(+, -, +)

	  Multiple *.db_spec files may have been scooped up by the command line.
	  Make a pass through the list of paths to these files, separately
	  processing each file.

	  	ListOfListsSpecDetailsStructs contains one element for each input
		file path;, a list, for each input spec file list;  it is the list 
		of specDetails structs created for each spec in the file.
	 * --------------------------------------------------------------------------- */
processEachSpecFile([], [], _).
processEachSpecFile([FilePath | RawSpecFileList], 
			[FileStructsList | ListOfListsSpecDetailsStructs], CmdInfo)
	:-
	processIndivSpecFile(FilePath, FileStructsList, CmdInfo),
	processEachSpecFile(RawSpecFileList, ListOfListsSpecDetailsStructs, CmdInfo).

	/* ----------------------------------------------------------------------------
	   There may be multiple specs in a file, and they may have foreign key
	   interaction.  Make a first pass through all the specs using pass1ReadFileSpecs/3,
	   resulting in a list of specDetails structs, one for each spec; 
	   Then make a 2nd pass through that list completing the databasaes and generating
	   the interface code.
	 * --------------------------------------------------------------------------- */
processIndivSpecFile(FilePath, FileStructsList, CmdInfo)
	:-
	grab_terms(FilePath, FileTerms),
	!,
	printf(user, '\n>> Starting file %t\n', [FilePath]),
	pass1ReadFileSpecs(FileTerms, FileSpecInfoList, FKInfoListOfLists, CmdInfo),
	append(FKInfoListOfLists, FKInfoList),

printf(user, 'pISF_FKI=%t\n ', [FKInfoList]),
	pass2CompleteDBs(FileSpecInfoList, FKInfoList, CmdInfo).

processIndivSpecFile(FilePath, FileStructsList, CmdInfo)
	:-
	pat_atom('Can''t find spec file: %t', [FilePath], ErrMsg),
	throw(dbsetup_error(ErrMsg)).

	/* ----------------------------------------------------------------------------
	   pass1ReadFileSpecs/3
	   pass1ReadFileSpecs(FilePath, FileSpecInfoList, CmdInfo),
	   pass1ReadFileSpecs(+, -, +)

	   Given FilePath, read the db_table(...) terms out of the file,
	   create a specDetails Struct, store the lines in that struct
	   (There will be a 2nd pass further processing everything.)
	  
	   SpecInfoList is the list of the specDetails Structs created.
	 * --------------------------------------------------------------------------- */
pass1ReadFileSpecs([], [], [], CmdInfo).
pass1ReadFileSpecs([DBTableTerm | RestDBTableTerms], [SpecStruct | SpecsInfoList], [ThisFKInfo | RestFKInfo], CmdInfo)
	:-
	printf(user, '\n', []),
	prelimWorkTerm(DBTableTerm, SpecStruct, CmdInfo),
	setupForeignKeyInfo(SpecStruct, ThisFKInfo),
	pass1ReadFileSpecs(RestDBTableTerms, SpecsInfoList, RestFKInfo, CmdInfo).

	/* ----------------------------------------------------------------------------
	   prelimWorkTerm/3
	   prelimWorkTerm(DBTerm, SpecStruct, CmdInfo)
	   prelimWorkTerm(+, -, +)

	   Create and initially populate the SpecStruct corresponding to DBTerm
	 * --------------------------------------------------------------------------- */
prelimWorkTerm(DBTerm, SpecStruct, CmdInfo)
	:-
        makeSpecStruct(SpecStruct),
        setSpec(srcTerm, SpecStruct, DBTerm),
	DBTerm =.. [_ | DBTLines],
	(member(name=SpecName, DBTLines) -> printf(user, 'Reading spec: %t\n', [SpecName])
		;
		hard_error(db_spec, 'Missing spec name', [])
	),
        setSpec(srcLines, SpecStruct, DBTLines),
	plug_in_lines(DBTLines, SpecStruct),
	handle_dbPath(SpecStruct, CmdInfo).

	/* ----------------------------------------------------------------------------
	   plug_in_lines/3
	   plug_in_lines(Line, SpecStruct)
	   plug_in_lines(+, +)

	   Extracts info from db spec Lines into SpecStruct

	   Recurses through the db spec lines:

	   	plug_in_lines([Tag=Value | DBTLines], SpecStruct)
	 * --------------------------------------------------------------------------- */
plug_in_lines([], SpecStruct)
	:-
	setup_table_name(SpecStruct),
	accessSpec(testDataTerms, SpecStruct, TDT),
	(var(TDT) -> setSpec(testDataTerms, SpecStruct, []); true),
	accessSpec(updateDataTerms, SpecStruct, UDT),
	(var(UDT) -> setSpec(updateDataTerms, SpecStruct, []); true).
plug_in_lines([test_data_term=IDT | RestDBTLines], SpecStruct)
	:-
	pull_tdts(RestDBTLines, TDBTLines, test_data_term, TailLines),
        setSpec(testDataTerms, SpecStruct, [IDT | TDBTLines]),
	plug_in_lines(TailLines, SpecStruct).
plug_in_lines([update_data_term=IDT | RestDBTLines], SpecStruct)
	:-
	pull_tdts(RestDBTLines, UDBTLines, update_data_term, TailLines),
        setSpec(updateDataTerms, SpecStruct, [IDT | UDBTLines]),
	plug_in_lines(TailLines, SpecStruct).
plug_in_lines([arg_decls=ArgDecls | DBTLines], SpecStruct)
	:-!,
	ArgDecls =.. [DtFunc | ColDecls],
        setSpec(arg_decls, SpecStruct, ArgDecls),
        setSpec(dtFunc, SpecStruct, DtFunc),
        setSpec(colDecls, SpecStruct, ColDecls),
	sql_cols_dfn(ColDecls, SqlColSpecs),
	setSpec(sqlColSpecs, SpecStruct, SqlColSpecs),
	plug_in_lines(DBTLines, SpecStruct).
plug_in_lines([foreign_keys=FKs | DBTLines], SpecStruct)
	:-!,
	(var(FKs) ->
        	setSpec(foreign_keys, SpecStruct, [])
		;
        	setSpec(foreign_keys, SpecStruct, FKs)
	),
	plug_in_lines(DBTLines, SpecStruct).
plug_in_lines([Tag=Value | DBTLines], SpecStruct)
	:-
        setSpec(Tag, SpecStruct, Value),
	plug_in_lines(DBTLines, SpecStruct).

pull_tdts([Tag=IDT | DBTLines], [IDT | TBTLines], Tag, TailLines)
	:-!,
	pull_tdts(DBTLines, TBTLines, Tag, TailLines).
pull_tdts(TailLines, [], _, TailLines).

handle_dbPath(SpecStruct, CmdInfo)
	:-
	accessCmd(spec, CmdInfo, SingleSpec),
printf(user,'handle_db: spec=%t\n', [SingleSpec]),
	nonvar(SingleSpec),
	SingleSpec \= '',  
	!,
	pathPlusFile(DirPath, _, SingleSpec),
	accessSpec(data_file, SpecStruct, Sqlite3DataFile),
	pathPlusFile(DirPath, Sqlite3DataFile, DBPath),
printf(user,'handle_db: dbPath=%t\n', [DBPath]),
	setSpec(dbPath, SpecStruct, DBPath).

handle_dbPath(SpecStruct, CmdInfo)
	:-
	accessCmd(specSrc, CmdInfo, SS),
printf(user,'handle_db: specSrc=%t\n', [SS]),
	accessCmd(tdbd, CmdInfo, TgtDBDirPath),
	accessSpec(data_file, SpecStruct, Sqlite3DataFile),
	fin_dbPath(Sqlite3DataFile, TgtDBDirPath, SpecStruct, CmdInfo).

fin_dbPath('', TgtDBDirPath, SpecStruct, CmdInfo)
	:-!,
	throw(dbsetup_error('Missing spec file name')).

fin_dbPath(Sqlite3DataFile, '', SpecStruct, CmdInfo)
	:-!,
	Path = './',
	pathPlusFile(Path, Sqlite3DataFile, DBPath),
	setSpec(dbPath, SpecStruct, DBPath).

fin_dbPath(Sqlite3DataFile, TgtDBDirPath, SpecStruct, CmdInfo)
	:-
	Path = TgtDBDirPath,
	pathPlusFile(Path, Sqlite3DataFile, DBPath),
	setSpec(dbPath, SpecStruct, DBPath).

setup_table_name(SpecStruct)
	:-
        accessSpec(tableName, SpecStruct, TN),
	fin_setup_table_name(TN, SpecStruct).
fin_setup_table_name(TN, SpecStruct)
	:-
	var(TN),
	!,
        accessSpec(dtFunc, SpecStruct, DtFunc),
	catenate(DtFunc, '_table', TableName),
        setSpec(tableName, SpecStruct, TableName).
fin_setup_table_name(TN, SpecStruct)
	:-
	TN = '',
	!,
        accessSpec(dtFunc, SpecStruct, DtFunc),
	catenate(DtFunc, '_table', TableName),
        setSpec(tableName, SpecStruct, TableName).
fin_setup_table_name(_, SpecStruct).

	/* ----------------------------------------------------------------------------
	   setupForeignKeyInfo/2
	   setupForeignKeyInfo(SpecStruct, ThisFKInfo)
	   setupForeignKeyInfo(+, -)

	   Extracts & massages any foreign key info present

	 |   RESTRICTION until we can rely on Sqlite foreign key
	 |   constraint maintenance: both foreign key origin db spec
 	 |   and target file must be in the same dbSpec.
	 * --------------------------------------------------------------------------- */
setupForeignKeyInfo(SpecStruct, ThisFKInfo)
	:-
	accessSpec(foreign_keys, SpecStruct, InitThisFKs),
	finSetupForeignKeyInfo(InitThisFKs, SpecStruct, ThisFKInfo).

finSetupForeignKeyInfo(ThisFKs, SpecStruct, [])
	:-
	var(ThisFKs),
	!.
finSetupForeignKeyInfo([], SpecStruct, [])
	:-!.
finSetupForeignKeyInfo(InitThisFKs, SpecStruct, ThisFKs)
	:-
	accessSpec(dtFunc, SpecStruct, DtFunc),
	distribute_plus(InitThisFKs, DtFunc, ThisFKs).
	
distribute_plus([], DtFunc, []).
distribute_plus([FKItem | InitThisFKs], DtFunc, [DtFunc + FKItem | ThisFKs])
	:-
	distribute_plus(InitThisFKs, DtFunc, ThisFKs).

	/* ----------------------------------------------------------------------------
	 * --------------------------------------------------------------------------- */
pass2CompleteDBs([], FKInfoList, CmdInfo).
pass2CompleteDBs([SpecInfo | RestFileSpecInfoList], FKInfoList, CmdInfo)
	:-
	finishDB(SpecInfo, FKInfoList, CmdInfo),
	pass2CompleteDBs(RestFileSpecInfoList, FKInfoList, CmdInfo).


	/* ++++ Handy list of SpecStruct tags:
		name, arg_decls, dtFunc, primary, index_fields, foreign_keys, data_file,
		module, test_lines, import_to, srcPath, srcTerm,  srcLines,  dbPath,	
		tableName, sqlColSpecs, colDecls, testDataTerms, updateDataTerms
	*/

	/* ----------------------------------------------------------------------------
	 * --------------------------------------------------------------------------- */
finishDB(SpecInfo, FKInfoList, CmdInfo)
	:-
%% for dev only:
%dumpSpecDetails(SpecInfo),
accessSpec(dtFunc, SpecInfo, DtFunc),
printf(user, 'finishDB = %t\n', [DtFunc]),

	accessSpec(foreign_keys, SpecInfo, ForeignKeys),
	fk_line(ForeignKeys, DtFunc, FKLine),
	create_table(SpecInfo, DBHandle, FKLine),
	create_indicies(SpecInfo, DBHandle),

	run_tests(SpecInfo, DBHandle),
	gen_intf_code(SpecInfo, FKInfoList).

	/* ----------------------------------------------------------------------------
	 * --------------------------------------------------------------------------- */
sql_cols_dfn([], []).
sql_cols_dfn([CD | ColDecls], [SS | SqlColSpecs])
        :-
        sql_col_def(CD, SS),
        sql_cols_dfn(ColDecls, SqlColSpecs).

sql_col_def(a(ColName, ColType), [column_name=ColName, column_type=SQLType])
        :-
        sql_type(ColType, SQLType).

sql_col_def(a(ColName, ColType, Modifier),  
		[column_name=ColName, column_type=SQLType, modifier=Modifier])
        :-
        sql_type(ColType, SQLType).

sql_type(integer, 'INT').
sql_type('INT', 'INT').
sql_type('INTEGER', 'INT').
sql_type(text, 'TEXT').
sql_type('TEXT', 'TEXT').
sql_type('REAL', 'REAL').
sql_type(double, 'REAL').
sql_type(float, 'REAL').
sql_type(date,_)
	:-
	hard_error(db_spec, 'date_not_yet_implemented', []).
sql_type(T,_)
	:-
	hard_error(db_spec, 'unknown_type', [T]).

	/* ----------------------------------------------------------------------------
	   create_table/3
	   create_table(SpecInfo, DBHandle, FKInfoList)
	   create_table(+, -, +)
	 * --------------------------------------------------------------------------- */
create_table(SpecInfo, DBHandle, FKLine)
	:-
	accessSpec(dbPath, SpecInfo, DBPath),
	accessSpec(tableName, SpecInfo, TableName),
	accessSpec(sqlColSpecs, SpecInfo, SqlColSpecs),
	accessSpec(primary, SpecInfo, Primary),
	accessSpec(dtFunc, SpecInfo, DtFunc),

        sql_create_table_string(TableName, SqlColSpecs, Primary, FKLine, CreateTableString),
	setSpec(cts, SpecInfo, CreateTableString),
        sqlite3_open(DBPath, DBHandle),
	sql_drop_table(DBHandle, TableName),
        sqlite3_exec_norows(DBHandle, CreateTableString).


	/* ----------------------------------------------------------------------------
	 * --------------------------------------------------------------------------- */
create_indicies(SpecInfo, DBHandle)
	:-
	accessSpec(index_fields, SpecInfo, IndexFields),
	accessSpec(colDecls, SpecInfo, ColDecls),
	accessSpec(tableName, SpecInfo, TableName),
	accessSpec(primary, SpecInfo, Primary),
	accessSpec(dtFunc, SpecInfo, DtFunc),
	create_indicies(IndexFields, ColDecls, TableName, Primary, DtFunc, DBHandle).


	%%%% Taking all Index WhereClause args = [] for the present
	%%%% like sql_create_index/5 does;
create_indicies([], ColDecls, TableName, Primary, DtFunc, DBHandle).
create_indicies([Primary | RestIndexFields], ColDecls, TableName, Primary, DtFunc, DBHandle)
	:-!,
	create_indicies(RestIndexFields, ColDecls, TableName, Primary, DtFunc, DBHandle).
create_indicies([Col | RestIndexFields], ColDecls, TableName, Primary, DtFunc, DBHandle)
	:-
	(member(a(Col, Type), ColDecls), Mod = '', !
		; 
		member(a(Col, Type, Mod), ColDecls)),
	(sub_atom(TableName, 0, _, _, DtFunc) ->
		catenate([TableName, '_', Col, '_index'], IndexName)
		;
		catenate([DtFunc, '_', TableName, '_', Col, '_index'], IndexName)
	),
	sql_create_index(Col, Mod, TableName, IndexName, Primary, [], DBHandle),
	create_indicies(RestIndexFields, ColDecls, TableName, Primary, DtFunc, DBHandle).

	/* ----------------------------------------------------------------------------
	   run_tests/2
	   run_tests(SpecInfo, DBHandle)
	   run_tests(+, +)

	   SpecInfo.testDataTerms and SpecInfo.updateDataTerms provide appropriate
	   rows for testing insertion, retieval, and update for the created db.
	 * --------------------------------------------------------------------------- */
run_tests(SpecInfo, DBHandle)
	:-
	accessSpec(dbPath, SpecInfo, DBPath),
	accessSpec(tableName, SpecInfo, TableName),
	accessSpec(primary, SpecInfo, Primary),
	accessSpec(colDecls, SpecInfo, ColDecls),

	accessSpec(testDataTerms, SpecInfo, TestDataTerms),
	accessSpec(updateDataTerms, SpecInfo, UpdateDataTerms),

	test_inserts(TestDataTerms, DBHandle, TableName, RowsIn),
	select_all_table(DBHandle, TableName, AllSelection),
	check_comp_ins_sel(RowsIn, AllSelection, TableName),

	test_updates(UpdateDataTerms, DBHandle, TableName, Primary, ColDecls),
	printf(user, 'Update/Select tests passed: %t\n', [TableName]).

	%% RowsIn collects the rows inserted by test_inserts/4; they
	%% are then compared against the rows returned by a select all (select *)
	%% against the table:
test_inserts([], DBHandle, TableName, []).
test_inserts([DT | RestTestDataTerms], DBHandle, TableName, [Args | RestRowsIn])
	:-
	DT =.. [F | Args],
	insert_one_row(DBHandle, TableName, Args),
	test_inserts(RestTestDataTerms, DBHandle, TableName, RestRowsIn).

check_comp_ins_sel(RowsIn, AllSelection, TableName)
	:-
	length(RowsIn, LRI),
	length(AllSelection, LAS),
	fin_check_comp_ins_sel(LRI, LAS, RowsIn, AllSelection),
	!,
	printf(user, 'Insert/Select tests passed: %t\n', [TableName]).

fin_check_comp_ins_sel(N, N, RowsIn, AllSelection)
	:-!,
	comp_ins_sel(RowsIn, AllSelection).
fin_check_comp_ins_sel(LRI, LAS, RowsIn, AllSelection)
	:-
	printf(user, 'Insert/Select Error: Num inserted rows \= Num selected rows \n\tInserted rows = %t\n\tSelected rows = %t\n', [RowsIn, AllSelection]).

comp_ins_sel([], []).
	
comp_ins_sel([RI | RestRowsIn], [SR| RestAllSelection])
	:-
	SR =.. [r | SRArgs],
	(comp_rows(RI, SRArgs) ->
		comp_ins_sel(RestRowsIn, RestAllSelection)
		;
		printf(user, 'Insert/Select Error: \n\tinsert row %t \\= selected row %t\n', [RI, SRArgs])
	).

comp_rows([], []).
comp_rows([A | RestRI], [B | RestSRArgs])
	:-
	comp(A, B),
	comp_rows(RestRI, RestSRArgs).

comp(A, A)
	:- !.
comp(A, B)
	:-
	number(A),
	!,
	(A =:= B -> true ; printf('%t fails\n',[A =:= B])).

	%% Need have comp(___, '___') or comp('___', ___) succeed, where ___ has been interned:
comp(A, B)
	:-
	atom_codes(A, ACs),
	atom_codes(B, BCs),
	ucomp(ACs, BCs).

ucomp([0'', 0'' | ACs], [0'', 0'' | BCs])
	:-!,
	ucomp(ACs, BCs).
ucomp([0'' | ACs], [0'', 0'' | BCs])
	:-!,
	ucomp(ACs, BCs).
ucomp([0'', 0'' | ACs], [0'' | BCs])
	:-!,
	ucomp(ACs, BCs).
ucomp([0'' | ACs], [0'' | BCs])
	:-!,
	ucomp(ACs, BCs).
ucomp([0'' ], [])
	:-!.
ucomp([], [0''])
	:-!.

ucomp([C | ACs], [C | BCs])
	:-
	ucomp(ACs, BCs).
	
test_updates(UpdateDataTerms, DBHandle, TableName, Primary, ColArgs)
	:-
	primaryPos(ColArgs, Primary, PrimaryPosition),
	do_test_updates(UpdateDataTerms, DBHandle, TableName, Primary, PrimaryPosition, ColArgs).


primaryPos(ColArgs, Primary, PrimaryPosition)
	:-
	colPos(ColArgs, Primary, 1, PrimaryPosition).

colPos([a(Primary,_) | RestColDeclsTerm], Primary, PrimaryPosition, PrimaryPosition)
	:-!.
colPos([_ | RestColArgs], Primary, CurPosition, PrimaryPosition)
	:-
	NxtPos is CurPosition + 1,
	colPos(RestColArgs, Primary, NxtPos, PrimaryPosition).

do_test_updates([], DBHandle, TableName, Primary, PrimaryPosition, ColArgs).
do_test_updates([UpdateTerm | RestUpdateDataTerms], DBHandle, TableName, Primary, PrimaryPosition, ColArgs)
	:-
	test_update(UpdateTerm, DBHandle, TableName, Primary, PrimaryPosition, ColArgs),
	do_test_updates(RestUpdateDataTerms, DBHandle, TableName, Primary, PrimaryPosition, ColArgs).

test_update(UpdateTerm, DBHandle, TableName, Primary, PrimaryPosition, ColArgs)
	:-
	arg(PrimaryPosition, UpdateTerm, PUV),
	WhereClauseList = [ Primary = PUV],
	UpdateTerm =.. [_ | UpdateRow],
	make_setlist(ColArgs, UpdateRow, SetList, XpRes),
	sql_update(DBHandle, TableName, SetList, WhereClauseList),
	select_where_lists(DBHandle, TableName, '*', WhereClauseList, SelResult),
	comp_ins_sel([UpdateRow], SelResult).


	%% make_setlist(ColArgs, UpdateRow, SetList, XpRes),
make_setlist([a(ColName, Type) | RestColArgs], [UpdV | RestUpdateRow], 
			[Set | RestSetList], [r(ColName, UpdV) | RestXpRes])
	:-
	make_set(Type, ColName, UpdV, Set), 
	make_setlist(RestColArgs, RestUpdateRow, RestSetList, RestXpRes).

make_setlist([a(ColName, Type, Modifier) | RestColArgs], [UpdV | RestUpdateRow], 
			[Set | RestSetList], [r(ColName, UpdV) | RestXpRes])
	:-
	make_set(Type, ColName, UpdV, Set), 
	make_setlist(RestColArgs, RestUpdateRow, RestSetList, RestXpRes).

make_setlist([], [], [], []).

make_set(Type, ColName, UpdV, Set) 
	:-
	sql_text_type(Type),
	!,
	pat_atom('%t = ''%t'' ', [ColName, UpdV], Set).

make_set(Type, ColName, UpdV, Set) 
	:- 
	pat_atom('%t = %t', [ColName, UpdV], Set).

sql_text_type(text).
sql_text_type('TEXT').
sql_text_type(string).

	/* ----------------------------------------------------------------------------
	 * --------------------------------------------------------------------------- */
gen_intf_code(SpecInfo, FKInfoList)
	:-
	accessSpec(dbPath, SpecInfo, DBPath),
	pathPlusFile(DBDirPath, _, DBPath),

	accessSpec(dtFunc, SpecInfo, DtFunc),
	open(atom(MainBody), write, MS),
	create_intf_code(SpecInfo, DtFunc, DBPath, Exports, FKInfoList, MS),
	close(MS),

	catenate(DtFunc, '_code.pro', CodeFile),
	pathPlusFile(DBDirPath, CodeFile, CodeFilePath),

/*
%% fix als issues to avoid this:
%% ensure sqlite3_intf.* added to alsdir/shared
SearchDir = '/Users/ken/ALS/A64/SQLite',
	printf(S, ':-builtins:asserta(searchdir(''%t'')).\n',[SearchDir]),
*/

	open(CodeFilePath, write, S),
	printf(S, ':-[''sqlite3_intf.pro''].\n\n', []),
	
	printf(S, 'module dbmod_%t.\n', [DtFunc]),
	printf(S, 'use dbmod.\n', []),
	printf(S, 'use sqlite3.\n\n', []),

	write_exports(Exports, S),
	printf(S, '\n%t\nendmod.\n', [MainBody]),
	close(S).

write_exports([], S).
write_exports([Xp | Exports], S)
	:-
	printf(S, 'export %t.\n', [Xp]),
	write_exports(Exports, S).

	/* ----------------------------------------------------------------------------
	 * --------------------------------------------------------------------------- */
:- defStruct(genPreds,
    [
	propertiesList =
      [
	group_insert/inserts,
	open,
	insert,	
	insert_list,
	group_retrieve/retrieves,
	delete,
	clear,
	retr_p,
	suffix,
	get_handle
      ],
	accessPred  = accessGP,
        setPred     = setGP,
        makePred    = makeGP,
        structLabel = gp
    ]
   ).


	/* ----------------------------------------------------------------------------
	 * --------------------------------------------------------------------------- */
create_intf_code(SpecInfo, DtFunc, DBPath, Exports, FKInfoList, S)
	:-
	accessSpec(tableName, SpecInfo, TableName),

/*
	accessSpec(tableName, SpecInfo, TableName),
	accessSpec(primary, SpecInfo, Primary),
	accessSpec(colDecls, SpecInfo, ColDecls),
	accessSpec(testDataTerms, SpecInfo, TestDataTerms),
	accessSpec(updateDataTerms, SpecInfo, UpdateDataTerms),
*/
	printf(S, '\n', []),
	printf(S, 'db_path(''%t'').\n\n', [DBPath]),


	printf(S, '\n', []),
	accessSpec(colDecls, SpecInfo, ColDecls),
	col_nums_asserts(ColDecls, 1, ColNums, S),
	catenate('_db_', DtFunc, Suffix),
	accessSpec(primary, SpecInfo, Primary),

	makeGP(GenPreds),
        setGP(suffix, GenPreds, Suffix),
	catenate(get_handle, Suffix, GetHandlePred),
        setGP(get_handle, GenPreds, GetHandlePred),
	get_handle_code(SpecInfo, GenPreds, Suffix, DtFunc, DBPath, TableName, ExT0, FKInfoList, GetHandlePred, S),

%	open_session_code(SpecInfo, GenPreds, Suffix, DtFunc, DBPath, TableName, ExT0, FKInfoList, GetHandlePred, S),

	recreate_table_code(SpecInfo, GenPreds, Suffix, DtFunc, DBPath, TableName, ExT0, FKInfoList, GetHandlePred, S),
	

	insert_row_code(SpecInfo, GenPreds, Suffix, DtFunc, DBPath, TableName, ExT1, FKInfoList, GetHandlePred, S),

	retrieve_rows_code(SpecInfo, GenPreds, ColDecls, Suffix, DtFunc, DBPath, TableName, ExT2, GetHandlePred, S),

	update_row_code(SpecInfo, GenPreds, ColDecls, Suffix, DtFunc, DBPath, TableName, Primary, 
			IndexFields, FKInfoList, ExT3, GetHandlePred, S),

	delete_row_code(SpecInfo, GenPreds, ColDecls, Suffix, DtFunc, DBPath, TableName, Primary, 
			IndexFields, FKInfoList, ExT4, GetHandlePred, S),

	append([ExT0, ExT1,ExT2, ExT3, ExT4, ['all_tests/0'] ], Exports),

	test_code(SpecInfo, GenPreds, ColDecls, DtFunc, DBPath, TableName, Primary, IndexFields, FKInfoList, ColNums, ExT4, S),
	true.

col_nums_asserts([], _, [], S)
	:-
	printf(S, '\n', []).
col_nums_asserts([a(Col,_) | RestColDecls], ColNum, [cn(Col, ColNum) | RestColNums], S)
	:-
	printf(S, 'col_num(%t, %t).\n', [Col, ColNum]),
	NextColNum is ColNum + 1,
	col_nums_asserts(RestColDecls, NextColNum, RestColNums, S).

get_handle_code(SpecInfo, GenPreds, Suffix, DtFunc, DBPath, TableName, ExT0, FKInfoList, GetHandlePred, S)
	:-
	catenate(is_handle, Suffix, IsHandlePred),
	printf(S, ':- dynamic(%t/1).\n\n', [IsHandlePred]),
	printf(S, '%t(DBHandle)\n\t:-\n', [GetHandlePred]),
	printf(S, '\t%t(DBHandle).\n', [IsHandlePred]),
	printf(S, '%t(DBHandle)\n\t:-\n', [GetHandlePred]),
	printf(S, '\tdb_path(DBPath),\n', []),
	printf(S, '\tsqlite3_open(DBPath, DBHandle),\n', []),
	printf(S, '\tset_foreign_keys_on(DBHandle),\n', []),
	printf(S, '\tsqlite3_exec_norows(DBHandle, ''PRAGMA foreign_keys = 1;''),\n', []),
	printf(S, '\tabolish(%t,1),\n', [IsHandlePred]),
	printf(S, '\tassert(%t(DBHandle)).\n\n', [IsHandlePred]).


open_session_code(SpecInfo, GenPreds, Suffix, DtFunc, DBPath, TableName, ExT0, FKInfoList, GetHandlePred, S)
	:-
printf('-------%t/open\n', [DtFunc]),
	catenate(open, Suffix, OpenPred),
	catenate(dbhandle, Suffix, HandlePred),
	setGP(open, GenPreds, OpenPred),
	printf(S, '%t(DBHandle)\n\t:-\n', [OpenPred]),
	printf(S, '\tsqlite3_open(''%t'',DBHandle),\n', [DBPath]),
	printf(S, '\tassert(%t(DBHandle)),\n', [HandlePred]),
	printf(S, '\tset_foreign_keys_on(DBHandle).\n\n', []),
	ExT0 = [OpenPred/1].


recreate_table_code(SpecInfo, GenPreds, Suffix, DtFunc, DBPath, TableName, ExT0, FKInfoList, GetHandlePred, S)
	:-
	catenate(recreate_table, Suffix, RecreateTablePred),
	accessSpec(cts, SpecInfo, CreateTableString),
	printf(S, '%t\n\t:-\n', [RecreateTablePred]),
	printf(S, '\t%t(DBHandle),\n', [GetHandlePred]),
        printf(S, '\tsqlite3_exec_norows(DBHandle, ''%t'').\n\n', [CreateTableString]),
	ExT0 = [RecreateTablePred/0].


insert_row_code(SpecInfo,  GenPreds, Suffix, DtFunc, DBPath, TableName, ExT1, FKInfoList, GetHandlePred, S)
	:-
printf('-------%t/insert\n', [DtFunc]),
	catenate(insert, Suffix, InsertPred),
	setGP(insert, GenPreds, InsertPred),
	catenate(insert_list, Suffix, InsertListPred),
	setGP(insert_list, GenPreds, InsertListPred),
	catenate(InsertPred, '_q4', InsertQ4Pred),

	printf(S, '%t(TermOrArgs)\n\t:-\n', [InsertQ4Pred]),
        printf(S, '\t%t(TermOrArgs, true).\n\n',[InsertPred], [quoted(true)]),

	printf(S, '%t(TermOrArgs)\n\t:-\n', [InsertPred]),
        printf(S, '\t%t(TermOrArgs, false).\n\n',[InsertPred], [quoted(true)]),

	printf(S, '%t(TermOrArgs, Q4Boolean)\n\t:-\n', [InsertPred]),
	printf(S, '\t(TermOrArgs = [_ | _] -> ArgsList = TermOrArgs ; TermOrArgs =.. [_ | ArgsList]),\n', []),
	printf(S, '\t%t(DBHandle),\n', [GetHandlePred]),
        printf(S, '\tinsert_one_row(DBHandle, %t, ArgsList, Q4Boolean).\n\n',[TableName], [quoted(true)]),

	printf(S, '%t(ListOfRows)\n\t:-\n',[InsertListPred]),
	printf(S, '\t%t(DBHandle),\n', [GetHandlePred]),
        printf(S, '\tinsert_rows(ListOfRows, DBHandle, %t).\n\n', [TableName], [quoted(true)]),

	ExT1 = [InsertPred/1, InsertQ4Pred/1, InsertListPred/1].

retrieve_rows_code(SpecInfo,  GenPreds, ColDecls, Suffix, DtFunc, DBPath, TableName, ExT2, GetHandlePred, S)
	:-
	catenate(retrieve_primary, Suffix, RetrieveByPrimaryPred),
	setGP(retr_p, GenPreds, RetrieveByPrimaryPred),
	catenate(retrieve_all, Suffix, RetrieveAllPred),
	catenate(retrieve_as_term, Suffix, RetrieveAsTermPred),
	accessSpec(primary, SpecInfo, Primary),

	printf(S, '\t% retrieve by primary\n',[]),
        printf(S, '%t(PrimaryValue, Args)\n\t:-\n',[RetrieveByPrimaryPred]),
        printf(S, '\tSelectByPrimaryPat = ''SELECT * FROM %t WHERE %t = %t;'',\n',[TableName, Primary]),
        printf(S, '\topen(atom(SPP), write, S),\n',[]),
        printf(S, '\tprintf(S, SelectByPrimaryPat, [PrimaryValue]),\n',[]),
        printf(S, '\tclose(S),\n',[]),
	printf(S, '\t%t(DBHandle),\n', [GetHandlePred]),
        printf(S, '\tsqlite3_exec_rows(DBHandle, SPP, 1,  [Result_r_Row | _]),\n',[], [quoted(true)]),
        printf(S, '\tResult_r_Row =.. [_ | Args].\n\n',[]),

        printf(S, '%t(ResultList)\n\t:-\n',[RetrieveAllPred]),
	printf(S, '\t%t(DBHandle),\n', [GetHandlePred]),
	printf(S, '\tselect_all_table(DBHandle, %t, ResultList).\n\n', [TableName]),

	catenate(test_retrieve, Suffix, TestRetrieveByPrimaryPred),
	ExT2 = [RetrieveByPrimaryPred/2, RetrieveAllPred/1, TestRetrieveByPrimaryPred/0].

update_row_code(SpecInfo, GenPreds, ColDecls, Suffix, DtFunc, DBPath, TableName, Primary, IndexFields, FFKI, ExT3, GetHandlePred, S)
	:-
printf('-------%t/update\n', [DtFunc]),
	printf(S, 'update%t(PrimaryValue, ColUpdateVals)\n\t:-\n',[Suffix]),
        printf(S, '\tColDecls = %t,\n', [ColDecls]),
        printf(S, '\topen(atom(UpdateUIA), write, S),\n', []),
        printf(S, '\tprintf(S, ''UPDATE %t SET '', []),\n', [TableName]),
        printf(S, '\tinscribe_setlist(ColUpdateVals, ColDecls, S),\n',[]),
        printf(S, '\tprintf(S, '' WHERE %t = %t;'', [PrimaryValue]),\n',[Primary]),
        printf(S, '\tclose(S),\n',[]),
	printf(S, '\t%t(DBHandle),\n', [GetHandlePred]),
        printf(S, '\tsqlite3_exec_norows(DBHandle, UpdateUIA).\n\n',[]),

	printf(S, 'inscribe_setlist([], ArgDecls, S).\n',[]),
	printf(S, 'inscribe_setlist([UpdatePair | ColUpdateVals], ArgDecls, S)\n\t:-\n',[]),
        printf(S, '\tinscribe_set(UpdatePair, ArgDecls, S),\n',[]),
        printf(S, '\tinscribe_setlist(ColUpdateVals, ArgDecls, S).\n',[]),
	printf(S, 'inscribe_set([ColName, ColValue], ArgDecls, S)\n\t:-\n',[]),
        printf(S, '\tmember(a(ColName,ColType), ArgDecls),\n',[]),
        printf(S, '\tinscribe_set_expr(ColType, ColName, ColValue, S).\n',[]),

	printf(S, 'inscribe_set(UpdatePair, ArgDecls, S) \n\t:-\n',[]),
        printf(S, '\targ(1, UpdatePair, ColName), arg(2, UpdatePair, ColValue),\n',[]),
        printf(S, '\tmember(a(ColName,ColType), ArgDecls), \n',[]),
        printf(S, '\tinscribe_set_expr(ColType, ColName, ColValue, S).\n',[]),

	printf(S, 'inscribe_set_expr(ColType, ColName, ColValue, S)\n\t:-\n',[]),
        printf(S, '\tsql_text_type(ColType),\n',[]),
        printf(S, '\t!,\n',[]),
        printf(S, '\tprintf(S, ''%t = ''''%t'''''', [ColName,ColValue]).\n',[]),
        
	printf(S, 'inscribe_set_expr(ColType, ColName, ColValue, S)\n\t:-\n',[]),
        printf(S, '\tprintf(S, ''%t = %t'', [ColName,ColValue]).\n\n',[]),

	printf(S, 'sql_text_type(text).\n',[]),
	printf(S, 'sql_text_type(''TEXT'').\n',[]),
	printf(S, 'sql_text_type(string).\n',[]),
	catenate(update_, DtFunc, UpdatePred),
	ExT3 = [UpdatePred/2].	

delete_row_code(SpecInfo, GenPreds, ColDecls, Suffix, DtFunc, DBPath, TableName, Primary, IndexFields, FFKI, ExT4, GetHandlePred, S)
	:-
printf('-------%t/delete\n', [DtFunc]),
printf('-------Primary=%t\n\n', [Primary]),

	accessGP(suffix, GenPreds, Suffix),
	catenate(clear, Suffix, ClearPred),
	catenate(delete, Suffix, DeletePred),
	setGP(clear, GenPreds, ClearPred),
	setGP(delete, GenPreds, DeletePred),
	accessGP(get_handle, GenPreds, GetHandlePred),

	printf(S, '\n%t\n\t:-\n',[ClearPred]),
	printf(S, '\t%t(DBHandle),\n',[GetHandlePred]),
	printf(S, '\tsql_clear_table(DBHandle, %t_table).\n\n',[DtFunc]),

	printf(S, '\t% delete by primary\n',[]),
        printf(S, 'delete%t(PrimaryValue)\n\t:-\n',[Suffix]),
        printf(S, '\tDelPrimPat = ''DELETE FROM %t_table WHERE %t = %t;'',\n',[DtFunc, Primary]),
        printf(S, '\topen(atom(SPP), write, S),\n',[]),
        printf(S, '\tprintf(S, DelPrimPat, [PrimaryValue]),\n',[]),
        printf(S, '\tclose(S),\n',[]),
	printf(S, '\t%t(DBHandle),\n', [GetHandlePred]),
        printf(S, '\tsqlite3_exec_norows(DBHandle, SPP).\n',[]),
	ExT4 = [ClearPred/0,DeletePred/1].

test_code(SpecInfo, GenPreds, ColDecls, DtFunc, DBPath, TableName, Primary, IndexFields, FFKI, ColNums, ExT4, S)
	:-
	printf(S, '\n\n\t%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\t%%%%%%%% TESTS %%%%%%%%\n\t%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n\n', []),
	printf(S, 'all_tests\n\t:-\n', []),
	call_test_calls([test_inserts, test_retrieves], S),

	accessGP(clear, GenPreds, ClearPred),

		%% Insert tests:
	accessSpec(testDataTerms, SpecInfo, TestDataTerms),
	accessGP(insert, GenPreds, InsertPred),
	test_gen_insert(InsertPred, TestDataTerms, DBPath, TableName, TestInsertPred, ClearPred, S),
	accessGP(insert_list, GenPreds, InsertListPred),


	accessGP(insert_list, GenPreds, InsertListPred),
	test_gen_insert_list(InsertListPred, TestDataTerms, DBPath, TableName, TestInsertListPred, ClearPred, S),
	printf(S, '\n%t\n\t:-\n', [test_inserts]),
	call_test_calls([TestInsertPred, TestInsertListPred], S),

		%% Tests for retrieve :
	accessGP(retr_p, GenPreds, RetrieveByPrimaryPred),
	test_gen_retrieve_primary(RetrieveByPrimaryPred, TestDataTerms, DBPath, TableName, TestInsertPred, 
					TestRetrieveByPrimaryPred, ColNums, RetrieveByPrimaryPred, ClearPred, S),
	printf(S, '\n%t\n\t:-\n', [test_retrieves]),
	call_test_calls([TestRetrieveByPrimaryPred], S).

call_test_calls([], S)
	:-
	printf(S, '\ttrue.\n\n', []).
call_test_calls([Call | Calls], S)
	:-
	printf(S, '\t%t,\n', [Call]),
	call_test_calls(Calls, S).

	
call_test_calls([], S)
	:-
	printf(S, '\ttrue.\n\n', []).
call_test_calls([Call | Calls], S)
	:-
	printf(S, '\t%t,\n', [Call]),
	call_test_calls(Calls, S).

test_gen_insert(InsertPred, TestDataTerms, DBPath, TableName, TestInsertPred, ClearPred, S)
	:-
	catenate('test_', InsertPred, TestInsertPred),
	printf(S, '%t\n\t:-\n', [TestInsertPred]),
	printf(S, '\t%t,\n', [ClearPred], []),
	test_insert_calls(TestDataTerms, InsertPred, S).

test_insert_calls([], InsertPred, S)
	:-
	printf(S, '\ttrue.\n\n', [InsertPred]).
test_insert_calls([TestCall | TestDataTerms], InsertPred, S)
	:-
	printf(S, '\t%t(%t),\n', [InsertPred, TestCall], [quoted(true)]),
	test_insert_calls(TestDataTerms, InsertPred, S).

test_gen_insert_list(InsertListPred, TestDataTerms, DBPath, TableName, TestInsertListPred, ClearPred, S)
	:-
	catenate('test_', InsertListPred, TestInsertListPred),
	printf(S, '%t\n\t:-\n', [TestInsertListPred]),
	printf(S, '\t%t,\n', [ClearPred], []),
	printf(S, '\t%t(%t).\n\n\n', [InsertListPred, TestDataTerms], [quoted(true)]).

test_gen_retrieve_primary(RetrieveByPrimaryPred, TestDataTerms, DBPath, TableName, TestInsertPred, TestRetrieveByPrimaryPred, ColNums, RetrieveByPrimaryPred, ClearPred, S)
	:-
	catenate('test_', RetrieveByPrimaryPred, TestRetrieveByPrimaryPred),
	printf(S, '%t\n\t:-\n', [TestRetrieveByPrimaryPred]),
	printf(S, '\t%t,\n', [ClearPred], []),
	printf(S, '\t%t,\n', [TestInsertPred], [quoted(true)]),
	member(cn(Primary, PrimaryColNum), ColNums),
	test_retr_primary_data_calls(TestDataTerms, RetrieveByPrimaryPred, PrimaryColNum, S).

test_retr_primary_data_calls([], _, PrimaryColNum, S)
	:-
	printf(S, '\ttrue.\n\n', []).
test_retr_primary_data_calls([TestDataTerm | RestTestDataTerms], RetrieveByPrimaryPred, PrimaryColNum, S)
	:-
	arg(PrimaryColNum, TestDataTerm, PrimaryValue),
	printf(S, '\t%t(%t, _),\n', [RetrieveByPrimaryPred, PrimaryValue]),
	test_retr_primary_data_calls(RestTestDataTerms, RetrieveByPrimaryPred, PrimaryColNum, S).




	/* ------------------------------------------------------------------
	 |	---- 23-10-01: Believe this has been handled:
	 |   RESTRICTION until we can rely on Sqlite foreign key
	 |   constraint maintenance: both foreign key origin db spec
 	 |   and target file must be in the same dbSpec.
	 |   
	 | initReadSpecs(FileDBSpecs, DBSwitchValue, DBDirSwitchValue, FileSpecsList).
	 | initReadSpecs(FileDBSpecs, DBSwitchValue, DBDirSwitchValue, FileSpecsList).
	 | initReadSpecs(FileDBSpecs, DBSwitchValue, DBDirSwitchValue, FileSpecsList).
	 | 
	 | Decomposes the db(....) terms found in the list FileDBSpecs
	 * ------------------------------------------------------------------ */




/*--------------------------------------------------------------------------------------------*
	From https://www.sqlite.org/foreignkeys.html:

  SQLite uses the following terminology:
  
  The parent table is the table that a foreign key constraint refers to. The parent table in the 
  example in this section is the artist table. Some books and articles refer to this as the 
  referenced table, which is arguably more correct, but tends to lead to confusion.
  
  The child table is the table that a foreign key constraint is applied to and the table that 
  contains the REFERENCES clause. The example in this section uses the track table as the child 
  table.  Other books and articles refer to this as the referencing table.
  
  The parent key is the column or set of columns in the parent table that the foreign key 
  constraint refers to. This is normally, but not always, the primary key of the parent table. 
  The parent key must be a named column or columns in the parent table, not the rowid.
  
  The child key is the column or set of columns in the child table that are constrained by the 
  foreign key constraint and which hold the REFERENCES clause.

  >> Predicates below use the sqlite3 parent-child terminology.  In the artist-track example:

	parent --> artist
	child  --> track

	FFKI = FileForeignKeyInfo = 
		[..., <child table> - fk(<child col>, <parent table>, <parent col>), ...]
 *--------------------------------------------------------------------------------------------*/
fk_type(DtFunc, List, FKData, child)
	:-
	member( DtFunc + fk(ChildKey, ParentDtFunc, ParentKey), List),
	!,
	FKData =  DtFunc + fk(ChildKey, ParentDtFunc, ParentKey).
fk_type(DtFunc, List, FKData, parent)
	:-
	member( ChildDtFunc + fk(ChildKey, DtFunc, ParentKey), List),
	!,
	FKData = ChildDtFunc + fk(ChildKey, DtFunc, ParentKey).
fk_type(DtFunc, List, _, nothing).

fk_create_table_string(nothing, _, nothing)
	:-!.
fk_create_table_string(child, ChildDtFunc + fk(ChildKey, DtFunc, ParentKey), FKTableLine)
	:-!,
	    %%	CREATE TABLE track_table (trackid INT PRIMARY KEY, trackname TEXT, trackartist INT, 
	    %%	FOREIGN KEY(trackartist) REFERENCES artist(artistid) 
	pat_atom('FOREIGN KEY(%t) REFERENCES %t_table(%t) ', [ChildCol, ParentTable, ParentCol], FKTableLine).

fk_create_table_string(_, _, nothing).


fk_line(ForeignKeys, DtFunc, FKLine)
	:-
	member(child = ChildInfo, ForeignKeys),
	!,
	member(parent = ParentInfo, ForeignKeys),
	member(table = ChildTable, ChildInfo),
	member(column = ChildColumn, ChildInfo),
	member(table = ParentTable, ParentInfo),
	member(column = ParentColumn, ParentInfo),
	pat_atom('FOREIGN KEY(%t) REFERENCES %t_table(%t)', [ChildColumn, ParentTable, ParentColumn], FKLine).
fk_line(_, _, nothing).
	


	%% spec, dbd, tdb, dbd
processCommandLine(CmdInfo)
	:-
	makeCmdInfo(CmdInfo),
		% library: cmdline.pro:
        get_cmdline_vals(SwitchVals),
        pull_out_nullswitches(SwitchVals, LoneItems, SwitchPairsList),

		% -spec : an individual *.db_spec file to be processed (may include a path)
		%	  -dbd is ignored if -spec is present
	(member(['-spec',  SpecSwitchValue], SwitchPairsList),! ; SpecSwitchValue = ''),
		setCmd(spec, CmdInfo, SpecSwitchValue),

		% -dbd	: a folder in which to search for *.db_spec files; default = ./
		% 	  not used (even if present) if -spec is present
	(member(['-dbd',  DBDirSwitchValue], SwitchPairsList),! ; DBDirSwitchValue = ''),
		setCmd(dbd,CmdInfo, DBDirSwitchValue),

		% -db	: an explicit file to be  created as the sqlite3 db
		%	  does not have to exist; will be created if need be
	(member(['-db',  DBSwitchValue], SwitchPairsList),! ; DBSwitchValue = ''),
		setCmd(db,CmdInfo, DBSwitchValue),

		% -tdbd	: a folder in which to place all generated files; default = ./
	(member(['-tdbd',  TgtDBDirSwitchValue], SwitchPairsList),! ; TgtDBDirSwitchValue = ''),
		(TgtDBDirSwitchValue = '' ->
			setCmd(tdbd,CmdInfo, DBDirSwitchValue)
			;
			setCmd(tdbd,CmdInfo, TgtDBDirSwitchValue)
		).

hard_error(Category, Msg_Key, PatternArgs)
	:-
%printf(user, 'Starting hard_error: Msg_Key  = %t PatternArgs=%t \n', [Msg_Key, PatternArgs]),
	error_msg(Category, Msg_Key, Pattern),
	pat_atom(Pattern, PatternArgs, Msg),
	throw(dbsetup_error(Msg)).

warning(Category, Msg_Key, SpecLines)
	:-
	warning_msg(Category, Msg_Key, Pattern),
	printf(user, Pattern, [SpecLines]).

	% error_msg(Category, Msg_Key, SpeLinesc, Pattern)
error_msg(db_spec, missing_arg_decls, 'Error: %t: Missing arg_decls = ___\n\n').
error_msg(db_spec, missing_primary, 'Error: %t: Missing primary = ___\n\n').
error_msg(db_spec, unknown_type, 'Error: Unknown type: %t\n\n').
error_msg(db_spec, date_not_yet_implemented, 'Error: Type date not yet implemented\n\n').
error_msg(db_spec, Key, 'Error: %t \n\n').

warning_msg(db_spec, missing_index_fields, 'Warning: No index_fields found\n\n').
warning_msg(db_spec, missing_name, '\n>> ---- Warning: Missing Name\n\n').
warning_msg(db_spec, missing_data_file, 'Warning: Missing data_file = __ Using %t \n\n').


dbsetup_excpetion(ErrorInfo)
	:-
%printf(user, 'Starting dbsetup_excpetion: ErrorInfo = %t\n', [ErrorInfo]),
	printf(user, '\n========================\n', []),
	printf(user, 'ERROR: %t\n', [ErrorInfo]),
	flush_output,
	printf(user, 'Exiting\n\n', []).

endmod.
