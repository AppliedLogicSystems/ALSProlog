<HTML>
<HEAD>
<TITLE>defStruct/2</TITLE>
</HEAD><BODY>
<A NAME="1fd80a84"></A><B>defStruct/2
<P></P>
<A NAME="0342fdc9"></A><A NAME="0341e515"></A></B>defStruct/2 –  specify an abstract data type
<P></P>
<A NAME="0341e516"></A><B>FORMS
<P></P>
<A NAME="0341e519"></A></B>:- defStruct(TypeID, Equations). <A NAME="0341e517"></A> <A NAME="0341e518"></A><A NAME="0341e518"></A> 
<P></P>
<A NAME="0341e51a"></A><B>DESCRIPTION  
<P></P>
<A NAME="0341e51b"></A></B>Used as a directive to specify an <A NAME="034304ff"></A>abstract <A NAME="03430500"></A><A NAME="03430500"></A>datatype. <A NAME="03430501"></A>TypeID  is an atom functioning identifying the type.  <A NAME="03430503"></A>Equations is a list of <A NAME="03430502"></A><I>equality <A NAME="0343052f"></A><A NAME="0343052f"></A>statements</I> of the form:
<P></P>
<A NAME="0341e51c"></A>Left = Right 
<P></P>
<A NAME="0341e51d"></A>where the left component of the equality statements must be one of:
<P></P>
<A NAME="0341e549"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> propertiesList
<P></P>
<A NAME="0341e540"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> accessPred
<P></P>
<A NAME="0341e541"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> setPred
<P></P>
<A NAME="0341e542"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> makePred
<P></P>
<A NAME="0341e543"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> structLabel
<P></P>
<A NAME="0341e544"></A>The right sides of equality statements are Prolog terms whose structure
depends on the left side entry.    The right side corresponding to propertiesList is a list of atoms which are the symbolic names of the properties or slots of
the structure being defined.   For all of the rest of the equality statements,
  the right side is a single atom.
<P></P>
<A NAME="0341e546"></A><A NAME="0341e545"></A>accessPred The name of the ternary (3-argument) predicate to be used for accessing the
values of the slots in the structure.  Calls on a generated accessPred take the
form
<P></P>
 <A NAME="0341e547"></A>&lt;accessPred&gt;(&lt;slotname&gt;, &lt;Structure&gt;, Value)
<P></P>
<A NAME="0341e548"></A><A NAME="0341ecad"></A>setPred The name of the ternary (3-argument) predicate to be used for setting or
changing the values of the slots in the structure. Calls on a generated accessPred
take the form
<P></P>
 <A NAME="0341eca4"></A>&lt;setPred&gt;(&lt;slotname&gt;, &lt;Structure&gt;, Value)
<P></P>
<A NAME="0341eca5"></A>
<P></P>
<A NAME="0341eca6"></A><A NAME="0341eca7"></A>makePred The name of the unary predicate used for obtaining a fresh structure of the
defined type.
<P></P>
<A NAME="0341eca9"></A><A NAME="0341eca8"></A>structLabel  The name of the functor of the structure defined.
<P></P>
<A NAME="0341ecaa"></A><A NAME="0341ecab"></A>propertiesList A list of  <A NAME="0343052b"></A><A NAME="0343052b"></A><B><I>slot <A NAME="0343052c"></A><A NAME="0343052c"></A>specifications,</I></B> as follows:
<P></P>
<A NAME="0341ecac"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> an atom,  which is the name of the particular slot, or
<P></P>
<A NAME="0341eb2a"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> an expression of the form 
<P></P>
<A NAME="0341eb21"></A>     SlotName/Term, 
<P></P>
<A NAME="0341eb22"></A>where <A NAME="0343052d"></A>SlotName is an atom serving as the name of this slot, and Term is an arbitrary Prolog term which is the default value of this particular
slot, or
<P></P>
<A NAME="0341eb24"></A><IMG SRC="Bullet.gif" ALT="Bullet.gif" BORDER=0 WIDTH=3 HEIGHT=7> an  <A NAME="0341eb23"></A><B><I>include</I></B> expression which is a term of the form
<P></P>
<A NAME="0341eb25"></A>      include(File, Type) 
<P></P>
<A NAME="0341eb26"></A>where File is a path to a file, and Type is the name of a defStruct which appears in that file;  if File can be located, and if the defStruct Type appears in File, the elements of propertiesList for Type are interpolated at the point where the <I>include</I> expression occurred; <I>include</I> expressions may be recursively nested.  [Note:  Relative paths in recursive
includes must be valid from the directory in which the defStruct directive was
invoked.]
<P></P>
<A NAME="0341eb27"></A><B>EXAMPLES  
<P></P>
<A NAME="0341eb28"></A></B>:- defStruct(windows,
<P></P>
  <A NAME="0341eb29"></A>[
<P></P>
<A NAME="0341eb55"></A>     propertiesList =
<P></P>
  <A NAME="0341eb4c"></A>[windowName,  % name of the window
<P></P>
  <A NAME="0341eb4d"></A>windowNum,  % assigned by window sys
<P></P>
  <A NAME="0341eb4e"></A>borderColor/blue,  % for color displays
<P></P>
  <A NAME="0341eb4f"></A>borderType/sing,  % single or double lines
<P></P>
  <A NAME="0341eb50"></A>uLR, uLC,   % coords(Row,Col) of
<P></P>
      <A NAME="0341eb51"></A>% upper Left corner
<P></P>
  <A NAME="0341eb52"></A>lRR, lRC,   % coords(Row,Col) of
<P></P>
      <A NAME="0341eb53"></A>% lower Right corner
<P></P>
  <A NAME="0341eb54"></A>fore/black,    % foreground/background
<P></P>
  <A NAME="0341eb80"></A>back /white   % text attribs
<P></P>
<A NAME="0341eb77"></A>        ],
<P></P>
<A NAME="0341eb78"></A>     accessPred  = accessWI,
<P></P>
<A NAME="0341eb79"></A>     setPred     = setWI,
<P></P>
<A NAME="0341eb7a"></A>     makePred    = makeWindowStruct,
<P></P>
<A NAME="0341eb7b"></A>     structLabel = wi
<P></P>
<A NAME="0341eb7c"></A>    ]
<P></P>
<A NAME="0341eb7d"></A>   ).
<P></P>
<A NAME="0341eb7e"></A>Then:
<P></P>
<A NAME="0341eb7f"></A>...,makeWindowStruct(WIN),
<P></P>
 <A NAME="0341ebab"></A>...,setWI(windowName,WIN,foo),
<P></P>
  <A NAME="0341eba2"></A>...,accessWI(borderColor,WIN,BColor),...
<P></P>
<A NAME="0341d67a"></A>
<P></P>
</BODY>
</HTML>