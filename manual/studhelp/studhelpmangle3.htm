<HTML>
<HEAD>
<TITLE>mangle/3</TITLE>
</HEAD><BODY>
<A NAME="49e1a109"></A><B>mangle/3
<P></P>
<A NAME="84b4b9a8"></A><A NAME="82df5db9"></A></B>mangle/3 –  destructively modify a structure
<P></P>
<A NAME="84b4b9a9"></A><B>FORMS
<P></P>
<A NAME="84b4b9d2"></A></B>mangle(Nth,Structure,NewArg) <A NAME="84b4b9aa"></A>   <A NAME="84b4b9ab"></A><A NAME="84b4b9ab"></A>   <A NAME="84b4b9ac"></A>    <A NAME="84b4b9ad"></A>    <A NAME="84b4b9ae"></A>   <A NAME="84b4b9da"></A> <A NAME="84b4b9d1"></A> 
<P></P>
<A NAME="84b4b9d3"></A><B>DESCRIPTION  
<P></P>
<A NAME="84b4b9d5"></A></B>mangle/3 destructively modifies an argument of a compound term in a spirit
similar to Lisp’s rplaca and rplacd.   Structure must be instantiated to a compound term with at least N arguments.  The Nth argument of Structure will become NewArg. Lists are considered to be structures of arity two. 
<P></P>
<A NAME="84b4b9d6"></A>Modifications made to a structure by mangle/3 will survive failure and backtracking. 
<P></P>
<A NAME="84b4b9d7"></A>Even though mangle/3 implements destructive assignment in Prolog, it is not necessarily more
efficient than copying a term. This is due to the extensive cleanup operation which
ensures that the effects of a mangle/3 persist across failure. 
<P></P>
<A NAME="84b4b9d8"></A><B>EXAMPLES  
<P></P>
<A NAME="84b4b9d9"></A></B>?- Victim = doNot(fold,staple,mutilate), mangle(2,Victim,spindle). 
<P></P>
<A NAME="84b4ba05"></A>Victim = doNot(fold,spindle,mutilate) 
<P></P>
<A NAME="84b4b9fc"></A>yes. 
<P></P>
<A NAME="84b4b9fd"></A><B>SEE ALSO 
<P></P>
<A NAME="84b4b9fe"></A></B>arg/3. 
<P></P>
</BODY>
</HTML>