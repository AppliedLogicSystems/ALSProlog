<HTML>
<HEAD>
<TITLE>clause/[2,3]</TITLE>
</HEAD><BODY>
<A NAME="49f6f3b4"></A><B>clause/[2,3]
<P></P>
<A NAME="23c051e4"></A><A NAME="422807bb"></A></B>clause/2 –  retrieve a clause
<P></P>
<A NAME="23c051e5"></A>clause/3 –  retrieve a clause with a database reference
<P></P>
<A NAME="23c051e6"></A><A NAME="4405ea11"></A>instance/2 –  retrieve a clause from the database reference
<P></P>
<A NAME="23c051e7"></A><B>FORMS
<P></P>
<A NAME="23c051e8"></A></B>clause(Head,Body) 
<P></P>
<A NAME="23c05214"></A>clause(Head,Body, Ref) 
<P></P>
<A NAME="23c05971"></A>instance(Ref,Clause) <A NAME="23c0520b"></A><A NAME="23c0520b"></A> <A NAME="23c0520c"></A><A NAME="23c0520c"></A> <A NAME="23c0520d"></A><A NAME="23c0520d"></A> <A NAME="23c0520e"></A> <A NAME="23c0520f"></A><A NAME="23c0520f"></A> <A NAME="23c05210"></A> <A NAME="23c05211"></A><A NAME="23c05211"></A> <A NAME="23c05212"></A><A NAME="23c05212"></A> <A NAME="23c05213"></A> <A NAME="23c05978"></A> <A NAME="23c0596f"></A><A NAME="23c05970"></A> 
<P></P>
<A NAME="23c05972"></A><B>DESCRIPTION  
<P></P>
<A NAME="23c05973"></A></B>When Head is bound to a non-variable term, the current module is searched for a clause
whose head matches Head and whose body matches Body.  If there is more than one clause that matches, then successive Heads and Bodys will be generated upon backtracking. 
<P></P>
<A NAME="23c05974"></A>When a fact is found, Body will be unified with the atom true. 
<P></P>
<A NAME="23c05975"></A>clause/3 unifies its third argument with the database reference that corresponds to
the clause that was found.  When Ref is instantiated in a call to clause/3, the other two arguments can be uninstantiated. 
<P></P>
<A NAME="23c05976"></A>:/2 can be used to specify which module should be searched.  If Ref is a valid database reference, instance(Ref, Clause) retrieves the Prolog clause referenced by Ref and unifies it with Clause. 
<P></P>
<A NAME="23c05977"></A><B>EXAMPLES  
<P></P>
<A NAME="23c057f5"></A></B>The following examples show the use of clause/2 :
<P></P>
<A NAME="23c057ec"></A>?- listing(fruit/1). 
<P></P>
<A NAME="23c057ed"></A>% user:fruit/1 
<P></P>
<A NAME="23c057ee"></A>fruit(apple). 
<P></P>
<A NAME="23c057ef"></A>fruit(_34) :- 
<P></P>
  <A NAME="23c057f0"></A>product(_34,plantGrowth) 
<P></P>
  <A NAME="23c057f1"></A>;  product(_34,plantFertilization). 
<P></P>
<A NAME="23c057f2"></A>fruit(orange). 
<P></P>
<A NAME="23c057f3"></A>
<P></P>
<A NAME="23c057f4"></A>% unusual:fruit/1 
<P></P>
<A NAME="23c05820"></A>fruit(tomato). 
<P></P>
<A NAME="23c05817"></A>fruit(kiwi). 
<P></P>
<A NAME="23c05818"></A>
<P></P>
<A NAME="23c05819"></A>yes. 
<P></P>
<A NAME="23c0581a"></A>?- clause(fruit(apple),true). 
<P></P>
<A NAME="23c0581b"></A>
<P></P>
<A NAME="23c0581c"></A>yes. 
<P></P>
<A NAME="23c0581d"></A>
<P></P>
<A NAME="23c0581e"></A>?- clause(fruit(X), Body). 
<P></P>
<A NAME="23c0581f"></A>X = apple 
<P></P>
<A NAME="23c0584b"></A>Body = true; 
<P></P>
<A NAME="23c05842"></A>
<P></P>
<A NAME="23c05843"></A>X = _1 
<P></P>
<A NAME="23c05844"></A>Body = (product(_1,plantGrowth);
<P></P>
   <A NAME="23c05845"></A>product(_1,plantFertilization)); 
<P></P>
<A NAME="23c05846"></A>      
<P></P>
<A NAME="23c05847"></A>X = orange 
<P></P>
<A NAME="23c05848"></A>Body = true; 
<P></P>
<A NAME="23c05849"></A>
<P></P>
<A NAME="23c0584a"></A>no. 
<P></P>
<A NAME="23c05876"></A>?- unusual:clause(fruit(X),Body). 
<P></P>
<A NAME="23c0586d"></A>X = tomato 
<P></P>
<A NAME="23c0586e"></A>Body = true; 
<P></P>
<A NAME="23c0586f"></A>
<P></P>
<A NAME="23c05870"></A>X = kiwi 
<P></P>
<A NAME="23c05871"></A>Body = true; 
<P></P>
<A NAME="23c05872"></A>
<P></P>
<A NAME="23c05873"></A>no. 
<P></P>
<A NAME="23c05874"></A><B>ERRORS  
<P></P>
<A NAME="23c05875"></A></B>If Ref is not instantiated to a database reference and Head is uninstantiated, the call to   clause/3 fails. 
<P></P>
<A NAME="23c058a1"></A><B>SEE ALSO  
<P></P>
<A NAME="23c05898"></A></B>[Bowen 91, 7.3], [Sterling 86, 12.2], [Clocksin 81, 6.4]. 
<P></P>
</BODY>
</HTML>