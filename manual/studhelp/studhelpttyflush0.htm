<HTML>
<HEAD>
<TITLE>ttyflush/0</TITLE>
</HEAD><BODY>
<A NAME="00e88060"></A><B>ttyflush/0
<P></P>
<A NAME="02bdfa3c"></A><A NAME="00e88091"></A></B>ttyflush/0 –  forces all buffered output to the screen
<P></P>
<A NAME="02bdf8ba"></A><B>FORMS
<P></P>
<A NAME="02bdf8b1"></A></B>ttyflush 
<P></P>
<A NAME="02bdf8b2"></A><B>DESCRIPTION  
<P></P>
<A NAME="02bdf8b3"></A></B>ttyflush/0 is used to make sure that output from tty I/O predicates appears on the
screen when you want it to. Screen output is normally flushed whenever Prolog is
waiting on some I/O operation. Typically, the I/O operation that is waited on is
some form of tty read. In this case, you don’t have to use ttyflush. 
<P></P>
<A NAME="02bdf8b4"></A>A long computation, while causing you to wait for a response, does not qualify
as an I/O operation, so any output predicates that were run before the CPU hog
started, might not show their output on the screen until the long computation
is finished. To combat this problem, ttyflush/0 can be used before entering into the long computation section of your
program. 
<P></P>
<A NAME="02bdf8b5"></A><B>EXAMPLES  
<P></P>
<A NAME="02bdf8b6"></A></B>If we define the following useless predicate:
<P></P>
<A NAME="02bdf8b7"></A>
<P></P>
<A NAME="02bdf8b8"></A>infiniteLoop :- infiniteLoop. 
<P></P>
<A NAME="02bdf8b9"></A>and then try to write something to the screen before running it:
<P></P>
<A NAME="02bdf8e5"></A>
<P></P>
<A NAME="02bdf8dc"></A>?- printf(&quot;April Fool’s Day&quot;), infiniteLoop. 
<P></P>
<A NAME="02bdf8dd"></A>April Fool's Day    Break Handler
<P></P>
<A NAME="02bdf8de"></A>    ------------------------
<P></P>
<A NAME="02bdf8df"></A>    a - Abort Computation
<P></P>
<A NAME="02bdf8e0"></A>    b - Break shell
<P></P>
<A NAME="02bdf8e1"></A>    c - Continue
<P></P>
<A NAME="02bdf8e2"></A>    d - Debug
<P></P>
<A NAME="02bdf8e3"></A>    e - Exit Prolog
<P></P>
<A NAME="02bdf8e4"></A>    f - Fail
<P></P>
<A NAME="02bdf910"></A>    p - Return to Previous Break Level
<P></P>
<A NAME="02bdf907"></A>    s - Show goal broken at
<P></P>
<A NAME="02bdf908"></A>    t - Stack trace
<P></P>
<A NAME="02bdf909"></A>    ? - This message
<P></P>
<A NAME="02bdf90a"></A>Break(1) &gt;a
<P></P>
<A NAME="02bdf90b"></A>
<P></P>
<A NAME="02bdf90c"></A>Warning: Aborting from Control-C or Control-Break.
<P></P>
<A NAME="02bdf90d"></A>
<P></P>
<A NAME="02bdf90e"></A>Error: Execution aborted.
<P></P>
<A NAME="02bdf90f"></A>
<P></P>
<A NAME="02bdf93b"></A>we find that the output doesn’t appear until the Control-C  is pressed. We can avoid this problem by putting a call to ttyflush/0 after the message printing predicate. The following example shows the result:
<P></P>
<A NAME="02bdf932"></A>
<P></P>
<A NAME="02bdf933"></A>?- printf(&quot;April Fool’s Day&quot;), ttyflush, infiniteLoop. 
<P></P>
<A NAME="02bdf934"></A>April Fool's Day    Break Handler
<P></P>
<A NAME="02bdf935"></A>    ------------------------
<P></P>
<A NAME="02bdf936"></A>    a - Abort Computation
<P></P>
<A NAME="02bdf937"></A>    b - Break shell
<P></P>
<A NAME="02bdf938"></A>    c - Continue
<P></P>
<A NAME="02bdf939"></A>    d - Debug
<P></P>
<A NAME="02bdf93a"></A>    e - Exit Prolog
<P></P>
<A NAME="02bdf966"></A>    f - Fail
<P></P>
<A NAME="02bdf95d"></A>    p - Return to Previous Break Level
<P></P>
<A NAME="02bdf95e"></A>    s - Show goal broken at
<P></P>
<A NAME="02bdf95f"></A>    t - Stack trace
<P></P>
<A NAME="02bdf960"></A>    ? - This message
<P></P>
<A NAME="02bdf961"></A>Break(1) &gt;a
<P></P>
<A NAME="02bdf962"></A>
<P></P>
<A NAME="02bdf963"></A>Warning: Aborting from Control-C or Control-Break.
<P></P>
<A NAME="02bdf964"></A>
<P></P>
<A NAME="02bdf965"></A>Error: Execution aborted.
<P></P>
<A NAME="02bdf991"></A><B>NOTES  
<P></P>
<A NAME="02bdf988"></A></B>The ISO Standard mandates that flush_output/[0,1] is preferred over ttyflush/0.  
<P></P>
<A NAME="02bdf989"></A><B>SEE ALSO  
<P></P>
<A NAME="02bdf98a"></A></B>printf/1, write/1, put/1, flush_output/[0,1].
<P></P>
</BODY>
</HTML>