<HTML>
<HEAD>
<TITLE>'=='/2</TITLE>
</HEAD><BODY>
‘==’/2
<P></P>
<A NAME="82df4738"></A><A NAME="a24666c8"></A><A NAME="a24666f4"></A><A NAME="0000f92f"></A>==/2 –  terms are identical
<P></P>
<A NAME="84be9a1c"></A><A NAME="a24666eb"></A>\==/2 –  terms are not identical
<P></P>
<A NAME="a24666ec"></A><B>FORMS
<P></P>
<A NAME="a24666ed"></A></B>Term1  == Term2 
<P></P>
<A NAME="a24666f1"></A>Term1 \== Term2 <A NAME="a24666ee"></A><A NAME="a24666ee"></A>   <A NAME="a24666ef"></A><A NAME="a24666ef"></A>   <A NAME="a24666f0"></A> 
<P></P>
<A NAME="a24666f2"></A><B>DESCRIPTION 
<P></P>
<A NAME="a24666f3"></A></B>Term1 is identical to Term2 (Term1 == Term2) if they can be unified, and variables occupying equivalent positions in both
terms are identical.  For atoms and variables, this is an absolute identity
check.  Viewing Prolog terms as trees in memory,  ==/2 determines whether Term1 and Term2 are isomorphic trees whose leaves are identical.  Unlike =/2, no variables are bound inside a call to   <A NAME="a246671f"></A>==/2. \== fails when == succeeds, and conversely.  
<P></P>
<A NAME="a2466717"></A><B>EXAMPLES 
<P></P>
<A NAME="a2466718"></A></B>?- bar \== foo. 
<P></P>
<A NAME="a2466719"></A>
<P></P>
<A NAME="a246671a"></A>yes. 
<P></P>
<A NAME="a246671b"></A>?- f(b) == f(b). 
<P></P>
<A NAME="a246671c"></A>
<P></P>
<A NAME="a246671d"></A>yes. 
<P></P>
<A NAME="a246671e"></A>?- X == Y. 
<P></P>
<A NAME="a246674a"></A>
<P></P>
<A NAME="a2466741"></A>no. 
<P></P>
<A NAME="a2466742"></A>?- f(X) \== f(X). 
<P></P>
<A NAME="a2466743"></A>
<P></P>
<A NAME="a2466744"></A>no. 
<P></P>
<A NAME="a2466745"></A>?- [a,b,c] \== [a,b,c]. 
<P></P>
<A NAME="a2466746"></A>
<P></P>
<A NAME="a2466747"></A>no. 
<P></P>
<A NAME="a2466748"></A><B>SEE ALSO 
<P></P>
<A NAME="a2466749"></A></B>[Bowen 91, 7.4], [Clocksin 81, 6.8], [Bratko 86, 3.4]. 
<P></P>
<A NAME="84bac9b4"></A>
<P></P>
</BODY>
</HTML>