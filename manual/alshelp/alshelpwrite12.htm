<HTML>
<HEAD>
<TITLE>write/[1,2]</TITLE>
</HEAD><BODY>
<A NAME="95b5b6a4"></A>write/\[1,2\]
<P></P>
<A NAME="00e880e1"></A><A NAME="02be0144"></A>write/1 –  write term to current output stream
<P></P>
<A NAME="02be0145"></A>write/2 –  write term to specified stream
<P></P>
<A NAME="00e613b8"></A><A NAME="02be0146"></A>writeq/1 –  write term to current output stream so that it may be  read back in
<P></P>
<A NAME="02be0147"></A>writeq/2 –  write term to specified stream so that it may be read back in
<P></P>
<A NAME="02be0148"></A>write_canonical/1 –  write term to current output stream in canonical form (no operators)
<P></P>
<A NAME="02be0149"></A><A NAME="00e613bf"></A>write_canonical/2 –  write term to specified stream in canonical form
<P></P>
<A NAME="02be014a"></A><A NAME="00e613c0"></A>write_term/2 –  write term to current output stream with options
<P></P>
<A NAME="02be08af"></A>write_term/3 –  write term to specified output stream with options
<P></P>
<A NAME="00e613ec"></A><A NAME="02be08a6"></A>display/1 –  write term to current output stream in canonical form
<P></P>
<A NAME="02be08a7"></A><B>FORMS
<P></P>
<A NAME="02be08a8"></A></B>write(Term)
<P></P>
<A NAME="02be08a9"></A>write(Stream_or_Alias,Term)
<P></P>
<A NAME="02be08aa"></A>writeq(Term)
<P></P>
<A NAME="02be08ab"></A>writeq(Stream_or_Alias,Term)
<P></P>
<A NAME="02be08ac"></A>write_canonical(Term)
<P></P>
<A NAME="02be08ad"></A>write_canonical(Stream_or_Alias,Term)
<P></P>
<A NAME="02be08ae"></A>write_term(Term,Options)
<P></P>
<A NAME="02be072c"></A>write_term(Stream_or_Alias,Term,Options)
<P></P>
<A NAME="02be074e"></A>display(Term) <A NAME="02be0723"></A>   <A NAME="02be0724"></A>   <A NAME="02be0725"></A>   <A NAME="02be0726"></A>   <A NAME="02be0727"></A><A NAME="02be0727"></A>   <A NAME="02be0728"></A><A NAME="02be0728"></A>   <A NAME="02be0729"></A><A NAME="02be0729"></A>   <A NAME="02be072a"></A><A NAME="02be072a"></A>   <A NAME="02be072b"></A>   <A NAME="02be0757"></A> 
<P></P>
<A NAME="02be074f"></A><B>DESCRIPTION  
<P></P>
<A NAME="02be0750"></A></B>These predicates will output the term bound to Term to a stream. The format of
the term is controlled by which variant is called or by an option given to write_term.  None of these procedures output a fullstop after the term written.
<P></P>
<A NAME="02be0751"></A>write/1 behaves as if write/2 were called with the current output stream as the Stream_or_Alias argument.
<P></P>
<A NAME="02be0752"></A>write/2 behaves as if write_term/3 were called with Options bound to
<P></P>
 <A NAME="02be0753"></A>[quoted(false),numbervars(true),lettervars(false),
<P></P>
  <A NAME="02be0754"></A>line_length(1024). 
<P></P>
<A NAME="02be0755"></A>In addition, the default line length is ignored and set to a large number,
causing the output of long terms to not be pretty printed.  Variables are printed
as underscore followed by some number.
<P></P>
<A NAME="02be0756"></A>writeq/1 behaves as if writeq/2 were called with the current output stream as the Stream_or_Alias argument.
<P></P>
<A NAME="02be0782"></A>writeq/2 behaves as if write_term/3 were called with Options bound to 
<P></P>
 <A NAME="02be0779"></A>[quoted(true),numbervars(true),lettervars(true)].  
<P></P>
<A NAME="02be077a"></A>The line length is set to the default line length for the stream which is
being output to.  Variables are printed as an underscore followed by a capital
letter.  writeq is useful for outputting a term whichmight be later subject to a read from
Prolog.
<P></P>
<A NAME="02be077b"></A>write_canonical/1 behaves as if write_canonical/2 were called with the current output stream bound to the Stream_or_Alias argument.
<P></P>
<A NAME="02be077c"></A>write_canonical/2 behaves as if write_term/3 were called with Options bound to 
<P></P>
 <A NAME="02be077d"></A>[quoted(true),ignore_ops(true),lettervars(true)].
<P></P>
<A NAME="02be077e"></A>This is the same behavior supplied by the DEC-10 compatiblity predicate display/1.  write_canonical is useful in situations where it is desirable to output a term in a format
which may subsequently read in without regard to operator definitions.  Such
terms are not particularly  pleasing to look at, however.
<P></P>
<A NAME="02be077f"></A>write_term/2 behaves as if write_term/3 were called with the current output stream bound to Stream_or_Alias.
<P></P>
<A NAME="02be0780"></A>write_term/3 writes out the term Term to the output stream associated with Stream_or_Alias and subject to the options in the write option list Options.  The options in the write options list control how a term is output. 
<P></P>
<A NAME="02be0781"></A> The options mandated by the draft standard are:
<P></P>
<A NAME="02be07ad"></A><UL><LI>uoted(Bool)  –  Bool is true or false.  When Bool is true, atoms and functors are written out in such a manner so that read/[1,2] may be used to read them back in; when Bool is false indicates that symbols should be written out without any special quoting;
control characters embedded in an atom will be written out as is.
<P></P>
<A NAME="02be07a4"></A></UL>ignore_ops(Bool) – Bool may be true or false.  When Bool is true, compound terms are output in functional notation.  
<P></P>
<A NAME="02be07a5"></A>numbervars(Bool) –  When Bool is true, a term of the form '$VAR'(N), where N is a non-negative integer, will be output as a variable name consisting of a
capital letter possibly followed by an integer.  The capital letter is the
(i+1)th letter of the alphabet, and the integer is j, where i = N mod 26 and j = N
div 26.  The integer j is omitted if it is zero.
<P></P>
<A NAME="02be07a6"></A>Other options not mandated by the draft standard but supported by ALS Prolog
are:
<P></P>
<A NAME="02be07a7"></A>lettervars(Bool) –  If Bool is true, variables will be printed out as an underscore followed by a letter and
digits if necessary.  If Bool is false, variables will be printed as _N, where N is computed using the address where the variable lives at.  This latter mode
is more suited to debugging purposes where correspondences between variables in
various calls is required.
<P></P>
<A NAME="02be07a8"></A>maxdepth(N,Atom1,Atom2) – N is the maximum depth to print to.  Atom1 is the atom to output when this depth has been reached. Atom2 is the atom to output when this depth has been reached at the tail of a list.
<P></P>
<A NAME="02be07a9"></A>maxdepth(N)  –  same as maxdepth(N,*,...)
<P></P>
<A NAME="02be07aa"></A>depth_computation(Val) – Val may be either flat or nonflat.  This indicates the method of depth computation.  If Val is bound to flat, all arguments of a term or list will be treated as being at the same depth. 
If Val is nonflat, then each subsequent argument in a term (or each subsequent element of a
list) will be considered to be at a depth one greater than the preceding structure
argument (or list element).
<P></P>
<A NAME="02be07ab"></A>line_length(N) –  N is the length in characters of the output line. The pretty printer will
attempt to break lines before they exceed the given line length.
<P></P>
<A NAME="02be07ac"></A>indent(N)  –  N specifies the initial indentation in characters to use for the second and
subsequent lines output (if any).
<P></P>
<A NAME="02be07d8"></A><UL><LI>uoted_strings(Bool) –  If Bool is true, lists of suitable character codes will print out as double quoted strings. 
If false, these lists will print out as lists of small integers.
<P></P>
<A NAME="02be07cf"></A></UL><B>EXAMPLES  
<P></P>
<A NAME="02be07d0"></A></B>?- X = 'Hello\tthere',
<P></P>
<A NAME="02be07d1"></A>?-_  write(X),nl,
<P></P>
<A NAME="02be07d2"></A>?-_  writeq(X),nl,
<P></P>
<A NAME="02be07d3"></A>?-_  write_canonical(X),nl.
<P></P>
<A NAME="02be07d4"></A>Hello    there
<P></P>
<A NAME="02be07d5"></A>'Hello\tthere'
<P></P>
<A NAME="02be07d6"></A>'Hello\tthere'
<P></P>
<A NAME="02be07d7"></A>
<P></P>
<A NAME="02be0803"></A>X = 'Hello\tthere'
<P></P>
<A NAME="02be07fa"></A>
<P></P>
<A NAME="02be07fb"></A>
<P></P>
<A NAME="02be07fc"></A>
<P></P>
<A NAME="02be07fd"></A>?- T = [3+4,'$VAR'(26) * X - 'Y'],
<P></P>
<A NAME="02be07fe"></A>?-_  write(T), nl,
<P></P>
<A NAME="02be07ff"></A>?-_  writeq(T), nl,
<P></P>
<A NAME="02be0800"></A>?-_  write_canonical(T), nl.
<P></P>
<A NAME="02be0801"></A>[3+4,A1*_4100-Y]
<P></P>
<A NAME="02be0802"></A>[3+4,A1*_A-'Y']
<P></P>
<A NAME="02be082e"></A>.(+(3,4),.(-(*('$VAR'(26),_A),'Y'),[]))
<P></P>
<A NAME="02be0825"></A>
<P></P>
<A NAME="02be0826"></A>T = [3+4,'$VAR'(26)*X-'Y']
<P></P>
<A NAME="02be0827"></A>X = X
<P></P>
<A NAME="02be082b"></A>
<P></P>
<A NAME="02be082c"></A>?- L =
<P></P>
<A NAME="02be082d"></A>[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z],
<P></P>
<A NAME="02be0859"></A>?-_  write_term(L,[line_length(20)]), nl,
<P></P>
<A NAME="02be0850"></A>?-_  write('list: '),
<P></P>
<A NAME="02be0851"></A>?-_ write_term(L,[line_length(26),indent(6)]),nl.
<P></P>
<A NAME="02be0852"></A>[a,b,c,d,e,f,g,h,i,
<P></P>
 <A NAME="02be0853"></A>    j,k,l,m,n,o,p,
<P></P>
 <A NAME="02be0854"></A>    q,r,s,t,u,v,w,
<P></P>
 <A NAME="02be0855"></A>    x,y,z]
<P></P>
<A NAME="02be0856"></A>list: [a,b,c,d,e,f,g,h,i,
<P></P>
  <A NAME="02be0857"></A>      j,k,l,m,n,o,p,
<P></P>
  <A NAME="02be0858"></A>      q,r,s,t,u,v,w,
<P></P>
  <A NAME="02be0884"></A>      x,y,z]
<P></P>
<A NAME="02be087b"></A>
<P></P>
<A NAME="02be087c"></A>L = [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
<P></P>
<A NAME="02be087d"></A>
<P></P>
<A NAME="02be087e"></A>
<P></P>
<A NAME="02be087f"></A>?- S = &quot;A string&quot;,
<P></P>
<A NAME="02be0880"></A>?-_  write_term(S, [quoted_strings(true)]),nl,
<P></P>
<A NAME="02be0881"></A>?-_  write_term(S, [quoted_strings(false)]),nl.
<P></P>
<A NAME="02be0882"></A>&quot;A string&quot;
<P></P>
<A NAME="02be0883"></A>[65,32,115,116,114,105,110,103]
<P></P>
<A NAME="02be0fe8"></A>
<P></P>
<A NAME="02be0fdf"></A>S = &quot;A string&quot;
<P></P>
<A NAME="02be0fe0"></A>
<P></P>
<A NAME="02be0fe1"></A>
<P></P>
<A NAME="02be0fe2"></A>?- T = [a(b(c(d))), a(b(c(d))), a(b(c(d))), a(b(c(d)))],
<P></P>
<A NAME="02be0fe3"></A>?-_  write_term(T, [maxdepth(3), depth_computation(flat)]), nl,
<P></P>
<A NAME="02be0fe4"></A>?-_  write_term(T, [maxdepth(3), depth_computation(nonflat)]), nl.
<P></P>
<A NAME="02be0fe5"></A>[a(b(*)),a(b(*)),a(b(*)),a(b(*))]
<P></P>
<A NAME="02be0fe6"></A>[a(b(*)),a(*),*,...]
<P></P>
<A NAME="02be0fe7"></A>
<P></P>
<A NAME="02be0e65"></A>T = [a(b(c(d))),a(b(c(d))),a(b(c(d))),a(b(c(d)))]
<P></P>
<A NAME="02be0e5c"></A><B>ERRORS
<P></P>
<A NAME="02be0e5d"></A></B>Stream_or_Alias is a variable
<P></P>
  <A NAME="02be0e5e"></A>––––&gt;  instantiation_error.
<P></P>
<A NAME="02be0e5f"></A>Stream_or_Alias is neither a variable nor a stream descriptor nor an alias
<P></P>
  <A NAME="02be0e60"></A>––––&gt;  domain_error(stream_or_alias,Stream_or_Alias).
<P></P>
<A NAME="02be0e61"></A>Stream_or_Alias is not associated with an open stream
<P></P>
  <A NAME="02be0e62"></A>––––&gt;  existence_error(stream,Stream_or_Alias).
<P></P>
<A NAME="02be0e63"></A>Stream_or_Alias is not an output stream
<P></P>
  <A NAME="02be0e64"></A>––––&gt;  permission_error(output,stream,Stream_or_Alias).
<P></P>
<A NAME="02be0e90"></A>Options is a variable
<P></P>
  <A NAME="02be0e87"></A>––––&gt;  instantiation_error.
<P></P>
<A NAME="02be0e88"></A>Options is neither a variable nor a list
<P></P>
  <A NAME="02be0e89"></A>––––&gt;  type_error(list,Option).
<P></P>
<A NAME="02be0e8a"></A>Options is a list an element of which is a variable
<P></P>
  <A NAME="02be0e8b"></A>––––&gt;  instantiation_error.
<P></P>
<A NAME="02be0e8c"></A>Options is a list containing an element E which is neither a variable nor a
valid write option
<P></P>
  <A NAME="02be0e8d"></A>––––&gt;  domain_error(write_option,E).
<P></P>
<A NAME="02be0e8e"></A><B>SEE ALSO  
<P></P>
<A NAME="02be0e8f"></A></B>read_term/[2,3], read/[1,2], open/4, close/1, nl/[0,1],    put_char/[1,2],
put_code/[1,2], set_line_length/2,                  op/3, tell/1,<I>User Guide (Prolog I/O), [Bowen 91, 7.8], [Clocksin 81, 6.9], [Sterling 86,
12.1], [Bratko 86, 6.2.1].
<P></P>
</I></BODY>
</HTML>