<HTML >
<HEAD >
<TITLE >bufread/[2, 4] </TITLE >
</HEAD><BODY>
<B >bufread/[2, 4] </B> 
<P></P>
bufread/2 &mdash; - runs the Prolog parser on a string of text 
<P></P>
bufread/4 &mdash; - similiar to bufread/2, giving additional information 
<P></P>
<B>FORMS</B>
<P ></P >
</B >bufread ( Buffer, [Structure | Vars] ) 
<P ></P >
bufread ( Buffer, [Structure | Vars], FullStop, LeftOver ) 
<P ></P >
<B >DESCRIPTION 
<P ></P >
</B >bufread/2 takes a Prolog string, Buffer, and attempts to transform it into a Prolog term. It does this by 
<P ></P >
<IMG SRC = images/Bullet.gif ALT = Bullet.gif BORDER = 0 WIDTH = 3 HEIGHT = 7 >Reading the first term out of Buffer ( trailing characters from Buffer are ignored ) and unifying it with Structure. 
<P ></P >
<IMG SRC = images/Bullet.gif ALT = Bullet.gif BORDER = 0 WIDTH = 3 HEIGHT = 7 >Returning in Vars a list of the quoted variable names occurring in the term 
read. 
<P ></P >
If an error has occured, the head will be an error message ( a Prolog string ), 
and the tail will be the column number where the error is suspected to have 
occurred. bufread/4 is the same as bufread/2, except that more information is provided. FullStop is a flag indicating whether a full stop has been typed. Its value is 1 if 
there was a full stop, and 0 if there was not. LeftOver is the text that is not transformed yet. Although, bufread/4 only transforms one term at a time, it returns the text it has not 
transformed yet in the LeftOver argument. This text can then be transformed by issuing another bufread call, with LeftOver given as the Buffer. 
<P ></P >
<B >EXAMPLES 
<P ></P >
</B >The following example converts the buffer 
<P ></P >

<P ></P >
&quot; ( abc, Bob ) some stuff&quot; 
<P ></P >
to the term f ( abc, _53 ) . 
<P ></P >
? - bufread ( &quot; ( abc, Bob ) some stuff&quot;, [T | Vars] ) . 
<P ></P >
T = f ( abc, _53 ) 
<P ></P >
Vars = [’Bob’] 
<P ></P >
yes. 
<P ></P >
Observe that the characters &quot; ome stuff&quot; are discarded by bufread/2. This next examples demonstrates how error messages are returned 
<P ></P >
? - bufread ( &quot; ello ( &quot; [Message | Column] ), 
<P ></P >
printf ( &quot; nMessage : %s\nColumn : %d\n&quot;, [Message, Column] ) . 
<P ></P >
Message : Non-empty term expected. 
<P ></P >
Column : 6 
<P ></P >
Message = [78, 111, 110, 45, 101, 109, 112, 116, 121, 32, 116, 101, 
<P ></P >
114, 109, 32, 101, 120, 112, 101, 99, 116, 101, 100, 46] 
<P ></P >
Column = 6 
<P ></P >
yes. 
<P ></P >
bufread/2 can be used to convert strings to integers in the following manner 
<P ></P >
? - bufread ( &quot; 23&quot;, [Int | _] ) . 
<P ></P >
Int = 123 
<P ></P >
yes. 
<P ></P >
In the following example, the term inside ( Where ) was not terminated with a full stop, so FullStop is bound to 0 There is no leftover text to run, so LeftOver is bound to the empty list. 
<P ></P >
? - bufread ( &quot; nside ( Where ) &quot; [Term | Vars], FullStop, LeftOver ) . 
<P ></P >
Term = inside ( _38 ) 
<P ></P >
Vars = [’Where’] 
<P ></P >
FullStop = 0 
<P ></P >
LeftOver = [] 
<P ></P >
yes. 
<P ></P >
If you are writing a shell in Prolog using bufread/4, you could write a continuation prompt to tell the user of your shell that 
they must terminate the term with a full stop. In the next example, the term food ( tai ) was terminated by a full stop, so FullStop is bound to 1 This time, there is some leftover text that can be processed, so LeftOver is bound to the remaining Prolog string 
<P ></P >
&quot; food ( indian ) . food ( chinese ) . &quot; 
<P ></P >

<P ></P >
? - bufread ( &quot; ood ( tai ) . food ( indian ) . food ( chinese ) . &quot; 
<P ></P >
[Term | Vars], FullStop, Rest ), 
<P ></P >
printf ( &quot; est = %s\n&quot;, [LeftOver] ) . 
<P ></P >
LeftOver = food ( indian ) . food ( chinese ) . 
<P ></P >
Term = food ( tai ) 
<P ></P >
Vars = [] 
<P ></P >
FullStop = 1 
<P ></P >
LeftOver = [32, 102, 111, 111, 100, 40, 105, 110, 100, 105, 97, 110, 41, 46, 32, 
<P ></P >
102, 111, 111, 100, 40, 99, 104, 105, 110, 101, 115, 101, 41, 46, 32] 
<P ></P >
yes. 
<P ></P >
If you are writing a shell such as mentioned above, you can use use the LeftOver argument to allow multiple goals per line. You do this by continually calling bufread/4 and checking whether you still have further input to process in LeftOver. 
<P ></P >
</BODY >
</HTML >
