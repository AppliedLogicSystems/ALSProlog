<HTML >
<HEAD >
<TITLE >assert/[1 , 2] </TITLE >
</HEAD><BODY>
<B >assert/[1 , 2] </B> 
<P></P>
assert/1 &mdash; adds a clause to a procedure 
<P></P>
assert/2 &mdash; adds a clause to a procedure 
<P></P>
asserta/1 &mdash; adds a clause at the beginning of a procedure 
<P></P>
asserta/2 &mdash; adds a clause at the beginning of a procedure 
<P></P>
assertz/1 &mdash; adds a clause at the end of a procedure 
<P></P>
assertz/2 &mdash; adds a clause at the end of a procedure 
<P></P>
<B>FORMS</B>
<P ></P >
</B >assert ( Clause ) 
<P ></P >
assert ( Clause , Ref ) 
<P ></P >
asserta ( Clause ) 
<P ></P >
asserta ( Clause , Ref ) 
<P ></P >
assertz ( Clause ) 
<P ></P >
assertz ( Clause , Ref ) 
<P ></P >
<B >DESCRIPTION 
<P ></P >
</B >The Clause is added to the procedure with the same name and arity in the module that assert is called from. All uninstantiated variables are re-quantified in the clause 
before it is added to the database , thus breaking any connection between the 
original variables and those occurring in the clause in the database. Because of 
this behavior , the order of calls to assert is important. For example , assuming 
no clauses already exist for p/1 , the first one of the following goals will fail , while the second succeeds. 
<P ></P >

<P ></P >
? - X = a , assert ( p ( X ) ) , p ( b ) . 
<P ></P >

<P ></P >
no. 
<P ></P >
? - assert ( p ( X ) ) , X = a , p ( b ) . 
<P ></P >
X = a 
<P ></P >

<P ></P >
yes. 
<P ></P >
The placement of a clause by assert/1 is defined by the implementation. asserta/1 always adds its clause before any other clauses in the same procedure , while assertz/1 always adds its clause at the end. Each form of assert can take an optional 
second argument ( normally an uninstantiated variable ) which is the database 
reference corresponding to the clause that was added. : /2 can be used to specify in which module the assert should take place. The 
database reference argument is normally passed as an uninstantiated variable. 
<P ></P >
<B >EXAMPLES 
<P ></P >
</B >The following example shows how the different forms of assert work 
<P ></P >

<P ></P >
? - assert ( p ( a ) ) , asserta ( p ( c ) ) , assertz ( p ( b ) ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - listing ( p/1 ) . 
<P ></P >
% user : p/1 
<P ></P >
p ( c ) . 
<P ></P >
p ( a ) . 
<P ></P >
p ( b ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
Notice that the order of the clauses in the database is different than the 
order in which they were asserted. This is because the second assert was done with asserta/1 , and the third assert was done with assertz/1. The asserta/1 call put the p ( c ) clause ahead of p ( a ) in the database. The assertz/1 call put p ( b ) at the end of the p/1 procedure , which happens to be after the p ( a ) clause. The next example demonstrates the use of parentheses in asserting a 
rule into the Prolog database 
<P ></P >

<P ></P >
? - assertz ( ( magic ( X ) : - wizard ( X ) ; pointGuard ( X , lakers ) ) ) . 
<P ></P >
X = _1 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - listing ( magic/1 ) . 
<P ></P >
% user : magic/1 
<P ></P >
magic ( _24 ) : - 
<P ></P >
wizard ( _24 ) 
<P ></P >
; pointGuard ( _24 , lakers ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
If the extra parentheses were not present , the Prolog parser would print the 
following error message 
<P ></P >

<P ></P >
assertz ( magic ( X ) : - wizard ( X ) ; pointGuard ( X , lakers ) ) . 
<P ></P >
^ 
<P ></P >
Syntax Error : Comma or right paren expected in argument list. 
<P ></P >

<P ></P >
The next example shows how the assert predicates can be used with modules. The first goal fails because there is no 
module named animals. After the module is created , the assertion is successful as you can see by 
looking at the listing of the animals module. 
<P ></P >

<P ></P >
? - animals : assert ( beast ( prolog ) ) . 
<P ></P >

<P ></P >
no. 
<P ></P >
? - [user]. 
<P ></P >
Consulting user. 
<P ></P >
module animals. 
<P ></P >
endmod. 
<P ></P >
user consulted. 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - animals : assert ( beast ( prolog ) ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - listing ( animals : _ ) . 
<P ></P >
% animals : beast/1 
<P ></P >
beast ( prolog ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
The following example shows the effects of adding clauses to procedures which 
are part of the current goal 
<P ></P >

<P ></P >
? - assert ( movie ( jaws ) ) , movie ( X ) , assert ( movie ( jaws2 ) ) . 
<P ></P >
X = jaws; 
<P ></P >

<P ></P >
no. 
<P ></P >
The reason this didn’t work is an implementation issue. The following is the 
sequence of events illustrating what happened 
<P ></P >
<IMG SRC = images/Bullet.gif ALT = Bullet.gif BORDER = 0 WIDTH = 3 HEIGHT = 7 >First the assert ( movie ( jaws ) ) subgoal was run , causing a new procedure to be placed in the Prolog database. 
<P ></P >
<IMG SRC = images/Bullet.gif ALT = Bullet.gif BORDER = 0 WIDTH = 3 HEIGHT = 7 >When the subgoal movie ( X ) was run , no choice point was created because there 
were no other clauses to try if failure occurred. 
<P ></P >
<IMG SRC = images/Bullet.gif ALT = Bullet.gif BORDER = 0 WIDTH = 3 HEIGHT = 7 >After movie ( X ) succeeded , the second clause of movie/1 was asserted , and the 
initial goal succeeded , binding X to jaws. 
<P ></P >
<IMG SRC = images/Bullet.gif ALT = Bullet.gif BORDER = 0 WIDTH = 3 HEIGHT = 7 >Backtracking was initiated by the ‘;’ response to the solution , but no second 
solution was found for movie/1 , even though there was a solution to be found. 
This was because there was no choice point to return to in movie/1. 
<P ></P >
One of the interesting ( and possibly bad ) parts to this phenomenon is that the 
second time this goal is run it will backtrack through the clauses of movie/1. This is shown below 
<P ></P >

<P ></P >
? - listing ( movie/1 ) . 
<P ></P >
% user : movie/1 
<P ></P >
movie ( jaws ) . 
<P ></P >
movie ( jaws2 ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - assert ( movie ( jaws ) ) , movie ( X ) , assert ( movie ( jaws2 ) ) . 
<P ></P >
X = jaws; 
<P ></P >
X = jaws2; 
<P ></P >
X = jaws; 
<P ></P >
X = jaws2; 
<P ></P >
X = jaws2; 
<P ></P >
X = jaws2 
<P ></P >

<P ></P >
yes. 
<P ></P >
The reason for this , is that there was more than one clause for movie/1 in the database this time , so a choicepoint was created for the movie ( X ) subgoal. Incidentally , this goal would continue finding the 
<P ></P >

<P ></P >
X = jaws2 
<P ></P >
solution. This is because every time the movie ( X ) finds a new solution , it succeeds , thus causing the 
<P ></P >

<P ></P >
assert ( movie ( jaws2 ) ) 
<P ></P >
subgoal to run. This adds another clause to the database to be tried when the 
user causes backtracking by pressing semicolon ( ; ) . If you look at the 
conversation with the Prolog shell shown above , you will notice that the last solution 
was accepted because no ‘;’ was typed after it. 
<P ></P >
<B >ERRORS 
<P ></P >
</B >Clauses must be either structured terms or atoms. If clause is a rule , with a 
principal functor of : -/2 , then the head and all the subgoals of the clause must either be atoms or 
structured terms. 
<P ></P >
<B >NOTES 
<P ></P >
</B >ALS Prolog provides a global variable mechanism separate from the Prolog 
database. Using global variables is much more efficient than using assert and retract. 
<P ></P >
<B >SEE ALSO 
<P ></P >
</B >: /2 , 
<P ></P >
[Bowen 91 , 7.3] , [Clocksin 81 , 6.4] , [Bratko 86 , 7.4] , [Sterling 86 , 12.2]. 
<P ></P >
</BODY >
</HTML >
