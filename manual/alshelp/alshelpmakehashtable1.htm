<HTML>
<HEAD>
<TITLE>make_hash_table/1</TITLE>
</HEAD><BODY>
<A NAME="0bc0665f"></A>make_hash_table/1
<P></P>
<A NAME="84bae00e"></A><A NAME="82df5d61"></A>make_hash_table/1 –  create hash table and access predicates
<P></P>
<A NAME="84b4b2c6"></A><B>FORMS
<P></P>
<A NAME="84b4b2c8"></A></B>make_hash_table(Name) <A NAME="84b4b2c7"></A><A NAME="84b4b2c7"></A>   
<P></P>
<A NAME="84b4b2c9"></A><B>DESCRIPTION
<P></P>
<A NAME="84b4b2ca"></A></B>make_hash_table/1 will create a hash table and a set of access  methods with the atom Name as the suffix.  Suppose for the sake of the following discussion that Name is bound to the atom '_table'.  Then the access predicates created will be as  follows:
<P></P>
<A NAME="84b4b2cb"></A>reset_table – throw away old hash table associated with the '_table' hash table and create a brand new one.
<P></P>
<A NAME="84b4ba30"></A>set_table(Key,Value) – associate Key with Value in the hash table Key should be bound to a ground term.  Any former associations that Key had in the hash table are replaced.
<P></P>
<A NAME="84b4ba27"></A>get_table(Key,Value) – get the value associated with the ground term bound to Key and unify it with Value.
<P></P>
<A NAME="84b4ba28"></A>del_table(Key,Value) – delete the Key/Value association from the hash table.  Key must be bound to a ground term.  Value will be unified against the associated value in the table.  If the
unification is not successful, the table will not be modified.
<P></P>
<A NAME="84b4ba29"></A>pget_table(KeyPattern,ValPattern) – The &quot;p&quot; in pget and pdel, below, stands for pattern.  pget_table permits KeyPattern and ValPattern to have any desired instantiation.  It will backtrack through the table and
locate associations matching the &quot;pattern&quot; as specified by KeyPattern and ValPattern.
<P></P>
<A NAME="84b4ba2a"></A>pdel_table(KeyPattern,ValPattern) – This functions the same as pget_table except that the association is deleted from the table once it is retrieved.
<P></P>
<A NAME="84b4ba2b"></A><B>EXAMPLES
<P></P>
<A NAME="84b4ba2c"></A></B>?- make_hash_table(‘_assoc’).
<P></P>
<A NAME="84b4ba2d"></A>
<P></P>
<A NAME="84b4ba2e"></A>yes.
<P></P>
<A NAME="84b4ba2f"></A>
<P></P>
<A NAME="84b4b8ad"></A>?- set_assoc(a, f(1)).
<P></P>
<A NAME="84b4b8a4"></A>
<P></P>
<A NAME="84b4b8a5"></A>yes.
<P></P>
<A NAME="84b4b8a6"></A>?- set_assoc(b, f(2)).
<P></P>
<A NAME="84b4b8a7"></A>
<P></P>
<A NAME="84b4b8a8"></A>yes.
<P></P>
<A NAME="84b4b8a9"></A>?- set_assoc(c, f(3)).
<P></P>
<A NAME="84b4b8aa"></A>
<P></P>
<A NAME="84b4b8ab"></A>yes.
<P></P>
<A NAME="84b4b8ac"></A>?- get_assoc(X, Y).
<P></P>
<A NAME="84b4b8d8"></A>
<P></P>
<A NAME="84b4b8cf"></A>no.
<P></P>
<A NAME="84b4b8d0"></A>?- get_assoc(c, Y).
<P></P>
<A NAME="84b4b8d1"></A>
<P></P>
<A NAME="84b4b8d2"></A>Y = f(3)
<P></P>
<A NAME="84b4b8d3"></A>
<P></P>
<A NAME="84b4b8d4"></A>yes.
<P></P>
<A NAME="84b4b8d5"></A>?- pget_assoc(X, Y).
<P></P>
<A NAME="84b4b8d6"></A>
<P></P>
<A NAME="84b4b8d7"></A>X = c
<P></P>
<A NAME="84b4b903"></A>Y = f(3);
<P></P>
<A NAME="84b4b8fa"></A>
<P></P>
<A NAME="84b4b8fb"></A>X = b
<P></P>
<A NAME="84b4b8fc"></A>Y = f(2);
<P></P>
<A NAME="84b4b8fd"></A>
<P></P>
<A NAME="84b4b8fe"></A>X = a
<P></P>
<A NAME="84b4b8ff"></A>Y = f(1);
<P></P>
<A NAME="84b4b900"></A>
<P></P>
<A NAME="84b4b901"></A>no.
<P></P>
<A NAME="84b4b902"></A>?- del_assoc(b, Y).
<P></P>
<A NAME="84b4b92e"></A>
<P></P>
<A NAME="84b4b925"></A>Y = f(2)
<P></P>
<A NAME="84b4b926"></A>
<P></P>
<A NAME="84b4b927"></A>yes.
<P></P>
<A NAME="84b4b928"></A>?- pdel_assoc(X, f(3)).
<P></P>
<A NAME="84b4b929"></A>
<P></P>
<A NAME="84b4b92a"></A>X = c
<P></P>
<A NAME="84b4b92b"></A>
<P></P>
<A NAME="84b4b92c"></A>yes.
<P></P>
<A NAME="84b4b92d"></A>?- pget_assoc(X, Y).
<P></P>
<A NAME="84b4b959"></A>
<P></P>
<A NAME="84b4b950"></A>X = a
<P></P>
<A NAME="84b4b951"></A>Y = f(1);
<P></P>
<A NAME="84b4b952"></A>
<P></P>
<A NAME="84b4b953"></A>no.
<P></P>
<A NAME="84b4b954"></A>?- reset_assoc.
<P></P>
<A NAME="84b4b955"></A>
<P></P>
<A NAME="84b4b956"></A>yes.
<P></P>
<A NAME="84b4b957"></A>?- pget_assoc(X,Y).
<P></P>
<A NAME="84b4b958"></A>
<P></P>
<A NAME="84b4b984"></A>no.
<P></P>
<A NAME="84b4b97b"></A><B>NOTES
<P></P>
<A NAME="84b4b97c"></A></B>Unlike assert and retract, the methods created by make_hash_table/1 do not access the database.  The associations between keys and values is
stored on the heap.  Thus elements of either keys or values may be modified in a
destructive fashion.  This will probably not have desirable consequences if a key
is modified.
<P></P>
<A NAME="84b4b97d"></A>These predicates have an advantage over assert and retract in that no copies are made.  In fact structure may be shared between hash
table entries.
<P></P>
<A NAME="84b4b97e"></A>See the discussion in make_gv/1 concerning global variable modification and backtracking.
<P></P>
<A NAME="84b4b97f"></A><B>SEE ALSO
<P></P>
<A NAME="84b4b980"></A></B>make_gv/1.
<P></P>
</BODY>
</HTML>