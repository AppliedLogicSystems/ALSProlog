<HTML>
<HEAD>
<TITLE>'$uia_alloc'/2</TITLE>
</HEAD><BODY>
<A NAME="82df6c58"></A><B>’$uia_alloc’/2
<P></P>
<A NAME="82e0aa4b"></A><A NAME="84b864c8"></A></B>’$uia_alloc’/2 –  allocates a UIA of specified length
<P></P>
<A NAME="84b864c9"></A>’$uia_size’/2 –  obtains the actual size of a UIA
<P></P>
<A NAME="84b864ca"></A>’$uia_clip’/2 –  clip the given UIA
<P></P>
<A NAME="84b864cb"></A>’$uia_pokeb’/3 –  modifies the specified byte of a UIA
<P></P>
<A NAME="84b864f7"></A>’$uia_peekb’/3 –  returns the specified byte of a UIA
<P></P>
<A NAME="84b864ee"></A>’$uia_pokew’/3 –  modifies the specified word of a UIA
<P></P>
<A NAME="84b864ef"></A>’$uia_peekw’/3 –  returns the specified word of a UIA
<P></P>
<A NAME="84b864f0"></A>’$uia_pokel’/3 –  modifies the specified long word of a UIA
<P></P>
<A NAME="84b864f1"></A>’$uia_peekl’/3 –  returns the specified long word of a UIA
<P></P>
<A NAME="84b864f2"></A>’$uia_poked’/3 –  modifies the specified double of a UIA
<P></P>
<A NAME="84b864f3"></A>’$uia_peekd’/3 –  returns the specified double of a UIA
<P></P>
<A NAME="84b864f4"></A>’$uia_pokes’/3 –  modifies the specified substring of a UIA
<P></P>
<A NAME="84b864f5"></A>’$uia_peeks’/3 –  returns the specified substring of a UIA
<P></P>
<A NAME="84b864f6"></A>’$uia_peeks’/4 –  returns the specified substring of a UIA
<P></P>
<A NAME="84b86c5b"></A>’$uia_peek’/4 –  returns the specified region of a UIA
<P></P>
<A NAME="84b86c52"></A>’$uia_poke’/4 –  modifies the specified region of a UIA
<P></P>
<A NAME="84b86c53"></A>’$strlen’/2 –  returns the length of the specified symbol
<P></P>
<A NAME="84b86c54"></A><B>FORMS
<P></P>
<A NAME="84b86c55"></A></B>’$uia_alloc’(BufLen,UIABuf) 
<P></P>
<A NAME="84b86c56"></A>’$uia_size’(UIABuf,Size) 
<P></P>
<A NAME="84b86c57"></A>’$uia_clip’(UIABuf,Size) 
<P></P>
<A NAME="84b86c58"></A>’$uia_pokeb’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86c59"></A>’$uia_peekb’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86c5a"></A>’$uia_pokew’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86ad8"></A>’$uia_peekw’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86acf"></A>’$uia_pokel’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86ad0"></A>’$uia_peekl’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86ad1"></A>’$uia_poked’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86ad2"></A>’$uia_peekd’(UIABuf,Offset,Value) 
<P></P>
<A NAME="84b86ad3"></A>’$uia_pokes’(UIABuf,Offset,Symbol) 
<P></P>
<A NAME="84b86ad4"></A>’$uia_peeks’(UIABuf,Offset,Symbol) 
<P></P>
<A NAME="84b86ad5"></A>’$uia_peeks’(UIABuf,Offset,Size,Symbol) 
<P></P>
<A NAME="84b86ad6"></A>’$uia_peek’(UIABuf,Offset,Size,Value) 
<P></P>
<A NAME="84b86ad7"></A>’$uia_poke’(UIABuf,Offset,Size,Value) 
<P></P>
<A NAME="84b86afc"></A>’$strlen’(Symbol,Size) <A NAME="84b86b03"></A><A NAME="84b86b03"></A> <A NAME="84b86afa"></A> <A NAME="84b86afb"></A> 
<P></P>
<A NAME="84b86afd"></A><B>DESCRIPTION  
<P></P>
<A NAME="84b86afe"></A></B>A call to ’$uia_alloc’(BufLen,UIABuf)creates a UIA of the length specified by BufLen.  BufLen should be instantiated to a positive integer which represents the size (in
bytes) of the UIA to allocate; currently the maximum allowable value of BufLen is 1024. The actual size of the buffer allocated will be that multiple of
four between BufLen+1 and BufLen+4. (UIAs are allocated on word boundaries and an extra byte is added to provide
for zero termination of strings when UIAs are used for symbols.) UIABuf should be a variable. UIAs are initially filled with zeros, and will unify
with the null atom (’’). 
<P></P>
<A NAME="84b86aff"></A>The call ’$uia_size’(UIABuf,Size)returns the actual size (in bytes) of the given UIA. If Size is less than or equal to the actual size of the given UIABuf, the call ’$uia_clip’(UIABuf,Size) reduces the size of UIABuf by removing all but one of the trailing zeros (null bytes). 
<P></P>
<A NAME="84b86b00"></A>Single-byte values can be inserted into a UIA buffer using ’$uia_pokeb’/3.  The modifications are destructive, and do not disappear upon backtracking. 
These procedures can be used to modify system atoms (file names and strings
that are represented as UIAs). However, this use is strongly discouraged.  UIABuf should be a buffer obtained from ’$uia_alloc’/2.  Offset is the offset within the buffer to the place where Value is to be inserted.  Both Offset and Value are integers.  In ’$uia_pokeb’/3, the buffer is viewed as a vector of bytes with the first byte having offset
zero.  The byte at Offset from the beginning of the buffer is changed to Value. The companion predicates ’$uia_pokew’/3, ’$uia_pokel’/3, ’$uia_poked’/3, perform the corresponding operation on words, long words, and doubles,
respectively. 
<P></P>
<A NAME="84b86b01"></A>’$uia_peekb’/3 is used to obtain specific bytes from a UIA buffer created by ’$uia_alloc’/2, or from any other UIA existing in the system. The parameters for these
procedures are specified as follows: The arguments of ’$uia_peekb’/3 are interpreted in the same manner as the parameters for ’$uia_pokeb’/3. The parameter Symbol must be a UIA or an atom.  The parameter Size must be an integer. The companion predicates, ’$uia_peekw’/3, ’$uia_peekl’/3, ’$uia_peekd’/3,perform the corresponding operation on words, long words, and doubles,
respectively. 
<P></P>
<A NAME="84b86b02"></A>Like ’$uia_pokeb’/3,  ’$uia_pokes’/3 views the buffer as a vector of bytes with offset zero specifying the first
byte. But instead of replacing just a single byte, ’$uia_pokes’/3 replaces the portion of the buffer beginning at Offset and having length equal to the length of Symbol, using the characters of Symbol for the replacement. If Symbol would extend beyond the end of the buffer, Symbol is truncated at the end of the buffer. The parameter Symbol must be an atom. The parameter Size must be an integer. 
<P></P>
<A NAME="84b86b2e"></A>’$uia_peeks’/3 binds Symbol to a UIA consisting of the characters beginning at position Offset and extending to the end of the buffer. ’$uia_peeks’/4 binds Symbol to a UIA consisting of the characters beginning at position Offset and extending to position End where End = Offset + Size. If End would occur beyond the end of the buffer, Symbol simply extends to the end of the buffer. 
<P></P>
<A NAME="84b86b25"></A>Provided that Offset and Size define a proper region within the given UIABuf (i.e., not including the final byte of UIABuf), ’$uia_poke’(UIABuf,Offset,Size,Value) modifies the indicated region by copying characters from the given UIA (or
symbol) Value. The size of the atom or UIA Value must be greater than or equal to Size. The region copied from ‘Value’ is defined by offset 0 and Size. 
<P></P>
<A NAME="84b86b26"></A>Provided that Offset and Size define a proper region within the given UIABuf (i.e., not including the final byte of UIABuf), ’$uia_peek’(UIABuf,Offset,Size,Value) extracts the indicated region from UIABuf, returning it as a new UIA Value. 
<P></P>
<A NAME="84b86b27"></A>When Symbol is a Prolog symbol (atom or UIA), ’$strlen’(Symbol,Size) returns the length of the print name of that symbol (thus not counting the
terminating null byte). 
<P></P>
<A NAME="84b86b28"></A><B>EXAMPLES  
<P></P>
<A NAME="84b86b29"></A></B>copy_atom_to_uia(Atom, UIABuf) :- 
<P></P>
  <A NAME="84b86b2a"></A>name(Atom,ExplodedAtom), 
<P></P>
  <A NAME="84b86b2b"></A>copy_list_to_uia(ExplodedAtom,UIABuf). 
<P></P>
<A NAME="84b86b2c"></A> 
<P></P>
<A NAME="84b86b2d"></A>copy_list_to_uia(Ints,UIABuf) :- 
<P></P>
  <A NAME="84b86b59"></A>length([_|Ints], BufLen), 
<P></P>
  <A NAME="84b86b50"></A>’$uia_alloc’(BufLen, UIABuf), 
<P></P>
  <A NAME="84b86b51"></A>copy_list_to_uia(Ints, 0, UIABuf). 
<P></P>
<A NAME="84b86b52"></A> 
<P></P>
<A NAME="84b86b53"></A>copy_list_to_uia([],_,_) :- !. 
<P></P>
<A NAME="84b86b54"></A>copy_list_to_uia([H | T], N, Buf) :- 
<P></P>
  <A NAME="84b86b55"></A>’$uia_pokeb’(Buf,N,H), 
<P></P>
  <A NAME="84b86b56"></A>NN is N+1, 
<P></P>
  <A NAME="84b86b57"></A>copy_list_to_uia(T, NN, Buf). 
<P></P>
<A NAME="84b86b58"></A><B>SEE ALSO
<P></P>
<A NAME="84b86b84"></A></B>atom_concat/3, sub_atom/3, atom_char/2
<P></P>
<A NAME="84b98be9"></A>
<P></P>
</BODY>
</HTML>