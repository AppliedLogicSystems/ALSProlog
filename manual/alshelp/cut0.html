<HTML >
<HEAD >
<TITLE >!/0 ( cut ) </TITLE >
</HEAD><BODY>
<B >!/0 ( cut ) </B> 
<P></P>
' !/0 ( cut ) ' &mdash; removes choice points 
<P></P>
<B>FORMS</B>
<P ></P >
</B >FirstGoal , ! , SecondGoal 
<P ></P >
FirstGoal , !; SecondGoal 
<P ></P >
<B >DESCRIPTION </B ><B >
<P ></P >
</B >Discards all choice points made since the parent goal started execution 
including the choice points , if any , created by calling the parent goal. In the 
following two cases , a cut in Condition will remove all choice points created by the Condition , any subgoals to the left of the Condition , and the choice point for the parent goal. 
<P ></P >

<P ></P >
Condition = ( Things , ! , MoreThings ) 
<P ></P >

<P ></P >
Condition-&gt;TrueGoal; FalseGoal 
<P ></P >
call ( Condition ) 
<P ></P >
In other words 
<P ></P >
-&gt; 
<P ></P >
call/1 
<P ></P >
; 
<P ></P >
: 
<P ></P >
, 
<P ></P >
are transparent to cut. The ISO Prolog Standard requires that call/1 be opaque to cut. At this time , ALS Prolog deviates from the standard. 
<P ></P >
<B >EXAMPLES 
<P ></P >
</B >In the following example , the solution eats ( chris , pizza ) causes a cut to be executed. This removes the choice point for the goal eats/2. As a result , the solution eats ( mick , pizza ) is not found , even though Mick will eat anything. 
<P ></P >

<P ></P >
? - [user]. 
<P ></P >
Consulting user. 
<P ></P >
eats ( chris , pizza ) : - !. 
<P ></P >
eats ( mick , Anything ) . 
<P ></P >
user consulted. 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - eats ( Person , pizza ) . 
<P ></P >
Person = chris; 
<P ></P >

<P ></P >
no. 
<P ></P >
The next example shows that not/1 is opaque to cut. This means that a ‘!’ inside the call to not/1 will not cut out the choicepoint for not/2 , or any other choicepoints created by goals to the left of not/2. 
<P ></P >

<P ></P >
? - not ( ( ! , fail ) ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >

<P ></P >
Notice the extra pair of parentheses above. This is to prevent the parser from 
creating a goal to not/2 instead of not/1. In the next example , the transparency of call/1 with respect to cut is shown 
<P ></P >

<P ></P >
? - [user]. 
<P ></P >
Consulting user. 
<P ></P >
cool ( peewee ) : - call ( ( ! , fail ) ) . 
<P ></P >
cool ( X ) . 
<P ></P >
user consulted. 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - cool ( peewee ) . 
<P ></P >

<P ></P >
no. 
<P ></P >
? - cool ( bugsbunny ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >

<P ></P >
peewee is not cool because the ‘!’ removed the choicepoint for cool/1. The fail after the ‘!’ prevented cool/1 from succeeding. The rationale for having cut behave this way is so that 
<P ></P >

<P ></P >
cool ( peewee ) : - call ( ( ! , fail ) ) . 
<P ></P >
will be equivalent to 
<P ></P >

<P ></P >
cool ( peewee ) : - ! , fail. 
<P ></P >
The next example shows the transparency of -&gt; with respect to cut. 
<P ></P >

<P ></P >
? - [-user]. 
<P ></P >
Reconsulting user. 
<P ></P >
cool ( X ) : - ( X = peewee , ! ) -&gt; fail. 
<P ></P >
cool ( X ) . 
<P ></P >
user reconsulted. 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - cool ( peewee ) . 
<P ></P >

<P ></P >
no. 
<P ></P >

<P ></P >
Again , peewee is not considered cool. In the goal 
<P ></P >

<P ></P >
? - cool ( peewee ) . 
<P ></P >
the ‘!’ after X = peewee cuts the choicepoint for cool/1. The condition succeeds , causing fail to be executed. However , the second clause is never reached because the 
choicepoint has been cut away. Consequently , the goal fails. The goal 
<P ></P >

<P ></P >
? - cool ( daffyduck ) . 
<P ></P >
succeeds because the ‘!’ is never reached in the condition of -&gt;. The -&gt; fails because there is no else subgoal. This causes the next clause for cool/1 to be executed. This clause always succeeds , therefore daffyduck is considered cool. 
<P ></P >
<B >SEE ALSO 
<P ></P >
</B >-&gt;/2 , not/1 , 
<P ></P >
[Bowen 91 , 7.1] , [Sterling 86 , 11] , [Bratko 86 , 5.1] , [Clocksin 81 , 4.2]. 
<P ></P >
</BODY >
</HTML >
