<HTML >
<HEAD >
<TITLE >make_gv/1 </TITLE >
</HEAD><BODY>
make_gv/1 
<P></P>
make_gv/1 &mdash; create named global variable and access method 
<P></P>
make_det_gv/1 &mdash; create named global variable and access methods which preserves instantiations of structures 
<P></P>
free_gv/1 &mdash; release store associated with named global variable 
<P></P>
<B>FORMS</B>
<P ></P >
</B >make_gv ( Name ) 
<P ></P >
make_det_gv ( Name ) 
<P ></P >
free_gv ( Name ) 
<P ></P >
<B >DESCRIPTION 
<P ></P >
</B >make_gv/1 allocates an internal global variable and creates two access predicates 
called setNAME/1 and getNAME/1 where NAME is the atom Name. These access predicates are installed in the module from which make_gv/1 is called. 
<P ></P >
The setNAME/1 predicate is used to set the allocated global variable to the term given to setNAME as its only argument. This operation is safe in that the contents of the 
global variable will survive backtracking without any dangling references. Care 
should be taken when using these global variables with backtracking as it is 
easy to create a ground structure in which &quot; oles&quot; will appear upon backtracking. 
These holes are uninstantiated variables where there used to be a term. They 
are caused by some bit of non-determinism when creating the term. If the 
non-determinism is removed via cut prior to a global variable operation , these 
&quot; oles&quot; will often not show up upon backtracking. If the non-determinism is removed 
after the global variable operation takes place , these holes will very likely 
show up. The reason that this is so is because the global variable mechanism 
will ( as a consequence of making the structure safe to backtrack over ) eliminate 
the ability of cut to discriminate among those trail entries which may be 
safely cut and those which are needed in the event of failure. 
<P ></P >
In situations where this is a problem , a call to copy_term/2 may be used to create a copy of the term prior to setting the global 
variable. The instantiation of the term that exists at the time of the copy will be 
the instantiation of the term which survives backtracking over the copy 
operation. 
<P ></P >
Also of interest is the time complexity of the set operation. So long as the 
argument to setNAME/1 is a non-pointer type , that is a suitably small integer or certain types of 
atoms ( the non-UIA variety ) , the set operation is a constant time operation. 
Otherwise it requires time linearly proportional to the current depth of the 
choice point stack. 
<P ></P >
The getNAME/1 predicate created by make_gv/1 is used to get the contents of one of these global variables. The contents 
of the global variable is unified with the single parameter passed to getNAME/1. 
<P ></P >
make_det_gv/1 creates access methods just like make_gv/1 but the setNAME/1 method avoids the problems referred to above concerning certain 
instantiations in structure becoming undone. It does this by making a copy of the term prior 
to setting the global variable. Making a copy of the term has the 
disadvantage of the increased space and time requirements associated with making copies. 
<P ></P >
free_gv/1 removes access methods created by make_gv/1 and frees up the global variable. 
<P ></P >
<B >EXAMPLES 
<P ></P >
</B >: - make_gv ( ' _demo' ) .%% Create get_demo/1 and set_demo/1. 
<P ></P >

<P ></P >
print_demo ( N ) : - get_demo ( X ) , printf ( ' demo%d : %t\n' , [N , X] ) . 
<P ></P >

<P ></P >
demo1 : - demo1 ( _ ) . 
<P ></P >
demo1 : - print_demo ( 1 ) . 
<P ></P >
demo1 ( _ ) : - X = f ( Y ) , ( Y = i ; Y = j ) , set_demo ( X ) , print_demo ( 1 ) , fail. 
<P ></P >

<P ></P >
demo2 : - demo2 ( _ ) . 
<P ></P >
demo2 : - print_demo ( 2 ) . 
<P ></P >
demo2 ( _ ) : - X = f ( Y ) , ( Y = i ; Y = j ) , ! , set_demo ( X ) , print_demo ( 2 ) , fail. 
<P ></P >

<P ></P >
demo3 : - demo3 ( _ ) . 
<P ></P >
demo3 : - print_demo ( 3 ) . 
<P ></P >
demo3 ( _ ) : - X = f ( Y ) , ( Y = i ; Y = j ) , set_demo ( X ) , ! , print_demo ( 3 ) , fail. 
<P ></P >

<P ></P >
demo4 : - demo4 ( _ ) . 
<P ></P >
demo4 : - print_demo ( 4 ) . 
<P ></P >
demo4 ( Y ) : - X = f ( Y ) , ( Y = i ; Y = j ) , ! , set_demo ( X ) , print_demo ( 4 ) , fail. 
<P ></P >

<P ></P >
demo5 : - _ = f ( Y ) , set_demo ( [a] ) , demo5 ( Y ) . 
<P ></P >
demo5 : - print_demo ( 5 ) . 
<P ></P >
demo5 ( Y ) : - X = f ( Y ) , ( Y = i ; Y = j ) , ! , set_demo ( X ) , print_demo ( 5 ) , fail. 
<P ></P >

<P ></P >
demo6 : - set_demo ( [a] ) , _ = f ( Y ) , demo6 ( Y ) . 
<P ></P >
demo6 : - print_demo ( 6 ) . 
<P ></P >
demo6 ( Y ) : - X = f ( Y ) , ( Y = i ; Y = j ) , ! , set_demo ( X ) , print_demo ( 6 ) , fail. 
<P ></P >

<P ></P >
demo7 : - demo7 ( _ ) . 
<P ></P >
demo7 : - print_demo ( 7 ) . 
<P ></P >
demo7 ( _ ) : - X = f ( Y ) , ( Y = i ; Y = j ) , copy_term ( X , Z ) , 
<P ></P >
set_demo ( Z ) , ! , print_demo ( 7 ) , fail. 
<P ></P >

<P ></P >
demo : - demo1 , nl , demo2 , nl , demo3 , nl 
<P ></P >
demo4 , nl , demo5 , nl , demo6 , nl 
<P ></P >
demo7. 
<P ></P >
The above program demonstrates the subtelties of combining global variables 
with backtracking. Here is a sample run of this program 
<P ></P >

<P ></P >
? - demo. 
<P ></P >
demo1 : f ( i ) 
<P ></P >
demo1 : f ( j ) 
<P ></P >
demo1 : f ( _A ) 
<P ></P >

<P ></P >
demo2 : f ( i ) 
<P ></P >
demo2 : f ( i ) 
<P ></P >

<P ></P >
demo3 : f ( i ) 
<P ></P >
demo3 : f ( _A ) 
<P ></P >

<P ></P >
demo4 : f ( i ) 
<P ></P >
demo4 : f ( i ) 
<P ></P >

<P ></P >
demo5 : f ( i ) 
<P ></P >
demo5 : f ( _A ) 
<P ></P >

<P ></P >
demo6 : f ( i ) 
<P ></P >
demo6 : f ( i ) 
<P ></P >

<P ></P >
demo7 : f ( i ) 
<P ></P >
demo7 : f ( i ) 
<P ></P >

<P ></P >
In each of these seven different tests , some non-determinism is introduced 
through the use of ;/2. 
<P ></P >
demo1 makes no attempt eliminate this non-determinism. Yet the results might be 
somewhat surprising. set_demo/1 is called twice; once with X instantiated to f ( i ) , the second time with X instantiatedto f ( j ) . Yet when we fail out of demo1/1 , print_demo/1 reports the &quot; emo&quot; variable to have an uninstantiated portion. 
<P ></P >
demo2 eliminates the non-determinism in a straightforward fashion through the use 
of a cut. Here the f ( i ) is made to &quot; tick&quot;. 
<P ></P >
demo3 is a slight variation on demo2. It shows that eliminating determinism after setting the global variable is 
too late to make the instantiations &quot; tick&quot;. 
<P ></P >
demo4 is similar to demo3 , but shows that it is alright for Y to be &quot; lder&quot; than the structure containing it. 
<P ></P >
demo5 shows that an intervening global variable operation may screw things up by 
making Y live in a portion of the heap which must be trailed when Y is bound. The cut prior to setting the global variable is not permitted to 
remove the trail entry which eventually causes Y to lose its instantiation. 
<P ></P >
demo6 shows that creating the variable after the global variable operation has the 
same effect as demo4. 
<P ></P >
demo7 demonstrates a technique that may be used to always make instantiations 
&quot; tick&quot;. It creates a new copy of the term and calls set_demo/1 with this new copy. 
<P ></P >
If the call to make_gv/1 at the top of the file were replaced with a call to make_det_gv/1 , then all of the instantiations would &quot; tick&quot; as make_det_gv/1 automatically makes a copy of the term thus doing implicitly what demo7 does explicitly. 
<P ></P >
<B >BUGS 
<P ></P >
</B >free_gv/1 does not work for access methods created by make_det_gv/1. 
<P ></P >
<B >SEE ALSO 
<P ></P >
</B >make_hash_table/1 , copy_term/2 , mangle/3. 
<P ></P >
</BODY >
</HTML >
