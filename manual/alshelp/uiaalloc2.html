<HTML >
<HEAD >
<TITLE >' $uia_alloc'/2 </TITLE >
</HEAD><BODY>
<B >’$uia_alloc’/2 </B> 
<P></P>
’$uia_alloc’/2 &mdash; allocates a UIA of specified length 
<P></P>
’$uia_size’/2 &mdash; obtains the actual size of a UIA 
<P></P>
’$uia_clip’/2 &mdash; clip the given UIA 
<P></P>
’$uia_pokeb’/3 &mdash; modifies the specified byte of a UIA 
<P></P>
’$uia_peekb’/3 &mdash; returns the specified byte of a UIA 
<P></P>
’$uia_pokew’/3 &mdash; modifies the specified word of a UIA 
<P></P>
’$uia_peekw’/3 &mdash; returns the specified word of a UIA 
<P></P>
’$uia_pokel’/3 &mdash; modifies the specified long word of a UIA 
<P></P>
’$uia_peekl’/3 &mdash; returns the specified long word of a UIA 
<P></P>
’$uia_poked’/3 &mdash; modifies the specified double of a UIA 
<P></P>
’$uia_peekd’/3 &mdash; returns the specified double of a UIA 
<P></P>
’$uia_pokes’/3 &mdash; modifies the specified substring of a UIA 
<P></P>
’$uia_peeks’/3 &mdash; returns the specified substring of a UIA 
<P></P>
’$uia_peeks’/4 &mdash; returns the specified substring of a UIA 
<P></P>
’$uia_peek’/4 &mdash; returns the specified region of a UIA 
<P></P>
’$uia_poke’/4 &mdash; modifies the specified region of a UIA 
<P></P>
’$strlen’/2 &mdash; returns the length of the specified symbol 
<P></P>
<B>FORMS</B>
<P ></P >
</B >’$uia_alloc’ ( BufLen , UIABuf ) 
<P ></P >
’$uia_size’ ( UIABuf , Size ) 
<P ></P >
’$uia_clip’ ( UIABuf , Size ) 
<P ></P >
’$uia_pokeb’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_peekb’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_pokew’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_peekw’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_pokel’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_peekl’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_poked’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_peekd’ ( UIABuf , Offset , Value ) 
<P ></P >
’$uia_pokes’ ( UIABuf , Offset , Symbol ) 
<P ></P >
’$uia_peeks’ ( UIABuf , Offset , Symbol ) 
<P ></P >
’$uia_peeks’ ( UIABuf , Offset , Size , Symbol ) 
<P ></P >
’$uia_peek’ ( UIABuf , Offset , Size , Value ) 
<P ></P >
’$uia_poke’ ( UIABuf , Offset , Size , Value ) 
<P ></P >
’$strlen’ ( Symbol , Size ) 
<P ></P >
<B >DESCRIPTION 
<P ></P >
</B >A call to ’$uia_alloc’ ( BufLen , UIABuf ) creates a UIA of the length specified by BufLen. BufLen should be instantiated to a positive integer which represents the size ( in 
bytes ) of the UIA to allocate; currently the maximum allowable value of BufLen is 1024 The actual size of the buffer allocated will be that multiple of 
four between BufLen + 1 and BufLen + 4 ( UIAs are allocated on word boundaries and an extra byte is added to provide 
for zero termination of strings when UIAs are used for symbols. ) UIABuf should be a variable. UIAs are initially filled with zeros , and will unify 
with the null atom ( ’’ ) . 
<P ></P >
The call ’$uia_size’ ( UIABuf , Size ) returns the actual size ( in bytes ) of the given UIA. If Size is less than or equal to the actual size of the given UIABuf , the call ’$uia_clip’ ( UIABuf , Size ) reduces the size of UIABuf by removing all but one of the trailing zeros ( null bytes ) . 
<P ></P >
Single-byte values can be inserted into a UIA buffer using ’$uia_pokeb’/3. The modifications are destructive , and do not disappear upon backtracking. 
These procedures can be used to modify system atoms ( file names and strings 
that are represented as UIAs ) . However , this use is strongly discouraged. UIABuf should be a buffer obtained from ’$uia_alloc’/2. Offset is the offset within the buffer to the place where Value is to be inserted. Both Offset and Value are integers. In ’$uia_pokeb’/3 , the buffer is viewed as a vector of bytes with the first byte having offset 
zero. The byte at Offset from the beginning of the buffer is changed to Value. The companion predicates ’$uia_pokew’/3 , ’$uia_pokel’/3 , ’$uia_poked’/3 , perform the corresponding operation on words , long words , and doubles 
respectively. 
<P ></P >
’$uia_peekb’/3 is used to obtain specific bytes from a UIA buffer created by ’$uia_alloc’/2 , or from any other UIA existing in the system. The parameters for these 
procedures are specified as follows : The arguments of ’$uia_peekb’/3 are interpreted in the same manner as the parameters for ’$uia_pokeb’/3. The parameter Symbol must be a UIA or an atom. The parameter Size must be an integer. The companion predicates , ’$uia_peekw’/3 , ’$uia_peekl’/3 , ’$uia_peekd’/3 , perform the corresponding operation on words , long words , and doubles 
respectively. 
<P ></P >
Like ’$uia_pokeb’/3 , ’$uia_pokes’/3 views the buffer as a vector of bytes with offset zero specifying the first 
byte. But instead of replacing just a single byte , ’$uia_pokes’/3 replaces the portion of the buffer beginning at Offset and having length equal to the length of Symbol , using the characters of Symbol for the replacement. If Symbol would extend beyond the end of the buffer , Symbol is truncated at the end of the buffer. The parameter Symbol must be an atom. The parameter Size must be an integer. 
<P ></P >
’$uia_peeks’/3 binds Symbol to a UIA consisting of the characters beginning at position Offset and extending to the end of the buffer. ’$uia_peeks’/4 binds Symbol to a UIA consisting of the characters beginning at position Offset and extending to position End where End = Offset + Size. If End would occur beyond the end of the buffer , Symbol simply extends to the end of the buffer. 
<P ></P >
Provided that Offset and Size define a proper region within the given UIABuf ( i.e. , not including the final byte of UIABuf ) , ’$uia_poke’ ( UIABuf , Offset , Size , Value ) modifies the indicated region by copying characters from the given UIA ( or 
symbol ) Value. The size of the atom or UIA Value must be greater than or equal to Size. The region copied from ‘Value’ is defined by offset 0 and Size. 
<P ></P >
Provided that Offset and Size define a proper region within the given UIABuf ( i.e. , not including the final byte of UIABuf ) , ’$uia_peek’ ( UIABuf , Offset , Size , Value ) extracts the indicated region from UIABuf , returning it as a new UIA Value. 
<P ></P >
When Symbol is a Prolog symbol ( atom or UIA ) , ’$strlen’ ( Symbol , Size ) returns the length of the print name of that symbol ( thus not counting the 
terminating null byte ) . 
<P ></P >
<B >EXAMPLES 
<P ></P >
</B >copy_atom_to_uia ( Atom , UIABuf ) : - 
<P ></P >
name ( Atom , ExplodedAtom ) , 
<P ></P >
copy_list_to_uia ( ExplodedAtom , UIABuf ) . 
<P ></P >

<P ></P >
copy_list_to_uia ( Ints , UIABuf ) : - 
<P ></P >
length ( [_ | Ints] , BufLen ) , 
<P ></P >
’$uia_alloc’ ( BufLen , UIABuf ) , 
<P ></P >
copy_list_to_uia ( Ints , 0 , UIABuf ) . 
<P ></P >

<P ></P >
copy_list_to_uia ( [] , _ , _ ) : - !. 
<P ></P >
copy_list_to_uia ( [H | T] , N , Buf ) : - 
<P ></P >
’$uia_pokeb’ ( Buf , N , H ) , 
<P ></P >
NN is N + 1 , 
<P ></P >
copy_list_to_uia ( T , NN , Buf ) . 
<P ></P >
<B >SEE ALSO 
<P ></P >
</B >atom_concat/3 , sub_atom/3 , atom_char/2 
<P ></P >
</BODY >
</HTML >
