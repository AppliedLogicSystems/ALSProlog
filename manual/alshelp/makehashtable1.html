<HTML >
<HEAD >
<TITLE >make_hash_table/1 </TITLE >
</HEAD><BODY>
make_hash_table/1 
<P></P>
make_hash_table/1 &mdash; create hash table and access predicates 
<P></P>
<B>FORMS</B>
<P ></P >
</B >make_hash_table ( Name ) 
<P ></P >
<B >DESCRIPTION 
<P ></P >
</B >make_hash_table/1 will create a hash table and a set of access methods with the atom Name as the suffix. Suppose for the sake of the following discussion that Name is bound to the atom ' _table'. Then the access predicates created will be as follows 
<P ></P >
reset_table – throw away old hash table associated with the ' _table' hash table and create a brand new one. 
<P ></P >
set_table ( Key, Value ) – associate Key with Value in the hash table Key should be bound to a ground term. Any former associations that Key had in the hash table are replaced. 
<P ></P >
get_table ( Key, Value ) – get the value associated with the ground term bound to Key and unify it with Value. 
<P ></P >
del_table ( Key, Value ) – delete the Key/Value association from the hash table. Key must be bound to a ground term. Value will be unified against the associated value in the table. If the 
unification is not successful, the table will not be modified. 
<P ></P >
pget_table ( KeyPattern, ValPattern ) – The &quot; &quot; in pget and pdel, below, stands for pattern. pget_table permits KeyPattern and ValPattern to have any desired instantiation. It will backtrack through the table and 
locate associations matching the &quot; attern&quot; as specified by KeyPattern and ValPattern. 
<P ></P >
pdel_table ( KeyPattern, ValPattern ) – This functions the same as pget_table except that the association is deleted from the table once it is retrieved. 
<P ></P >
<B >EXAMPLES 
<P ></P >
</B >? - make_hash_table ( ‘_assoc’ ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >

<P ></P >
? - set_assoc ( a, f ( 1 ) ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - set_assoc ( b, f ( 2 ) ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - set_assoc ( c, f ( 3 ) ) . 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - get_assoc ( X, Y ) . 
<P ></P >

<P ></P >
no. 
<P ></P >
? - get_assoc ( c, Y ) . 
<P ></P >

<P ></P >
Y = f ( 3 ) 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - pget_assoc ( X, Y ) . 
<P ></P >

<P ></P >
X = c 
<P ></P >
Y = f ( 3 ) ; 
<P ></P >

<P ></P >
X = b 
<P ></P >
Y = f ( 2 ) ; 
<P ></P >

<P ></P >
X = a 
<P ></P >
Y = f ( 1 ) ; 
<P ></P >

<P ></P >
no. 
<P ></P >
? - del_assoc ( b, Y ) . 
<P ></P >

<P ></P >
Y = f ( 2 ) 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - pdel_assoc ( X, f ( 3 ) ) . 
<P ></P >

<P ></P >
X = c 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - pget_assoc ( X, Y ) . 
<P ></P >

<P ></P >
X = a 
<P ></P >
Y = f ( 1 ) ; 
<P ></P >

<P ></P >
no. 
<P ></P >
? - reset_assoc. 
<P ></P >

<P ></P >
yes. 
<P ></P >
? - pget_assoc ( X, Y ) . 
<P ></P >

<P ></P >
no. 
<P ></P >
<B >NOTES 
<P ></P >
</B >Unlike assert and retract, the methods created by make_hash_table/1 do not access the database. The associations between keys and values is 
stored on the heap. Thus elements of either keys or values may be modified in a 
destructive fashion. This will probably not have desirable consequences if a key 
is modified. 
<P ></P >
These predicates have an advantage over assert and retract in that no copies are made. In fact structure may be shared between hash 
table entries. 
<P ></P >
See the discussion in make_gv/1 concerning global variable modification and backtracking. 
<P ></P >
<B >SEE ALSO 
<P ></P >
</B >make_gv/1. 
<P ></P >
</BODY >
</HTML >
