<h2 id="forms">FORMS</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'$uia_alloc'(BufLen, UIABuf)

'$uia_size'(UIABuf, Size)

'$uia_clip'(UIABuf, Size)

'$uia_pokeb'(UIABuf, Offset, Value)
'$uia_peekb'(UIABuf, Offset, Value)

'$uia_pokew'(UIABuf, Offset, Value)
'$uia_peekw'(UIABuf, Offset, Value)

'$uia_pokel'(UIABuf, Offset, Value)
'$uia_peekl'(UIABuf, Offset, Value)

'$uia_poked'(UIABuf, Offset, Value)
'$uia_peekd'(UIABuf, Offset, Value)

'$uia_pokes'(UIABuf, Offset, Symbol)
'$uia_peeks'(UIABuf, Offset, Symbol)
'$uia_peeks'(UIABuf, Offset, Size, Symbol)

'$uia_peek'(UIABuf, Offset, Size, Value)
'$uia_poke'(UIABuf, Offset, Size, Value)

'$strlen'(Symbol, Size)
</code></pre></div></div>

<h2 id="description">DESCRIPTION</h2>

<p>A call to <code class="highlighter-rouge">'$uia_alloc'(BufLen, UIABuf)</code> creates a UIA of the length specified by <code class="highlighter-rouge">BufLen</code>. <code class="highlighter-rouge">BufLen</code> should be instantiated to a positive integer which represents the size(in bytes) of the UIA to allocate; currently the maximum allowable value of <code class="highlighter-rouge">BufLen</code> is 1024 The actual size of the buffer allocated will be that multiple of four between <code class="highlighter-rouge">BufLen</code> + 1 and <code class="highlighter-rouge">BufLen</code> + 4 (UIAs are allocated on word boundaries and an extra byte is added to provide for zero termination of strings when UIAs are used for symbols.) <code class="highlighter-rouge">UIABuf</code> should be a variable. UIAs are initially filled with zeros, and will unify with the null atom (<code class="highlighter-rouge">''</code>).</p>

<p>The call <code class="highlighter-rouge">'$uia_size'(UIABuf, Size)</code> returns the actual size (in bytes) of the given UIA. If <code class="highlighter-rouge">Size</code> is less than or equal to the actual size of the given <code class="highlighter-rouge">UIABuf</code>, the call <code class="highlighter-rouge">'$uia_clip'(UIABuf, Size)</code> reduces the size of <code class="highlighter-rouge">UIABuf</code> by removing all but one of the trailing zeros (null bytes).</p>

<p>Single-byte values can be inserted into a UIA buffer using <code class="highlighter-rouge">'$uia_pokeb'/3</code>. The modifications are destructive, and do not disappear upon backtracking. These procedures can be used to modify system atoms (file names and strings that are represented as UIAs). However, this use is strongly discouraged. <code class="highlighter-rouge">UIABuf</code> should be a buffer obtained from <code class="highlighter-rouge">'$uia_alloc'/2</code>. Offset is the offset within the buffer to the place where <code class="highlighter-rouge">Value</code> is to be inserted. Both Offset and Value are integers. In <code class="highlighter-rouge">'$uia_pokeb'/3</code>, the buffer is viewed as a vector of bytes with the first byte having offset zero. The byte at <code class="highlighter-rouge">Offset</code> from the beginning of the buffer is changed to Value. The companion predicates <code class="highlighter-rouge">'$uia_pokew'/3</code>, <code class="highlighter-rouge">'$uia_pokel'/3</code>, <code class="highlighter-rouge">'$uia_poked'/3</code>, perform the corresponding operation on words, long words, and doubles, respectively.</p>

<p><code class="highlighter-rouge">'$uia_peekb'/3</code> is used to obtain specific bytes from a UIA buffer created by <code class="highlighter-rouge">'$uia_alloc'/2</code>, or from any other UIA existing in the system. The parameters for these procedures are specified as follows: The arguments of <code class="highlighter-rouge">'$uia_peekb'/3</code> are interpreted in the same manner as the parameters for <code class="highlighter-rouge">'$uia_pokeb'/3</code>. The parameter <code class="highlighter-rouge">Symbol</code> must be a UIA or an atom. The parameter <code class="highlighter-rouge">Size</code> must be an integer. The companion predicates, <code class="highlighter-rouge">'$uia_peekw'/3</code>, <code class="highlighter-rouge">'$uia_peekl'/3</code>, <code class="highlighter-rouge">'$uia_peekd'/3</code>, perform the corresponding operation on words, long words, and doubles, respectively.</p>

<p>Like <code class="highlighter-rouge">'$uia_pokeb'/3</code>, <code class="highlighter-rouge">'$uia_pokes'/3</code> views the buffer as a vector of bytes with offset zero specifying the first byte. But instead of replacing just a single byte, <code class="highlighter-rouge">'$uia_pokes'/3</code> replaces the portion of the buffer beginning at <code class="highlighter-rouge">Offset</code> and having length equal to the length of <code class="highlighter-rouge">Symbol</code>, using the characters of <code class="highlighter-rouge">Symbol</code> for the replacement. If <code class="highlighter-rouge">Symbol</code> would extend beyond the end of the buffer, <code class="highlighter-rouge">Symbol</code> is truncated at the end of the buffer. The parameter <code class="highlighter-rouge">Symbol</code> must be an atom. The parameter <code class="highlighter-rouge">Size</code> must be an integer.</p>

<p><code class="highlighter-rouge">'$uia_peeks'/3</code> binds Symbol to a UIA consisting of the characters beginning at position <code class="highlighter-rouge">Offset</code> and extending to the end of the buffer. <code class="highlighter-rouge">'$uia_peeks'/4</code> binds <code class="highlighter-rouge">Symbol</code> to a UIA consisting of the characters beginning at position <code class="highlighter-rouge">Offset</code> and extending to position <code class="highlighter-rouge">End</code> where <code class="highlighter-rouge">End</code> = <code class="highlighter-rouge">Offset</code> + <code class="highlighter-rouge">Size</code>. If <code class="highlighter-rouge">End</code> would occur beyond the end of the buffer, <code class="highlighter-rouge">Symbol</code> simply extends to the end of the buffer.</p>

<p>Provided that <code class="highlighter-rouge">Offset</code> and <code class="highlighter-rouge">Size</code> define a proper region within the given <code class="highlighter-rouge">UIABuf</code> (i.e., not including the final byte of <code class="highlighter-rouge">UIABuf</code>), <code class="highlighter-rouge">'$uia_poke'(UIABuf, Offset, Size, Value)</code> modifies the indicated region by copying characters from the given UIA (or symbol) <code class="highlighter-rouge">Value</code>. The size of the atom or UIA <code class="highlighter-rouge">Value</code> must be greater than or equal to <code class="highlighter-rouge">Size</code>. The region copied from <code class="highlighter-rouge">Value</code> is defined by offset 0 and <code class="highlighter-rouge">Size</code>.</p>

<p>Provided that <code class="highlighter-rouge">Offset</code> and <code class="highlighter-rouge">Size</code> define a proper region within the given <code class="highlighter-rouge">UIABuf</code> (i.e., not including the final byte of <code class="highlighter-rouge">UIABuf</code>), <code class="highlighter-rouge">'$uia_peek'(UIABuf, Offset, Size, Value)</code> extracts the indicated region from <code class="highlighter-rouge">UIABuf</code>, returning it as a new UIA <code class="highlighter-rouge">Value</code>.</p>

<p>When <code class="highlighter-rouge">Symbol</code> is a Prolog symbol (atom or UIA), <code class="highlighter-rouge">'$strlen'(Symbol, Size)</code> returns the length of the print name of that symbol (thus not counting the terminating null byte).</p>

<h2 id="examples">EXAMPLES</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>copy_atom_to_uia(Atom, UIABuf) :-
  name(Atom, ExplodedAtom),
  copy_list_to_uia(ExplodedAtom, UIABuf).

copy_list_to_uia(Ints, UIABuf) :-
  length([_ | Ints ], BufLen),
  '$uia_alloc'(BufLen, UIABuf),

copy_list_to_uia(Ints, 0, UIABuf).
copy_list_to_uia([ ], _, _) :- !.
copy_list_to_uia([H | T ], N, Buf) :-
  '$uia_pokeb'(Buf, N, H),
  NN is N + 1,
  copy_list_to_uia(T, NN, Buf).
</code></pre></div></div>

<h2 id="see-also">SEE ALSO</h2>

<ul>
  <li><code class="highlighter-rouge">atom_concat/3</code></li>
  <li><code class="highlighter-rouge">sub_atom/3</code></li>
  <li>`atom_char/2</li>
</ul>
