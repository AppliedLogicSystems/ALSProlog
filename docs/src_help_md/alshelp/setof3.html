<h2 id="forms">FORMS</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setof(Template, Goal, Collection)

bagof(Template, Goal, Collection)

findall(Template, Goal, Collection)

b_findall(Template, Goal, Collection, Bound)
</code></pre></div></div>

<h2 id="description">DESCRIPTION</h2>

<p>These predicates collect in the list <code class="highlighter-rouge">Collection</code>, the set of all instances of <code class="highlighter-rouge">Template</code> such that the goal, <code class="highlighter-rouge">Goal</code>, is provable. <code class="highlighter-rouge">Template</code> is a term that usually shares variables with <code class="highlighter-rouge">Goal</code>.</p>

<p><code class="highlighter-rouge">setof/3</code> produces a <code class="highlighter-rouge">Collection</code> which is sorted according to the standard order with all duplicate elements removed. Both <code class="highlighter-rouge">bagof/3</code> and <code class="highlighter-rouge">findall/3</code> produce <code class="highlighter-rouge">Collections</code> that are not sorted.</p>

<p>If there are no solutions to <code class="highlighter-rouge">Goal</code>, then <code class="highlighter-rouge">setof/3</code> and <code class="highlighter-rouge">bagof/3</code> will fail, whereas, <code class="highlighter-rouge">findall/3</code> unifies <code class="highlighter-rouge">Collection</code> with <code class="highlighter-rouge">[]</code>.</p>

<p>Variables that occur in <code class="highlighter-rouge">Goal</code> and not within <code class="highlighter-rouge">Template</code> are known as <strong><em>free, variables</em></strong>. <code class="highlighter-rouge">setof/3</code> and <code class="highlighter-rouge">bagof/3</code> will generate alternative bindings for free variables upon backtracking.</p>

<p>Within a call to <code class="highlighter-rouge">setof/3</code> or <code class="highlighter-rouge">bagof/3</code>, free variables can be existentially quantified in <code class="highlighter-rouge">Goal</code> by using the notation <code class="highlighter-rouge">Variable^Query</code>. This means that there exists a <code class="highlighter-rouge">Variable</code> such that <code class="highlighter-rouge">Query</code> is true.</p>

<p>The collection to be enumerated should be finite, and should be enumerable by Prolog in finite time. It is possible for the provable instances of <code class="highlighter-rouge">Template</code> to contain variables, but in this case <code class="highlighter-rouge">Collection</code> will only provide an imperfect representation of what is actually an infinite collection.</p>

<p><code class="highlighter-rouge">setof/3</code> calls upon <code class="highlighter-rouge">sort/2</code> to eliminate duplicate solutions from <code class="highlighter-rouge">Collection</code>, which seriously impacts its efficiency. In addition, even though <code class="highlighter-rouge">bagof/3</code> leaves duplicate solutions, it still calls <code class="highlighter-rouge">keysort/2</code>.</p>

<p><code class="highlighter-rouge">findall/3</code> neither removes duplicates nor generates alternative bindings for free variables; it assumes that all variables occurring within <code class="highlighter-rouge">Goal</code> are existentially quantified. As a result, <code class="highlighter-rouge">findall/3</code> is much more efficient than either <code class="highlighter-rouge">setof/3</code> or <code class="highlighter-rouge">bagof/3</code>.</p>

<p>When <code class="highlighter-rouge">Bound</code> is a positive integer, <code class="highlighter-rouge">b_findall/4</code> operates similarly to <code class="highlighter-rouge">findall/3</code>, except that it returns at most <code class="highlighter-rouge">Bound</code> number of solutions on the list <code class="highlighter-rouge">Collection</code>. It fails if <code class="highlighter-rouge">Bound</code> is anything other than a positive integer.</p>

<h2 id="examples">EXAMPLES</h2>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- listing.
% user:likes/2
likes(kev,running).
likes(kev,lifting).
likes(keith,running).
likes(keith,lifting).
likes(ken,swimming).
likes(sally,swimming).
likes(andy,bicycling).
likes(chris,lifting).
likes(chris,running).
yes.
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- setof(Person, likes(Person, Sport), SetOfPeople).
Person = _1
Sport = bicycling
SetOfPeople = [andy];
Person = _1
Sport = lifting
SetOfPeople = [chris,keith,kev];
Person = _1
Sport = running
SetOfPeople = [chris,keith,kev];
Person = _1
Sport = swimming
SetOfPeople = [sally,ken];
no.
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- setof((Sport,People),
setof(Person, likes(Person, Sport), People),
Set).
Sport = _1
People = _2
Person = _4
Set = [(bicycling,[andy]),(lifting,[chris,keith,kev]),
(running,[chris,keith,kev]),(swimming,[sally,ken])]
yes.
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- setof(Person, Sport^(Person likes Sport), SetOfPeople).
Person = _1
Sport = _2
SetOfPeople = [andy,chris,sally,keith,ken,kev]
yes.
</code></pre></div></div>

<h2 id="see-also">SEE ALSO</h2>

<ul>
  <li>[Bowen 91, 7.5]</li>
  <li>[Clocksin 81, 7.8]</li>
  <li>[Bratko 86, 7.6]</li>
  <li>[Sterling 86, 17.1]</li>
</ul>
