<h2 id="forms">FORMS</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>catch(Goal, Pattern, ExceptionGoal)

throw(Reason)
</code></pre></div></div>
<h2 id="description">DESCRIPTION</h2>

<p><code class="highlighter-rouge">catch/3</code> provides a facility for catching errors or exceptions and handling them gracefully. Execution of <code class="highlighter-rouge">catch/3</code> will cause the goal <code class="highlighter-rouge">Goal</code> to be executed. If no errors or throws occur during the execution of <code class="highlighter-rouge">Goal</code>, then <code class="highlighter-rouge">catch/3</code> behaves just as if <code class="highlighter-rouge">call/1</code> were called with <code class="highlighter-rouge">Goal</code>. <code class="highlighter-rouge">Goal</code> may succeed thus giving control to portions of the program outside the scope of the catch. Failures in these portions of the program may cause reexecution(via backtracking) of goals in the scope of the catch of which <code class="highlighter-rouge">Goal</code> is the ancestor.</p>

<p>If a goal of the form <code class="highlighter-rouge">throw(Reason)</code> is encountered during the execution of <code class="highlighter-rouge">Goal</code> or in any subsequent reexecution of <code class="highlighter-rouge">Goal</code>, then the goal <code class="highlighter-rouge">ExceptionGoal</code> of the <code class="highlighter-rouge">catch</code> with the innermost scope capable of unifying <code class="highlighter-rouge">Reason</code> and <code class="highlighter-rouge">Pattern</code> together will be executed with this unification intact. Once started, the execution of the goal <code class="highlighter-rouge">ExceptionGoal</code> behaves just like the execution of any other goal. The goal <code class="highlighter-rouge">ExceptionGoal</code> is outside of the scope of the catch which initiated the execution of <code class="highlighter-rouge">ExceptionGoal</code>, so any throws encountered during the execution of <code class="highlighter-rouge">ExceptionGoal</code> will be handled by <code class="highlighter-rouge">catch</code>es which are ancestors of the <code class="highlighter-rouge">catch</code> which initiated the execution of <code class="highlighter-rouge">ExceptionGoal</code>. This means that a handler may catch some fairly general pattern, deal with some aspects which it is prepared for, but throw on back to some earlier handler for those aspects for which it is not prepared.</p>

<p>Many of the builtins will cause an error if the types of the arguments to the builtin are wrong. There are other reasons for errors such as exhausting a certain resource. Whatever the cause, an error occurring during the execution of a goal causes <code class="highlighter-rouge">throw/1</code> to be executed. The effect is as if the goal which caused the error where replaced by a goal <code class="highlighter-rouge">throw(error(ErrorTerm, ErrorInfo))</code> where <code class="highlighter-rouge">ErrorTerm</code> and <code class="highlighter-rouge">ErrorInfo</code> supply information about the error. <code class="highlighter-rouge">ErrorTerm</code> is mandated by ISO Prolog Standard. <code class="highlighter-rouge">ErrorInfo</code> is an implementation defined (and therefore specific) term which may or may not provide additional information about the error.</p>

<p>The ISO Prolog Standard specifies that ErrorTerm be one of the following forms :</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">instantiation_error</code> – An argument or one of its components is a variable.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">type_error(ValidType, Culprit)</code> – An argument or one of its components is of the incorrect type. <code class="highlighter-rouge">ValidType</code> may be any one of the following atoms : <code class="highlighter-rouge">atom, body, callable, character, compound, constant, integer, list, number, variable</code>. <code class="highlighter-rouge">Culprit</code> is the argument or component which was of the incorrect type.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">domain_error(ValidDomain, Culprit)</code> – The base type of an argument is correct, but the value is outside the domain for which the predicate is defined. The ISO Prolog Standard states that ValidDomain may be any one of the following atoms: <code class="highlighter-rouge">character_code_list, character_list, close_option, flag_value, io_mode, not_less_than_zero, operator_priority, operator_specifier, prolog_flag, read_option, source_sink, stream_or_alias, stream_option, stream_position, write_option</code>. Moreover, ALS Prolog allows <code class="highlighter-rouge">ValidDomain</code> to take on these additional values : <code class="highlighter-rouge">depth_computation, line_length, positive_integer</code>. <code class="highlighter-rouge">Culprit</code> is the argument which caused the error.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">existence_error(ObjectType, Culprit)</code> – An operation is attempted on a certain type of object specified by <code class="highlighter-rouge">ObjectType</code> which does not exist. <code class="highlighter-rouge">Culprit</code> is the nonexistent object on which the operation was attempted. <code class="highlighter-rouge">ObjectType</code> may take on the following values: <code class="highlighter-rouge">operator, past_end_of_stream, procedure, static_procedure, source_sink, stream</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">permission_error(Operation, ObjectType, Culprit)</code> – <code class="highlighter-rouge">Operation</code> is an operation not permitted on object type <code class="highlighter-rouge">ObjectType</code>. <code class="highlighter-rouge">Culprit</code> is the object on which the error occurred. <code class="highlighter-rouge">ObjectType</code> is an atom taking on values as described above for <code class="highlighter-rouge">existence_error</code>. <code class="highlighter-rouge">Operation</code> may be one of the following atoms : <code class="highlighter-rouge">access_clause, create, input, modify, open, output, reposition</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">representation_error(Flag)</code> – The implementation defined limit indicated by <code class="highlighter-rouge">Flag</code> has been breached. <code class="highlighter-rouge">Flag</code> may be one of the following atoms : <code class="highlighter-rouge">character, character_code, exceeded_max_arity, flag</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">calculation_error(CalcFlag)</code> – An arithmetic operation resulted in an exceptional value as indicated by the atom <code class="highlighter-rouge">CalcFlag</code>. <code class="highlighter-rouge">CalcFlag</code> may take on the following values : <code class="highlighter-rouge">overflow, underflow, zero_divide, undefined</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">resource_error(Resource)</code> – There are insufficient resources to complete execution. The type of resource exhausted is indicated by the implementation-defined term <code class="highlighter-rouge">Resource</code>.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">syntax_error</code> – A sequence of characters being read by <code class="highlighter-rouge">read_term/4</code> cannot be parsed with the current operator definitions. The reason for the syntax error (in ALS Prolog) is given in the implementation-defined <code class="highlighter-rouge">ErrorInfo</code> (see below).</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">system_error</code> – Other sorts of errors. These will commonly be operating system-related errors such as being unable to complete a write operation due to the disk being full. Additional details about this type of error might be found in the implementation-defined term <code class="highlighter-rouge">ErrorInfo</code>.</p>
  </li>
</ul>

<p>In ALS Prolog, <code class="highlighter-rouge">ErrorInfo</code> is a list providing additional information where the ISO Prolog Standard mandated term <code class="highlighter-rouge">ErrorTerm</code> falls short. The terms which may be on this list take the following forms :</p>

<p><code class="highlighter-rouge">M:G</code> – The predicate in which the error occurred was in module <code class="highlighter-rouge">M</code> on goal <code class="highlighter-rouge">G</code>. Due to the compiled nature of ALS Prolog, it is not always possible to obtain all of the arguments to the goal <code class="highlighter-rouge">G</code>. Those which could not be obtained are indicated as such by the atom ‘ ? ‘ . For this reason, the form <code class="highlighter-rouge">M:G</code> should be used for informational purposes only.</p>

<p>errno(ErrNo) – This form is used to further elaborate on the reason that a system_error occurred. The errno/1 form indicates that a system call failed. The value of ErrNo is an integer which indicates the nature of the system error. The values that ErrNo take on may vary from system to system. ALS is looking at a symbolic way of providing this information.</p>

<p>syntax(Context, ErrorMessage, LineNumber, Stream) – This form is used to provide additional information about system errors. Context is an atom providing some information about the context in which the error occurred. ErrorMessage is an atom providing the text of the message for the error. LineNumber is the number of the line near which the syntax error occurred. Stream is the stream which was being read when the syntax error occurred.</p>

<h2 id="examples">EXAMPLES</h2>

<p>Attempt to open a non-existent file.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- open(wombat,read,S).
Error: Operation attempted on object of type source_sink which does not exist.
Operation attempted on: wombat.
- Goal:          sio:open(wombat,read,_A,?)
- Throw pattern: error(existence_error(source_sink,wombat),
                     [sio:open(wombat,read,_A,?)])
</code></pre></div></div>
<p>Attempt to open a file when the file argument is an uninstantiated variable:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- open(_, read, S).
Error: Instantiation error.
- Goal:          sio:open(_A,read,_B,[type(text)])
- Throw pattern: error(instantiation_error,[sio:open(_A,read,_B,*)])
</code></pre></div></div>
<p>Define a procedure <code class="highlighter-rouge">integer_list/2</code> to illustrate a use of <code class="highlighter-rouge">throw/1</code>.  Note that <code class="highlighter-rouge">il/2</code> builds the list and throws the result back at the appropriate time.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- reconsult(user).
integer_list(N,List)
    :-
    catch(il(N,[]),int_list(List),true),
    !.

il(0,L)
    :-
    throw(int_list(L)).
il(N,L)
    :-
    NN is N-1,
    il(NN,[N|L]).
^D
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- integer_list(8,L).
L=[1,2,3,4,5,6,7,8]
yes.
</code></pre></div></div>
<h2 id="errors">ERRORS</h2>

<p><code class="highlighter-rouge">Goal</code> is a variable</p>

<p>—- &gt; <code class="highlighter-rouge">instantiation_error</code>.</p>

<p><code class="highlighter-rouge">Goal</code> is not a callable term</p>

<p>—- &gt; <code class="highlighter-rouge">type_error(callable, Goal)</code>. [not yet implemented ]</p>

<p><code class="highlighter-rouge">Reason</code> does not unify with <code class="highlighter-rouge">Pattern</code> in any call of <code class="highlighter-rouge">catch/3</code></p>

<p>—- &gt; <code class="highlighter-rouge">system_error</code>. [not yet implemented ]</p>

<h2 id="notes">NOTES</h2>

<p>In the present implementation of ALS Prolog, <code class="highlighter-rouge">catch/3</code> leaves a choice point which is used to restore the scope of the catch when backtracked into. This choice point remains around even for determinate goals which are called from catch. Thus when catch succeeds, you should assume that a choice point has been created. If the program should be determinate, a cut should be placed immediately after the catch. It is expected that at some point in the future, this unfortunate aspect of ALS Prolog will be fixed, thus obviating the need for an explicit cut.</p>

<p>If throw/1 is called with Reason instantiated to a pattern which does not match Pattern in any call of catch/3, control will return to the program which started the Prolog environment. This usually means that Prolog silently exits to an operating system shell. When using the development environment, however, the Prolog shell establishes a handler for catching uncaught throws or errors thus avoiding this unceremonious exit from the Prolog system. It is occassionally possible, particularly with resource errors, to end up in this last chance handler only to have another error occur in attempting to handle the error. Since no handler exists to handle this error, control returns to the operating system often with no indication of what went wrong.</p>

