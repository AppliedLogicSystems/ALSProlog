<h2 id="forms">FORMS</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:- module_closure(Name, Arity, Procedure) .

:- module_closure(Name, Arity) .
</code></pre></div></div>
<h2 id="description">DESCRIPTION</h2>

<p>For some Prolog procedures, it is essential to know the module within which they are invoked. For example, <code class="highlighter-rouge">setof/3</code> must invoke the goal in its second argument relative to the correct module. The problem is that <code class="highlighter-rouge">setof/3</code> is defined in <code class="highlighter-rouge">module builtins</code>, while it may invoked in some other module which is where the code defining the goal in the second argument should be run. In reality, <code class="highlighter-rouge">setof/3</code> is defined as the module closure of another predicate <code class="highlighter-rouge">setof/4</code> (whose definition appears in the <code class="highlighter-rouge">builtins module</code>). The extra argument to <code class="highlighter-rouge">setof/4</code> is the module in which the goal in the second argument of <code class="highlighter-rouge">setof/3</code> is to be run. Declaring <code class="highlighter-rouge">setof/3</code> to be a module closure of <code class="highlighter-rouge">setof/4</code> means that goals of the form</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>..., setof(X, G, L), ...
</code></pre></div></div>
<p>are automatically expanded to goals of the form</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>..., setof(M, X, G, L), ...
</code></pre></div></div>
<p>where <code class="highlighter-rouge">M</code> is the current module; i.e., the module in which the original call took place. Thus <code class="highlighter-rouge">setof/4</code> is supplied with the correct module <code class="highlighter-rouge">M</code> in which to run the goal in the second argument of the original call to <code class="highlighter-rouge">setof/3</code>.</p>

<p>The actual predicate that you write should expect to receive the calling module as its first argument. Then one ‘ closes ‘ the predicate with a module closure declaration which suppresses the first(module) argument. The arguments to <code class="highlighter-rouge">module_closure/3</code> are as follows :</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">Name</code> is the name of the procedure the user will call.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Arity</code> is the number of arguments of the user procedure; that is, the number of arguments in the ‘closed’ procedure which the user procedure will call.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">Procedure</code> is the name of the(unclosed) procedure to call with the additional module argument. Note that <code class="highlighter-rouge">Procedure</code> can be different than <code class="highlighter-rouge">Name</code>, although they are often the same.</p>
  </li>
</ul>

<p>The procedure that the user will call should be exported if it is contained within a module. The actual (unclosed) procedure does not need to be exported.</p>

<p><code class="highlighter-rouge">module_closure/2</code> simply identifies the first and third arguments of module_closure/3. That is, the command</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:- module_closure(foo, 5) .
</code></pre></div></div>
<p>is equivalent to</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:- module_closure(foo, 5, foo) .
</code></pre></div></div>
<h2 id="examples">EXAMPLES</h2>

<p>The following example illustrates the use of <code class="highlighter-rouge">module_closure/3</code>. First assume that the following three modules and code have been created and loaded :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module m1.
use m3.
export testA/1.

testA(X) :- leading(X) .

p(tom).
p(dick).
p(harry).

endmod. % m1

module m2.
use m3.
export testB/1.

testB(X) :- leading(X) .

p(sally).
p(jane).
p(martha).

endmod. % m2

module m3.

leading(X) :- p(X) .

endmod. % m3
</code></pre></div></div>
<p>Attempting to run either testA or testB in default module <code class="highlighter-rouge">user</code> fails :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- testA(X).

no.

?- testB(X).

no.
</code></pre></div></div>
<p>This is because the call to p(X) runs in module m3 which has no clauses defining p/1. Now let us change module m3 to read as follows :</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module m3.

first(M, X) :- M:p(X).

export leading/1.

:- module_closure(leading, 1, first) .

endmod.
</code></pre></div></div>
<p>We have defined a new predicate <code class="highlighter-rouge">first/2</code> which carries a module as its first argument and which makes the call to <code class="highlighter-rouge">p(X)</code> in that module. And we have specified that <code class="highlighter-rouge">leading/1</code> is the module closure of <code class="highlighter-rouge">first/2</code>. Now the calls succeed :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- testA(X).

X=tom

yes.

?- testB(X).

X=sally

yes.
</code></pre></div></div>
<p>Note that we exported <code class="highlighter-rouge">leading/1</code> from <code class="highlighter-rouge">module m3</code>, and both <code class="highlighter-rouge">module m1</code> and <code class="highlighter-rouge">module m2</code> were declared to use <code class="highlighter-rouge">module m3</code>.</p>

<h2 id="see-also">SEE ALSO</h2>

<ul>
  <li>
    <p><code class="highlighter-rouge">:/2</code></p>
  </li>
  <li>
    <p>`User Guide (Modules)</p>
  </li>
</ul>

