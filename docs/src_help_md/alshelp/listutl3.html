<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>number_list/4</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">number_list/4</h1>
</header>
<h2 id="forms">FORMS</h2>
<p><code>nobind_member(X, List)</code></p>
<p><code>flatten(List, FlatList)</code></p>
<p><code>n_of(N, Item, Result)</code></p>
<p><code>is_length(List, N)</code></p>
<p><code>number_list(List, NumberedList)</code></p>
<p><code>number_list(Items, StartNum, NumberedItems)</code></p>
<p><code>encode_list(Items, Codes, CodedItems)</code></p>
<p><code>struct_lookup_subst(OrderedTags, DefArgs, ArgSpecs, ArgsList)</code></p>
<p><code>check_default(PList, Tag, Default, Value)</code></p>
<p><code>remove_tagged(EqnList, TagsToRemove, ReducedEqnList)</code></p>
<p><code>merge_plists(LeftEqnList, RightEqnList, MergedLists)</code></p>
<p><code>merge_tagged_lists(LeftEqnList, RightEqnList, MergedLists)</code></p>
<p><code>mangle_change_tagged(PList,Tag,NewValue)</code></p>
<p><code>subst_tagged(PList,Tag,NewValue,NewPList)</code></p>
<p><code>merge_in_list(Left, Right, Result)</code></p>
<h2 id="description">DESCRIPTION</h2>
<p><strong><code>nobind_member/2</code></strong> nobind_member(X, List) holds and only if X is a member of List; if the test is successful, no variables in either input are bound.</p>
<p><strong><code>flatten/2</code></strong> If List is a list, some of whose elements may be nested lists, FlatList is the flattened version of List obtained by traversing the tree defining List in depth-first, left-to-right order; compound structures other than list structures are not flattened.</p>
<p><strong><code>n_of/3</code></strong> Result is a list of length N all of whose elements are the entity Item.</p>
<p><strong><code>is_length/2</code></strong> List is of length N - works in both directions.</p>
<p><strong><code>number_list/2</code></strong> If List is a list, NumberedList is a list of terms of the form N-Item, where the Item components are simply the elements of List in order, and N is a integer, sequentially numbered the elements of List.</p>
<p><strong><code>number_list/3</code></strong> If Items is a list, and StartNum is an integer, NumberedItems is the list obtained by replacing each element X in Items by N-X, where N is the number of the position of X in Items.</p>
<p><strong><code>encode_list/3</code></strong> If Items is a list, and Codes is a list of atoms with length(Items) = length(Codes), then CodedItems is the list obtained by replacing each element X in Items by C-X, where C is the element of Codes in the position of X in Items.</p>
<p><strong><code>struct_lookup_subst/4</code></strong> OrderedTags and DefArgs are lists of the same length; so will be ArgsList. ArgSpecs is a list of equations of the form Tag = Value where each of the Tags in such an equation must be on the list OrderedTags (but not all OrderedTags elements must occur on ArgSpecs); in fact, ArgSpecs can be empty. The elements X of ArgsList are defined as follows: if X corresponds to Tag on OrderedTags, then: if Tag=Val occurs on ArgSpecs, X is Val; otherwise, X is the element of DefArgs corresponding to Tag.</p>
<p><strong><code>check_default/4.</code></strong> PList is a list of equations of the form tag = value check_default(PList, Tag, Default, Value) succeeds if: i) Tag=Value belongs to PList; or, ii) if Default is of the form Value^DC and call(DC) succeeds, or iii) if Default=Value</p>
<p><strong><code>remove_tagged/3</code></strong> EqnList is a list of equations of the form tag = value and TagsToRemove is a list of atoms which are candidates to occur as tags in these equations. ReducedEqnList is the result of removing all equations beginning with a tag from TagsToRemove from the list EqnList.</p>
<p><strong><code>merge_plists/3</code></strong> LeftEqnList and RightEqnList are lists of equations of the form tag = value MergedLists consists of all equations occurring in either LeftEqnList or RightEqnList, where if the equations Tag=LVal and Tag = RVal occur in LeftEqnList and RightEqnList, respectively, MergedLists will contain the equation Tag = MVal where: a) If both of LVal and RVal are lists, then MVal is obtained by recursively calling merge_plists(LVal, RVal, MVal), or if that fails, checking that they are identical; b) Otherwise, MVal is LVal.</p>
<p><strong><code>merge_tagged_lists/3</code></strong> LeftEqnList and RightEqnList are lists of equations of the form tag = value MergedLists consists of all equations occurring in either LeftEqnList or RightEqnList, where if the equations Tag=LVal and Tag = RVal occur in LeftEqnList and RightEqnList, respectively, MergedLists will contain the equation Tag = LVal</p>
<p><strong><code>mangle_change_tagged/3.</code></strong> If Plist is a list of tagged equations, Tag is a tag, and NewValue is an arbitrary prolog term, then: i) If an equation Tag=OldVal occurs on PList, destructively alters that eqn to become Tag=NewValue; ii) Has no effect otherwise.</p>
<p><strong><code>subst_tagged/4.</code></strong> If Plist is a list of tagged equations, Tag is a tag, and NewValue is an arbitrary prolog term, then: i) If an equation Tag=OldVal occurs on PList, then NewPList is the result of altering that eqn to become Tag=NewValue; ii) Otherwise, NewPList = OldPList.</p>
<p><strong><code>merge_in_list/3</code></strong> If Left and Right are lists, list Result consists of those elements of Left (in order, with duplicates preserved) which do not occur on Right, followed by list Right.</p>
<h2 id="examples">EXAMPLES</h2>
</body>
</html>
