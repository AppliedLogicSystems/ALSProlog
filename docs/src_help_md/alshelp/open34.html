<h2 id="forms">FORMS</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open(Name, Mode, Stream)

open(Name, Mode, Stream, Options)
</code></pre></div></div>
<h2 id="description">DESCRIPTION</h2>

<p><code class="highlighter-rouge">open/3</code> and <code class="highlighter-rouge">open/4</code> are used to open a file or other entities for input or output. Calling <code class="highlighter-rouge">open/3</code> is the same as calling <code class="highlighter-rouge">open/4</code> where <code class="highlighter-rouge">Options</code> is the empty list.</p>

<p>Once a stream has been opened with <code class="highlighter-rouge">open/3</code> or <code class="highlighter-rouge">open/4</code> for reading or writing, <code class="highlighter-rouge">read_term/3</code> or <code class="highlighter-rouge">write_term/3</code> can then be used to read terms from or write terms to the opened stream. <code class="highlighter-rouge">get_char/2</code> or <code class="highlighter-rouge">put_char/2</code> can be used to read or write characters.</p>

<p>A <strong><em>source</em></strong> refers to some entity which may be opened as a stream for read access. Such streams, once open, are called <em>input streams</em>. A <strong><em>sink</em></strong> refers to some entity which may be written to. Such a stream is called an <em>output stream</em>. There are streams which are both sources and sinks; such streams may be both read from and written to.</p>

<p>‘Name’ specifies the source/sink to be opened. Whether ‘Name’ is a source or a sink will depend on the value of ‘Mode’. ‘Mode’ may either be read, indicating that ‘Name’ is a source. Or ‘Mode’ may be write, which indicating that <code class="highlighter-rouge">Name</code> is a sink. If the source/sink specified by <code class="highlighter-rouge">Name</code>, <code class="highlighter-rouge">Mode</code>, and the options in <code class="highlighter-rouge">Options</code> is successfully opened, then <code class="highlighter-rouge">Stream</code> will be unified with a stream descriptor which may be used in I/O operations on the stream. If the stream could not be successfully opened, then an error is thrown.</p>

<p>If <code class="highlighter-rouge">Name</code> is an atom, then the contents of the stream are the contents of the file with name <code class="highlighter-rouge">Name</code>. <code class="highlighter-rouge">Mode</code> may take on additional values for file streams. The values which <code class="highlighter-rouge">Mode</code> may take on for file streams are:</p>

<p><code class="highlighter-rouge">read</code> – open the file for read access</p>

<p><code class="highlighter-rouge">write</code> – open the file for write access; truncate or create the file as necessary</p>

<p><code class="highlighter-rouge">read_write</code> – both reading and writing are permitted; file is not truncated on open</p>

<p><code class="highlighter-rouge">append</code> – open file with write access and position at end of stream; file is not truncated on open</p>

<p>If <code class="highlighter-rouge">Name</code> has the form <code class="highlighter-rouge">atom(A)</code>, then <code class="highlighter-rouge">Name</code> represents an atom stream. When opened with <code class="highlighter-rouge">Mode</code> equal to read, <code class="highlighter-rouge">A</code> must be an atom. The contents of the stream are simply the characters comprising the atom <code class="highlighter-rouge">A</code>. When opened for write access, <code class="highlighter-rouge">A</code> will be unified with the atom formed from the characters written to the stream during the time that the stream was open. The unification is carried out at the time that the stream is closed.</p>

<p>If <code class="highlighter-rouge">Name</code> has the form <code class="highlighter-rouge">code_list(CL)</code> or <code class="highlighter-rouge">string(CL)</code>, then <code class="highlighter-rouge">Name</code> represents a character-code list stream. When opened for read access, the contents of such a stream are the character codes found in the list <code class="highlighter-rouge">CL</code>. When opened for write access, <code class="highlighter-rouge">CL</code> will be unified with a list of character codes. This list is formed from the codes of characters written to the stream during the lifetime of the stream. The unification is carried out when the stream is closed.</p>

<p>If <code class="highlighter-rouge">Name</code> has the form <code class="highlighter-rouge">char_list(CL)</code>, then <code class="highlighter-rouge">Name</code> represents a character list stream. The behavior of character list streams is identical to that of code list streams with the exception that the types of the objects in the lists are different. A code list consists of character codes, whereas a character list consists of a list of characters.</p>

<p><code class="highlighter-rouge">Name</code> may also take on one of the following forms representing a socket stream:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>socket(unix, PathName)

socket(inet_stream, Host)

socket(inet_stream, Host, Port)

socket(inet_dgram, Host, Port)

socket(clone, Stream_Or_Alias)
</code></pre></div></div>
<p>Regardless of the mode(read or write), the call to <code class="highlighter-rouge">open/[3,4]</code> will attempt to open the socket stream as a server (if appropriate). Failing that, it will attempt to open the stream as a client. If a connection-oriented socket is opened as a server, then prior to the first buffer read or write, the stream will wait for a client to connect. If the stream is opened as a client, the connection (in a connection-oriented socket) is established as part of the open.</p>

<p><code class="highlighter-rouge">socket(unix, PathName)</code>: Open a unix domain socket. Addresses in the unix domain are merely path names which are specified by <code class="highlighter-rouge">PathName</code>. Unix domain sockets are somewhat limited in that both the server and client process must reside on the same machine. The stream will be opened as a server if the name specified by <code class="highlighter-rouge">PathName</code> does not currently exist (and the requisite permissions exist to create a directory entry). Otherwise, the stream will be opened as a client.</p>

<p><code class="highlighter-rouge">socket(inet_stream, Host)</code>: Open an internet domain stream socket on the host given by <code class="highlighter-rouge">Host</code> using port number 1599. The stream will be opened as a server if <code class="highlighter-rouge">Host</code> is set to the name of the host on which the process is running and no other process has already established a server stream on this port. Otherwise, the stream will be opened as a client. A permission error will be generated if neither operation can be performed. The host specification may either be a host name or an internet address.</p>

<p><code class="highlighter-rouge">socket(inet_stream, Host, Port)</code>: Similar to the above, but the Port may specified. This permits an application to choose its own "well known" port number and act as either a server or client. Alternately, both <code class="highlighter-rouge">Host</code> and <code class="highlighter-rouge">Port</code> may be variable, in which case the system will open a stream at a port of its choosing. When variable, <code class="highlighter-rouge">Host</code> and <code class="highlighter-rouge">Port</code> will be instantiated to values of the current host and the port which was actually opened.</p>

<p><code class="highlighter-rouge">socket(inet_dgram, Host, Port)</code>: Similar to inet_stream, but a datagram socket is created instead. A datagram socket is an endpoint which is not connected. The datagram socket will be opened as a server socket if the <code class="highlighter-rouge">Host</code> is either variable or bound to the name of the current host and <code class="highlighter-rouge">Port</code> is either variable or bound to a port number which is not currently in use. Otherwise, a client socket is established which (by default) will write to the host and port indicated by <code class="highlighter-rouge">Host</code> and <code class="highlighter-rouge">Port</code>. A server socket is initially set up to write out to UDP port 9 which will discard any messages sent. Datagram sockets will set the end-of-file indication for each datagram read. This mechanism permits code written in Prolog to fully process each incoming datagram without having to worry about running over into the next datagram. <code class="highlighter-rouge">flush_input/1</code> should be used to reset the stream attached to the datagram in order for more input to be read. Programmers using datagrams should strive to make each datagram self contained. If this is a hardship, stream sockets should be used instead.</p>

<p><code class="highlighter-rouge">socket(clone, Stream_or_Alias)</code>: This specification will create a new(prolog) stream descriptor for a socket from an existing socket stream descriptor. This gives the programmer the ability to create more than one buffer which refers to the same socket. This cloning mechanism has two uses. Firstly, sockets are full duplex which means that they may be both read from and written to. Yet, the interface which ALS Prolog provides will only naturally provide read access or write access, not both simultaneously. The cloning mechanism accommodates this problem by allowing separate(prolog) stream descriptors for each mode which refer to the same unix socket descriptor. Secondly, server socket streams will only act as a server until a connection is established. Once the connection is made, they lose their "server" property. An application which wants to service more than one client will want to clone its "server" descriptor prior to performing any reads to or writes from the stream.</p>

<p><code class="highlighter-rouge">Name</code> may also take the form <code class="highlighter-rouge">url(URL)</code> or <code class="highlighter-rouge">url(URL, Options)</code>, representing a Curl-based internet-stream. A stream <code class="highlighter-rouge">S</code> opened with</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open(url(&lt;URL&gt;, &lt;CurlOptionList&gt;), read, S, &lt;possible generic stream options&gt;)
</code></pre></div></div>
<p>will contain the characters returned by a GET to <code class="highlighter-rouge">&lt;URL&gt;</code>, conditioned by <code class="highlighter-rouge">&lt;CurlOptionList&gt;</code> and <code class="highlighter-rouge">&lt;possible generic stream options&gt;</code>.</p>

<p>A stream S opened with</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>open(url(&lt;URL&gt;, &lt;CurlOptionList&gt;), write, S, &lt;possible generic stream options&gt;)
</code></pre></div></div>
<p>will capture all characters written to <code class="highlighter-rouge">S</code> (write,nl,printf, etc.), and when <code class="highlighter-rouge">S</code> is closed, the sequence of characters in <code class="highlighter-rouge">S</code> will be POSTed to ``, conditioned by <code class="highlighter-rouge">&lt;CurlOptionList&gt;</code> and <code class="highlighter-rouge">&lt;possible generic stream options&gt;</code>.  WARNING: The implementation of open(url(,), write, S, …) utilizes the freeze construct. Everything will work correctly so long as no gc (garbage collection) takes place; otherwise, Issue #87 will cause incorrect and unpredictable behavior.</p>

<p>For both read and write internet url streams, the options available for <code class="highlighter-rouge">&lt;CurlOptionList&gt;</code> are exactly the same as for <code class="highlighter-rouge">http/3</code> or <code class="highlighter-rouge">curl/[1,3]</code>.</p>

<p>The behavior and disposition of a stream may be influenced by the (generic) <code class="highlighter-rouge">Options</code> arguments. <code class="highlighter-rouge">Options</code> is a list comprising one or more of the following terms :</p>

<p><code class="highlighter-rouge">type(T)</code> – <code class="highlighter-rouge">T</code> may be either text or binary. This defines whether the stream is a text stream or a binary stream. At present, ALS Prolog makes no distinction between these two types.</p>

<p><code class="highlighter-rouge">alias(Alias)</code> – <code class="highlighter-rouge">Alias</code> must be an atom. This option specifies an alias for the stream. If an alias is established, the alias may be passed in lieu of the stream descriptor to predicates requiring a stream handle.</p>

<p><code class="highlighter-rouge">reposition(R)</code> – <code class="highlighter-rouge">R</code> is either true or false. <code class="highlighter-rouge">reposition(true)</code> indicates that the stream must be repositionable. If it is not, <code class="highlighter-rouge">open/3</code> or <code class="highlighter-rouge">open/4</code> will throw an error. <code class="highlighter-rouge">reposition(false)</code> indicates that the stream is not repositionable and any attempt to reposition the stream will result in an error. If neither option is specified, the stream will be opened as repositionable if possible. A program can find out if a stream is repositionable or not by calling <code class="highlighter-rouge">stream_property/2</code>.</p>

<p><code class="highlighter-rouge">eof_action(Action)</code> – <code class="highlighter-rouge">Action</code> may be one of <code class="highlighter-rouge">error, eof_code</code>, or <code class="highlighter-rouge">reset</code>. <code class="highlighter-rouge">Action</code> instantiated to <code class="highlighter-rouge">error</code> indicates that an existence error should be triggered when a stream attempts to read past <code class="highlighter-rouge">end-of-file</code>. The default <code class="highlighter-rouge">Action</code> is <code class="highlighter-rouge">eof_code</code> which will cause an input predicate reading past <code class="highlighter-rouge">end-of-file</code> to return a distinguished value as the output of the predicate (either <code class="highlighter-rouge">end_of_file</code>, or -1) . Finally, <code class="highlighter-rouge">Action</code> instantiated to reset indicates that the stream should be reset upon <code class="highlighter-rouge">end-of-file</code>.</p>

<p><code class="highlighter-rouge">snr_action(Action)</code> – <code class="highlighter-rouge">Action</code> may be one of <code class="highlighter-rouge">error, snr_code</code>, or <code class="highlighter-rouge">wait</code>. As with <code class="highlighter-rouge">eof_action</code>, <code class="highlighter-rouge">Action</code> instantiated to <code class="highlighter-rouge">error</code> will generate an existence error when an input operation attempts to read from a stream for which no input is ready. As with <code class="highlighter-rouge">eof_action</code>, <code class="highlighter-rouge">Action</code> instantiated to <code class="highlighter-rouge">snr_code</code> will force the input predicate to return a distinguished code when the stream is not ready. This code will be either -2 or the atom <code class="highlighter-rouge">stream_not_ready</code>. The default <code class="highlighter-rouge">Action</code> is <code class="highlighter-rouge">wait</code> which will force the input operation to wait until the stream is ready.</p>

<p><code class="highlighter-rouge">buffering(B)</code> – <code class="highlighter-rouge">B</code> is either <code class="highlighter-rouge">byte, line</code>, or <code class="highlighter-rouge">block</code>. This option applies to streams open for output. If <code class="highlighter-rouge">buffering(byte)</code> is specified, the stream buffer will be flushed (actually written out) after each character. <code class="highlighter-rouge">buffering(line)</code> is useful for streams which interact with a user; the buffer is flushed when a newline character is put into the buffer. <code class="highlighter-rouge">buffering(block)</code> is the default; the buffer is not flushed until the block is full or until a call to <code class="highlighter-rouge">flush_output/1</code> is made.</p>

<p><code class="highlighter-rouge">bufsize(Size)</code> – <code class="highlighter-rouge">Size</code> must be a positive integer. The <code class="highlighter-rouge">Size</code> parameter indicates the size of buffer to allocate the associated stream. The default size should be adequate for most streams.</p>

<p><code class="highlighter-rouge">prompt_goal(Goal)</code> – <code class="highlighter-rouge">Goal</code> should be a ground callable term. This option is used when opening an input stream. <code class="highlighter-rouge">Goal</code> will be run each time a new buffer is read. This option is most useful when used in conjunction with opening an output stream where a prompt should be written to whenever new input is required from the input stream.</p>

<p><code class="highlighter-rouge">maxdepth(Depth)</code> – <code class="highlighter-rouge">Depth</code> is a positive integer. This option when specified for an output stream sets the default maximum depth used to write out a term with <code class="highlighter-rouge">write_term/3</code>, et. al. Explicit options to <code class="highlighter-rouge">write_term/3</code> may be used to override this option.</p>

<p><code class="highlighter-rouge">depth_computation(DC)</code> – <code class="highlighter-rouge">DC</code> should be either <code class="highlighter-rouge">flat</code> or <code class="highlighter-rouge">nonflat</code>. This option indicates the default mechanism to be used for <code class="highlighter-rouge">write_term/3</code> to compute the depth of a term. <code class="highlighter-rouge">flat</code> indicates that all arguments in a list or structured term should be considered to be at the same depth. <code class="highlighter-rouge">nonflat</code> indicates that each successive element of a structured term or list is at depth one greater than its predecessor.</p>

<p><code class="highlighter-rouge">line_length(Length)</code> – <code class="highlighter-rouge">Length</code> is a positive integer. This option is used to set the default line length associated with the (output) stream. Predicates which deal with term output use this parameter to break the line at appropriate points when outputting a term which will span several lines. Explicit options to <code class="highlighter-rouge">write_term/3</code> may be used to override this option.</p>

<p><code class="highlighter-rouge">write_eoln_type(Type)</code> - allows control over which end-of-line(eoln) characters are output by <code class="highlighter-rouge">nl/1</code>. The values for <code class="highlighter-rouge">Type</code> and the corresponding eoln characters are: <code class="highlighter-rouge">cr("\r")</code>, <code class="highlighter-rouge">lf("\n")</code>, and <code class="highlighter-rouge">crlf("\r\n")</code>. The default is determined by the operating system : MacOSX(lf), Unix(lf), and Win32/DOS(crlf).</p>

<p><code class="highlighter-rouge">read_eoln_type(Type)</code> - determines what <code class="highlighter-rouge">read/2</code> and <code class="highlighter-rouge">get_line/3</code> recognize as an <code class="highlighter-rouge">end-of-line</code>. The values for <code class="highlighter-rouge">Type</code> and the corresponding <code class="highlighter-rouge">ends-of-line</code> are: <code class="highlighter-rouge">cr</code> - carriage return(“\r”) <code class="highlighter-rouge">lf</code> - line feed(“\n”), <code class="highlighter-rouge">crlf</code> - carriage return followed by a line feed(“\r\n”), <code class="highlighter-rouge">universal</code> - indicates that any of the end-of-line types(<code class="highlighter-rouge">cr,lf,crlfl</code>) should be interpreted as an <code class="highlighter-rouge">end-of-line</code>. The default is <code class="highlighter-rouge">universal</code> since this allows the correct <code class="highlighter-rouge">end-of-line</code> interpretation for text files on all operating systems.</p>

<h2 id="examples">EXAMPLES</h2>
<p>Open a file named example.dat for write access, write a term to it and close it.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- open('example.dat',write,S), writeq(S, example(term)),
?-_ put_char(S,'.'), nl(S), close(S).

S = stream_descriptor('',closed,file,'example.dat', [noinput|output], true,
2,0,0,0,0,true,0, wt_opts(78,40000,flat),[],true,text,eof_code,0,0)

yes.
</code></pre></div></div>
<p>Open a file named example.dat for read access with alias example.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- open('example.dat',read,_,[alias(example)]).

yes.
</code></pre></div></div>
<p>Read a term from stream with alias example.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- read(example,T).

T = example(term)

yes.
</code></pre></div></div>
<p>Read another term from with stream with alias example.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- read(example,T).

T = end_of_file

yes.
</code></pre></div></div>
<p>Close the stream aliased example.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?- close(example).

yes.
</code></pre></div></div>

<h2 id="errors">ERRORS</h2>

<p><code class="highlighter-rouge">Name</code>, <code class="highlighter-rouge">Mode</code>, or <code class="highlighter-rouge">Options</code> is a variable</p>

<p>– – – – &gt; instantiation_error.</p>

<p><code class="highlighter-rouge">Name</code> does not refer to either a variable or a source/sink</p>

<p>– – – – &gt; domain_error(source_sink, Name) .</p>

<p><code class="highlighter-rouge">Mode</code> is neither a variable nor an atom</p>

<p>– – – – &gt; type_error(atom, Mode) .</p>

<p><code class="highlighter-rouge">Mode</code> is an atom, but not a valid I/O mode for the given source/sink</p>

<p>– – – – &gt; domain_error(io_mode, Mode) .</p>

<p><code class="highlighter-rouge">Stream</code> is not a variable</p>

<p>– – – – &gt; type_error(variable, Stream) .</p>

<p><code class="highlighter-rouge">Options</code> is neither a variable nor a list</p>

<p>– – – – &gt; type_error(list, Options) .</p>

<p><code class="highlighter-rouge">Options</code> is a list with a variable element</p>

<p>– – – – &gt; instantiation_error.</p>

<p><code class="highlighter-rouge">Options</code> is a list with element E which is not a valid stream option</p>

<p>– – – – &gt; domain_error(stream_option, E) .</p>

<p><code class="highlighter-rouge">Name</code> specifies a valid source/sink, but can not be opened. If <code class="highlighter-rouge">Name</code> refers to a file, the file may not exist or the protection on the file or containing directory might be set to be incompatible with the open mode</p>

<p>– – – – &gt; permission_error(open, source_sink, Name) .</p>

<p><code class="highlighter-rouge">Options</code> contains an element <code class="highlighter-rouge">alias(A)</code> and <code class="highlighter-rouge">A</code> is already associated with another stream</p>

<p>– – – – &gt; permission_error(open, source_sink, alias(A)) .</p>

<p><code class="highlighter-rouge">Options</code> contains an element <code class="highlighter-rouge">reposition(true)</code> and it is not possible to reposition a stream corresponding to the source/sink <code class="highlighter-rouge">Name</code>.</p>

<p>– – – – &gt; permission_error(open, source_sink, reposition(true)) .</p>

<h2 id="notes">NOTES</h2>

<p>The structured term comprising a stream descriptor is visible to the programmer. The programmer should not directly use the stream descriptor to learn of properties or attributes associated with the stream or otherwise rely on the representation of stream descriptors. Use <code class="highlighter-rouge">stream_property/2</code> to examine the properties associated with a stream.</p>

<p>The DEC-10 compatibility predicates <code class="highlighter-rouge">see/1</code> and <code class="highlighter-rouge">tell/1</code> are defined in terms of <code class="highlighter-rouge">open/4</code>. When a stream is opened with either of these predicates it is assigned an alias which is the name of the source/sink. Thus the single argument to <code class="highlighter-rouge">see/1</code> and <code class="highlighter-rouge">tell/1</code> may be considered to be both the name of the stream and an alias for the stream.</p>

<h2 id="see-also">SEE ALSO</h2>

<ul>
  <li>
    <p><code class="highlighter-rouge">close/1</code><br />
<code class="highlighter-rouge">current_input/1</code><br />
<code class="highlighter-rouge">current_output/1</code><br />
<code class="highlighter-rouge">flush_input/1</code><br />
<code class="highlighter-rouge">flush_output/1</code><br />
<code class="highlighter-rouge">stream_property/2</code><br />
<code class="highlighter-rouge">curl/[1,3]</code><br />
<code class="highlighter-rouge">http/3</code><br />
<code class="highlighter-rouge">read_term/3</code><br />
<code class="highlighter-rouge">write_term/3</code><br />
<code class="highlighter-rouge">get_char/1</code><br />
<code class="highlighter-rouge">put_char/1</code><br />
<code class="highlighter-rouge">set_stream_position/2</code></p>
  </li>
  <li>
    <p>`User Guide (Prolog I/O)</p>
  </li>
</ul>
