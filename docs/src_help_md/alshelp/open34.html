<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>open/[3,4]</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">open/[3,4]</h1>
</header>
<p><code>open/3</code> — open a stream</p>
<p><code>open/4</code> — open a stream with options</p>
<h2 id="forms">FORMS</h2>
<pre><code>open(Name, Mode, Stream)

open(Name, Mode, Stream, Options)</code></pre>
<h2 id="description">DESCRIPTION</h2>
<p><code>open/3</code> and <code>open/4</code> are used to open a file or other entities for input or output. Calling <code>open/3</code> is the same as calling <code>open/4</code> where <code>Options</code> is the empty list.</p>
<p>Once a stream has been opened with <code>open/3</code> or <code>open/4</code> for reading or writing, <code>read_term/3</code> or <code>write_term/3</code> can then be used to read terms from or write terms to the opened stream. <code>get_char/2</code> or <code>put_char/2</code> can be used to read or write characters.</p>
<p>A <strong><em>source</em></strong> refers to some entity which may be opened as a stream for read access. Such streams, once open, are called <em>input streams</em>. A <strong><em>sink</em></strong> refers to some entity which may be written to. Such a stream is called an <em>output stream</em>. There are streams which are both sources and sinks; such streams may be both read from and written to.</p>
<p>‘Name’ specifies the source/sink to be opened. Whether ‘Name’ is a source or a sink will depend on the value of ‘Mode’. ‘Mode’ may either be read, indicating that ‘Name’ is a source. Or ‘Mode’ may be write, which indicating that <code>Name</code> is a sink. If the source/sink specified by <code>Name</code>, <code>Mode</code>, and the options in <code>Options</code> is successfully opened, then <code>Stream</code> will be unified with a stream descriptor which may be used in I/O operations on the stream. If the stream could not be successfully opened, then an error is thrown.</p>
<p>If <code>Name</code> is an atom, then the contents of the stream are the contents of the file with name <code>Name</code>. <code>Mode</code> may take on additional values for file streams. The values which <code>Mode</code> may take on for file streams are:</p>
<p><code>read</code> – open the file for read access</p>
<p><code>write</code> – open the file for write access; truncate or create the file as necessary</p>
<p><code>read_write</code> – both reading and writing are permitted; file is not truncated on open</p>
<p><code>append</code> – open file with write access and position at end of stream; file is not truncated on open</p>
<p>If <code>Name</code> has the form <code>atom(A)</code>, then <code>Name</code> represents an atom stream. When opened with <code>Mode</code> equal to read, <code>A</code> must be an atom. The contents of the stream are simply the characters comprising the atom <code>A</code>. When opened for write access, <code>A</code> will be unified with the atom formed from the characters written to the stream during the time that the stream was open. The unification is carried out at the time that the stream is closed.</p>
<p>If <code>Name</code> has the form <code>code_list(CL)</code> or <code>string(CL)</code>, then <code>Name</code> represents a character-code list stream. When opened for read access, the contents of such a stream are the character codes found in the list <code>CL</code>. When opened for write access, <code>CL</code> will be unified with a list of character codes. This list is formed from the codes of characters written to the stream during the lifetime of the stream. The unification is carried out when the stream is closed.</p>
<p>If <code>Name</code> has the form <code>char_list(CL)</code>, then <code>Name</code> represents a character list stream. The behavior of character list streams is identical to that of code list streams with the exception that the types of the objects in the lists are different. A code list consists of character codes, whereas a character list consists of a list of characters.</p>
<p><code>Name</code> may also take on one of the following forms representing a socket stream:</p>
<pre><code>socket(unix, PathName)

socket(inet_stream, Host)

socket(inet_stream, Host, Port)

socket(inet_dgram, Host, Port)

socket(clone, Stream_Or_Alias)</code></pre>
<p>Regardless of the mode(read or write), the call to <code>open/[3,4]</code> will attempt to open the socket stream as a server (if appropriate). Failing that, it will attempt to open the stream as a client. If a connection-oriented socket is opened as a server, then prior to the first buffer read or write, the stream will wait for a client to connect. If the stream is opened as a client, the connection (in a connection-oriented socket) is established as part of the open.</p>
<p><code>socket(unix, PathName)</code>: Open a unix domain socket. Addresses in the unix domain are merely path names which are specified by <code>PathName</code>. Unix domain sockets are somewhat limited in that both the server and client process must reside on the same machine. The stream will be opened as a server if the name specified by <code>PathName</code> does not currently exist (and the requisite permissions exist to create a directory entry). Otherwise, the stream will be opened as a client.</p>
<p><code>socket(inet_stream, Host)</code>: Open an internet domain stream socket on the host given by <code>Host</code> using port number 1599. The stream will be opened as a server if <code>Host</code> is set to the name of the host on which the process is running and no other process has already established a server stream on this port. Otherwise, the stream will be opened as a client. A permission error will be generated if neither operation can be performed. The host specification may either be a host name or an internet address.</p>
<p><code>socket(inet_stream, Host, Port)</code>: Similar to the above, but the Port may specified. This permits an application to choose its own “well known” port number and act as either a server or client. Alternately, both <code>Host</code> and <code>Port</code> may be variable, in which case the system will open a stream at a port of its choosing. When variable, <code>Host</code> and <code>Port</code> will be instantiated to values of the current host and the port which was actually opened.</p>
<p><code>socket(inet_dgram, Host, Port)</code>: Similar to inet_stream, but a datagram socket is created instead. A datagram socket is an endpoint which is not connected. The datagram socket will be opened as a server socket if the <code>Host</code> is either variable or bound to the name of the current host and <code>Port</code> is either variable or bound to a port number which is not currently in use. Otherwise, a client socket is established which (by default) will write to the host and port indicated by <code>Host</code> and <code>Port</code>. A server socket is initially set up to write out to UDP port 9 which will discard any messages sent. Datagram sockets will set the end-of-file indication for each datagram read. This mechanism permits code written in Prolog to fully process each incoming datagram without having to worry about running over into the next datagram. <code>flush_input/1</code> should be used to reset the stream attached to the datagram in order for more input to be read. Programmers using datagrams should strive to make each datagram self contained. If this is a hardship, stream sockets should be used instead.</p>
<p><code>socket(clone, Stream_or_Alias)</code>: This specification will create a new(prolog) stream descriptor for a socket from an existing socket stream descriptor. This gives the programmer the ability to create more than one buffer which refers to the same socket. This cloning mechanism has two uses. Firstly, sockets are full duplex which means that they may be both read from and written to. Yet, the interface which ALS Prolog provides will only naturally provide read access or write access, not both simultaneously. The cloning mechanism accommodates this problem by allowing separate(prolog) stream descriptors for each mode which refer to the same unix socket descriptor. Secondly, server socket streams will only act as a server until a connection is established. Once the connection is made, they lose their “server” property. An application which wants to service more than one client will want to clone its “server” descriptor prior to performing any reads to or writes from the stream.</p>
<p><code>Name</code> may also take the form <code>url(URL)</code> or <code>url(URL, Options)</code>, representing a Curl-based internet-stream. A stream <code>S</code> opened with</p>
<pre><code>open(url(&lt;URL&gt;, &lt;CurlOptionList&gt;), read, S, &lt;possible generic stream options&gt;)</code></pre>
<p>will contain the characters returned by a GET to <code>&lt;URL&gt;</code>, conditioned by <code>&lt;CurlOptionList&gt;</code> and <code>&lt;possible generic stream options&gt;</code>.</p>
<p>A stream S opened with</p>
<pre><code>open(url(&lt;URL&gt;, &lt;CurlOptionList&gt;), write, S, &lt;possible generic stream options&gt;)</code></pre>
<p>will capture all characters written to <code>S</code> (write,nl,printf, etc.), and when <code>S</code> is closed, the sequence of characters in <code>S</code> will be POSTed to `<code>, conditioned by</code><CurlOptionList><code>and</code><possible generic stream options>`. WARNING: The implementation of open(url(,), write, S, …) utilizes the freeze construct. Everything will work correctly so long as no gc (garbage collection) takes place; otherwise, Issue #87 will cause incorrect and unpredictable behavior.</p>
<p>For both read and write internet url streams, the options available for <code>&lt;CurlOptionList&gt;</code> are exactly the same as for <code>http/3</code> or <code>curl/[1,3]</code>.</p>
<p>The behavior and disposition of a stream may be influenced by the (generic) <code>Options</code> arguments. <code>Options</code> is a list comprising one or more of the following terms :</p>
<p><code>type(T)</code> – <code>T</code> may be either text or binary. This defines whether the stream is a text stream or a binary stream. At present, ALS Prolog makes no distinction between these two types.</p>
<p><code>alias(Alias)</code> – <code>Alias</code> must be an atom. This option specifies an alias for the stream. If an alias is established, the alias may be passed in lieu of the stream descriptor to predicates requiring a stream handle.</p>
<p><code>reposition(R)</code> – <code>R</code> is either true or false. <code>reposition(true)</code> indicates that the stream must be repositionable. If it is not, <code>open/3</code> or <code>open/4</code> will throw an error. <code>reposition(false)</code> indicates that the stream is not repositionable and any attempt to reposition the stream will result in an error. If neither option is specified, the stream will be opened as repositionable if possible. A program can find out if a stream is repositionable or not by calling <code>stream_property/2</code>.</p>
<p><code>eof_action(Action)</code> – <code>Action</code> may be one of <code>error, eof_code</code>, or <code>reset</code>. <code>Action</code> instantiated to <code>error</code> indicates that an existence error should be triggered when a stream attempts to read past <code>end-of-file</code>. The default <code>Action</code> is <code>eof_code</code> which will cause an input predicate reading past <code>end-of-file</code> to return a distinguished value as the output of the predicate (either <code>end_of_file</code>, or -1) . Finally, <code>Action</code> instantiated to reset indicates that the stream should be reset upon <code>end-of-file</code>.</p>
<p><code>snr_action(Action)</code> – <code>Action</code> may be one of <code>error, snr_code</code>, or <code>wait</code>. As with <code>eof_action</code>, <code>Action</code> instantiated to <code>error</code> will generate an existence error when an input operation attempts to read from a stream for which no input is ready. As with <code>eof_action</code>, <code>Action</code> instantiated to <code>snr_code</code> will force the input predicate to return a distinguished code when the stream is not ready. This code will be either -2 or the atom <code>stream_not_ready</code>. The default <code>Action</code> is <code>wait</code> which will force the input operation to wait until the stream is ready.</p>
<p><code>buffering(B)</code> – <code>B</code> is either <code>byte, line</code>, or <code>block</code>. This option applies to streams open for output. If <code>buffering(byte)</code> is specified, the stream buffer will be flushed (actually written out) after each character. <code>buffering(line)</code> is useful for streams which interact with a user; the buffer is flushed when a newline character is put into the buffer. <code>buffering(block)</code> is the default; the buffer is not flushed until the block is full or until a call to <code>flush_output/1</code> is made.</p>
<p><code>bufsize(Size)</code> – <code>Size</code> must be a positive integer. The <code>Size</code> parameter indicates the size of buffer to allocate the associated stream. The default size should be adequate for most streams.</p>
<p><code>prompt_goal(Goal)</code> – <code>Goal</code> should be a ground callable term. This option is used when opening an input stream. <code>Goal</code> will be run each time a new buffer is read. This option is most useful when used in conjunction with opening an output stream where a prompt should be written to whenever new input is required from the input stream.</p>
<p><code>maxdepth(Depth)</code> – <code>Depth</code> is a positive integer. This option when specified for an output stream sets the default maximum depth used to write out a term with <code>write_term/3</code>, et. al. Explicit options to <code>write_term/3</code> may be used to override this option.</p>
<p><code>depth_computation(DC)</code> – <code>DC</code> should be either <code>flat</code> or <code>nonflat</code>. This option indicates the default mechanism to be used for <code>write_term/3</code> to compute the depth of a term. <code>flat</code> indicates that all arguments in a list or structured term should be considered to be at the same depth. <code>nonflat</code> indicates that each successive element of a structured term or list is at depth one greater than its predecessor.</p>
<p><code>line_length(Length)</code> – <code>Length</code> is a positive integer. This option is used to set the default line length associated with the (output) stream. Predicates which deal with term output use this parameter to break the line at appropriate points when outputting a term which will span several lines. Explicit options to <code>write_term/3</code> may be used to override this option.</p>
<p><code>write_eoln_type(Type)</code> - allows control over which end-of-line(eoln) characters are output by <code>nl/1</code>. The values for <code>Type</code> and the corresponding eoln characters are: <code>cr(&quot;\r&quot;)</code>, <code>lf(&quot;\n&quot;)</code>, and <code>crlf(&quot;\r\n&quot;)</code>. The default is determined by the operating system : MacOSX(lf), Unix(lf), and Win32/DOS(crlf).</p>
<p><code>read_eoln_type(Type)</code> - determines what <code>read/2</code> and <code>get_line/3</code> recognize as an <code>end-of-line</code>. The values for <code>Type</code> and the corresponding <code>ends-of-line</code> are: <code>cr</code> - carriage return(“”) <code>lf</code> - line feed(“”), <code>crlf</code> - carriage return followed by a line feed(“”), <code>universal</code> - indicates that any of the end-of-line types(<code>cr,lf,crlfl</code>) should be interpreted as an <code>end-of-line</code>. The default is <code>universal</code> since this allows the correct <code>end-of-line</code> interpretation for text files on all operating systems.</p>
<h2 id="examples">EXAMPLES</h2>
<p>Open a file named example.dat for write access, write a term to it and close it.</p>
<pre><code>?- open(&#39;example.dat&#39;,write,S), writeq(S, example(term)),
?-_ put_char(S,&#39;.&#39;), nl(S), close(S).

S = stream_descriptor(&#39;&#39;,closed,file,&#39;example.dat&#39;, [noinput|output], true,
2,0,0,0,0,true,0, wt_opts(78,40000,flat),[],true,text,eof_code,0,0)

yes.</code></pre>
<p>Open a file named example.dat for read access with alias example.</p>
<pre><code>?- open(&#39;example.dat&#39;,read,_,[alias(example)]).

yes.</code></pre>
<p>Read a term from stream with alias example.</p>
<pre><code>?- read(example,T).

T = example(term)

yes.</code></pre>
<p>Read another term from with stream with alias example.</p>
<pre><code>?- read(example,T).

T = end_of_file

yes.</code></pre>
<p>Close the stream aliased example.</p>
<pre><code>?- close(example).

yes.</code></pre>
<h2 id="errors">ERRORS</h2>
<p><code>Name</code>, <code>Mode</code>, or <code>Options</code> is a variable</p>
<p>– – – – &gt; instantiation_error.</p>
<p><code>Name</code> does not refer to either a variable or a source/sink</p>
<p>– – – – &gt; domain_error(source_sink, Name) .</p>
<p><code>Mode</code> is neither a variable nor an atom</p>
<p>– – – – &gt; type_error(atom, Mode) .</p>
<p><code>Mode</code> is an atom, but not a valid I/O mode for the given source/sink</p>
<p>– – – – &gt; domain_error(io_mode, Mode) .</p>
<p><code>Stream</code> is not a variable</p>
<p>– – – – &gt; type_error(variable, Stream) .</p>
<p><code>Options</code> is neither a variable nor a list</p>
<p>– – – – &gt; type_error(list, Options) .</p>
<p><code>Options</code> is a list with a variable element</p>
<p>– – – – &gt; instantiation_error.</p>
<p><code>Options</code> is a list with element E which is not a valid stream option</p>
<p>– – – – &gt; domain_error(stream_option, E) .</p>
<p><code>Name</code> specifies a valid source/sink, but can not be opened. If <code>Name</code> refers to a file, the file may not exist or the protection on the file or containing directory might be set to be incompatible with the open mode</p>
<p>– – – – &gt; permission_error(open, source_sink, Name) .</p>
<p><code>Options</code> contains an element <code>alias(A)</code> and <code>A</code> is already associated with another stream</p>
<p>– – – – &gt; permission_error(open, source_sink, alias(A)) .</p>
<p><code>Options</code> contains an element <code>reposition(true)</code> and it is not possible to reposition a stream corresponding to the source/sink <code>Name</code>.</p>
<p>– – – – &gt; permission_error(open, source_sink, reposition(true)) .</p>
<h2 id="notes">NOTES</h2>
<p>The structured term comprising a stream descriptor is visible to the programmer. The programmer should not directly use the stream descriptor to learn of properties or attributes associated with the stream or otherwise rely on the representation of stream descriptors. Use <code>stream_property/2</code> to examine the properties associated with a stream.</p>
<p>The DEC-10 compatibility predicates <code>see/1</code> and <code>tell/1</code> are defined in terms of <code>open/4</code>. When a stream is opened with either of these predicates it is assigned an alias which is the name of the source/sink. Thus the single argument to <code>see/1</code> and <code>tell/1</code> may be considered to be both the name of the stream and an alias for the stream.</p>
<h2 id="see-also">SEE ALSO</h2>
<ul>
<li><p><code>close/1</code><br />
<code>current_input/1</code><br />
<code>current_output/1</code><br />
<code>flush_input/1</code><br />
<code>flush_output/1</code><br />
<code>stream_property/2</code><br />
<code>curl/[1,3]</code><br />
<code>http/3</code><br />
<code>read_term/3</code><br />
<code>write_term/3</code><br />
<code>get_char/1</code><br />
<code>put_char/1</code><br />
<code>set_stream_position/2</code></p></li>
<li><p>`User Guide (Prolog I/O)</p></li>
</ul>
</body>
</html>
