<h2 id="forms">FORMS</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:- defineClass(SpecEqns) .
</code></pre></div></div>
<h2 id="description">DESCRIPTION</h2>

<p>Used as a directive to specify an ObjectPro class. <code class="highlighter-rouge">SpecEqns is</code> a list of equations of the form</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     Keyword = Value

</code></pre></div></div>
<p>The acceptable keywords, together with their associated <code class="highlighter-rouge">Value</code> types, are the following :</p>

<p><strong><code class="highlighter-rouge">name</code></strong> - atom</p>

<p><strong><code class="highlighter-rouge">subclassOf</code></strong> - atom <em>(name of an existing class to serve as parent)</em></p>

<p><strong><code class="highlighter-rouge">addl_slots</code></strong> - list of atoms <em>(to serve as names of local slots)</em></p>

<p><strong><code class="highlighter-rouge">defaults</code></strong> - list of default values for slots</p>

<p><strong><code class="highlighter-rouge">constrs</code></strong> - list of constraint expressions for slots</p>

<p><strong><code class="highlighter-rouge">export</code></strong> - yes <strong><em>[or]</em></strong> no</p>

<p><strong><code class="highlighter-rouge">action</code></strong> - atom</p>

<p>The <em>name equation</em> and the <em>subclassOf equation</em> are both required. The single top-level pre-defined class is called <strong><code class="highlighter-rouge">genericObjects</code></strong>. Atoms on the <em>addl_slots list</em> specify slots in the structure defining the state of objects which are instances of this class. These slot names must be distinct from slot names in any of the ancestor classes from which the new class inherits. The <strong>__state-schema__</strong> of a class is the union of the local <em>addl_slots</em> of the class with the <em>addl_slots</em> of all classes of which the class is a subclass. An object which is instance of a class has a slot in its state structure corresponding to each entry in the state-schema for the class.</p>

<p>Class definitions can supply default values for slots using an equation of the type</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defaults = [..., &lt;SlotName&gt; = &lt;Value&gt;, ...]
</code></pre></div></div>
<p>where each &lt;<code class="highlighter-rouge">SlotName</code>&gt; is any one of the slotnames from the complete state schema of the class, and &lt;<code class="highlighter-rouge">Value</code>&gt; is any appropriate value for that slot. Omitting this keyword in a class definition is equivalent to including</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defaults = []
</code></pre></div></div>
<p>If the <em><code class="highlighter-rouge">export = yes</code></em> equation appears on <code class="highlighter-rouge">SpecEqns</code>, the class methods and other information concerning the class are exported from the module in which the directive is executed.</p>

<p>The <em>constraints equation</em> is used to impose constraints on the values of particular slots in the states of objects which instances of the class. The general form of a constraint specification is</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    constrs = list of constraint expressions
</code></pre></div></div>
<p>Three types of constraint expressions are supported:</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">slotName = value</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">slotName &lt; valueList</code></p>
  </li>
  <li>
    <p><code class="highlighter-rouge">slotName - Var^Condition</code></p>
  </li>
</ul>

<p>The left side of each of the the equations is the name of a slot occurring in the complete state-schema of the class being defined.  The first two types of expressions are special cases of the third.</p>

<p>In the first constraint expression, <code class="highlighter-rouge">slotName = value</code>, <code class="highlighter-rouge">value</code> is any Prolog term, and specifies a fixed value for this slot.</p>

<p>The second constraint expression, <code class="highlighter-rouge">slotName &lt; valueList</code>, requires the values installed under <code class="highlighter-rouge">slotName</code> to be among the Prolog terms appearing on the list <code class="highlighter-rouge">valueList</code>. Here <code class="highlighter-rouge">'&lt;'</code> is a short hand for ‘is an element of’.</p>

<p>The third constraint expression subsumes the first two. <code class="highlighter-rouge">Var</code> is a Prolog variable, and <code class="highlighter-rouge">Condition</code> is an arbitrary Prolog call in which <code class="highlighter-rouge">Var</code> occurs. The test is imposed by binding the incoming candidate value to the variable <code class="highlighter-rouge">Var</code>, and then calling the test <code class="highlighter-rouge">Conditon</code>. Installation of the incoming value in the slot named <code class="highlighter-rouge">slotName</code> takes place only if the test <code class="highlighter-rouge">Condition</code> succeeds.</p>

<p>If an equation <code class="highlighter-rouge">action = Name</code> occurs on <code class="highlighter-rouge">SpecEqns</code>, where <code class="highlighter-rouge">Name</code> is an atom, then methods of this class must be implemented by a binary predicate <code class="highlighter-rouge">Name/2</code>. If this equation is absent, the methods predicate for this class will be</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;className&gt;Action/2, 
</code></pre></div></div>
<p>where <code class="highlighter-rouge">&lt;className&gt;</code> is the name of the class(i.e., <code class="highlighter-rouge">name = &lt;className&gt;</code> occurs on <code class="highlighter-rouge">SpecEqns</code>). The format of the calls to this predicate is</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    &lt;className&gt; Action(Message, State)
</code></pre></div></div>
<p>where <code class="highlighter-rouge">State</code> is the state of an object of this class, and  <code class="highlighter-rouge">Message</code> is an arbitrary Prolog term.</p>

<p>The structure of a State is opaque. Access to the slots is provided by two predicates:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>setObjStruct(SlotDescrip, State, Value)

accessObjStruct(SlotDescrip, State, VarOrValue)
</code></pre></div></div>
<p><code class="highlighter-rouge">SlotDescrip</code> is a slot description, which is either a slot name, or an expression of the form</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     SlotName^SlotDescrip
</code></pre></div></div>
<p>The latter is used in cases of compound objects in which the value installed in a slot may be the state of another object. Thus,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     &lt;what&gt;ObjStruct(Slot1^Slot2, State, Value)
</code></pre></div></div>
<p>is equivalent to</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     accessObjStruct(Slot1, State, Obj1),
     &lt;what&gt;ObjStruct(Slot2, Obj1, Value)
</code></pre></div></div>
<p>The call</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    setObjStruct(SlotName, State, Value)
</code></pre></div></div>
<p>destructively updates the slot <code class="highlighter-rouge">SlotName</code> of <code class="highlighter-rouge">State</code> to contain <code class="highlighter-rouge">Value</code>, provided that:</p>

<ul>
  <li><code class="highlighter-rouge">Value</code> is not an uninstantiated variable, and</li>
  <li>any constraints imposed on this slot by the class are satisfied by the incoming <code class="highlighter-rouge">Value</code>.</li>
</ul>

<p>However, note that <code class="highlighter-rouge">Value</code> can be a term containing uninstantiated variables.</p>

<p>The second call</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    accessObjStruct(SlotName, State, ValueOrValue)
</code></pre></div></div>
<p>accesses the slot <code class="highlighter-rouge">SlotName</code> of <code class="highlighter-rouge">State</code> and unifies the value obtained with <code class="highlighter-rouge">VarOrValue</code>. For compactness, the following syntactic sugar is provided:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     State^SlotDescrip := Value
</code></pre></div></div>
<p>for</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     setObjStruct(SlotDescrip, State, Value)
</code></pre></div></div>
<p>and</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     VarOrValue := State^SlotDescrip
</code></pre></div></div>
<p>for</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     accessObjStruct(SlotDescrip, State, VarOrValue)
</code></pre></div></div>
<p>The bodies of clauses defining the action predicate of a class can contain calls on <code class="highlighter-rouge">accessObjStruct/3, setObjStruct/3, :=, send/2, send_self/2</code>, and any other built-in or program-defined Prolog predicate.</p>

<h2 id="examples">EXAMPLES</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:- defineClass(
     [ name = stacker,
       subclassOf = [genericObjects],
       addl_slots = [theStack, depth]
     ] ).

stackerAction(push(Item), State)
     :-
     accessObjStruct(theStack, State, CurStack),
     setObjStruct(theStack, State, [Item | CurStack ]),
     accessObjStruct(depth, State, CurDepth),
     NewDepth is CurDepth + 1,
     setObjStruct(depth, State, NewDepth).

stackerAction(pop(Item), State)
     :-
     accessObjStruct(theStack, State, [Item | RestStack ]),
     setObjStruct(theStack, State, RestStack),
     accessObjStruct(depth, State, CurDepth),
     NewDepth is CurDepth - 1,
     setObjStruct(depth, State, NewDepth).

stackerAction(cur_stack(Stack), State)
     :-
     accessObjStruct(theStack, State, Stack).

stackerAction(cur_depth(Depth), State)
     :-
     accessObjStruct(depth, State, Depth).

...create_object([name=stack, instanceOf=stacker, values=[theStack=[], depth=0] ], Obj),...
</code></pre></div></div>
