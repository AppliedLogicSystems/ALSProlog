<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>make_hash_table/1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">make_hash_table/1</h1>
</header>
<p><code>make_hash_table/1</code> — create a hash table and access predicates</p>
<h2 id="forms">FORMS</h2>
<pre><code>make_hash_table(Name)</code></pre>
<h2 id="description">DESCRIPTION</h2>
<p><strong><code>make_hash_table/1</code></strong> will create a hash table and a set of access methods with the atom <code>Name</code> as the suffix. Suppose for the sake of the following discussion that <code>Name</code> is bound to the atom <code>'_table'</code>. Then the access predicates created will be as follows:</p>
<p><strong><code>reset_table</code></strong> – throw away the old hash table associated with the <code>'_table'</code> hash table and create a brand new one.</p>
<p><strong><code>set_table(Key, Value)</code></strong> – associate ‘Key’ with ‘Value’ in the hash table. <code>Key</code> should be bound to a ground term. Any former associations that <code>Key</code> had in the hash table are replaced.</p>
<p><strong><code>get_table(Key, Value)</code></strong> – get the value associated with the ground term bound to <code>Key</code> and unify it with <code>Value</code>.</p>
<p><strong><code>del_table(Key, Value)</code></strong> – delete the <code>Key/Value</code> association from the hash table. <code>Key</code> must be bound to a ground term. `Value. will be unified against the associated value in the table. If the unification is not successful, the table will not be modified.</p>
<p><strong><code>pget_table(KeyPattern, ValPattern)</code></strong> – The “<code>p</code>” in <code>pget</code> and <code>pdel</code>, below, stands for pattern. <code>pget_table</code> permits <code>KeyPattern</code> and <code>ValPattern</code> to have any desired instantiation. It will backtrack through the table and locate associations matching the “<code>pattern</code>” as specified by <code>KeyPattern</code> and <code>ValPattern</code>.</p>
<p><strong><code>pdel_table(KeyPattern, ValPattern)</code></strong> – This functions the same as <code>pget_table</code> except that the association is deleted from the table once it is retrieved.</p>
<h2 id="examples">EXAMPLES</h2>
<pre><code>?- make_hash_table(&#39;_assoc&#39;).

yes.

?- set_assoc(a,f(1)).

yes.

?- set_assoc(b,f(2)).

yes.

?- set_assoc(c,f(3)).

yes.

?- get_assoc(X,Y).

no.

?- get_assoc(c,Y).

Y=f(3)

yes.

?- pget_assoc(X,Y).

X=c
Y=f(3);

X=b
Y=f(2);

X=a
Y=f(1);

no.

?- del_assoc(b,Y).

Y=f(2)

yes.

?- pdel_assoc(X,f(3)).

X=c

yes.

?- pget_assoc(X,Y).

X=a
Y=f(1);

no.

?- reset_assoc.

yes.

?- pget_assoc(X,Y).

no.</code></pre>
<h2 id="notes">NOTES</h2>
<p>Unlike <code>assert</code> and <code>retract</code>, the methods created by <code>make_hash_table/1</code> do not access the database. The associations between keys and values is stored on the heap. Thus elements of either keys or values may be modified in a destructive fashion. This will probably not have desirable consequences if a key is modified.</p>
<p>These predicates have an advantage over <code>assert</code> and <code>retract</code> in that no copies are made. In fact structure may be shared between hash table entries.</p>
<p>See the discussion in <code>make_gv/1</code> concerning global variable modification and backtracking.</p>
<h2 id="see-also">SEE ALSO</h2>
<ul>
<li>`make_gv/1</li>
</ul>
</body>
</html>
