<HTML>
<HEAD>
<TITLE>copy_term/1</TITLE>
</HEAD><BODY>
<A NAME="cc02ac65"></A>copy_term/1
<P></P>
<A NAME="82df5653"></A><A NAME="84bfde73"></A>copy_term/1 –  make copy of a term
<P></P>
<A NAME="84bfde74"></A><B>FORMS
<P></P>
<A NAME="84bfdea2"></A></B>copy_term(Term) <A NAME="84bfde75"></A><A NAME="84bfde75"></A>   <A NAME="84bfde76"></A><A NAME="84bfde76"></A> 
<P></P>
<A NAME="84bfde99"></A><B>DESCRIPTION
<P></P>
<A NAME="84bfde9a"></A></B>copy_term/1 will copy the term Term and unify this copy with Copy. Unbound variables in Term and Copy will not be shared between the two terms.
<P></P>
<A NAME="84bfde9b"></A><B>EXAMPLES  
<P></P>
<A NAME="84bfde9c"></A></B>?- copy_term(f(X,g(Y,X)), Z).
<P></P>
<A NAME="84bfde9d"></A>
<P></P>
<A NAME="84bfde9e"></A>X = X
<P></P>
<A NAME="84bfde9f"></A>Y = Y
<P></P>
<A NAME="84bfdea0"></A>Z = f(_A,g(_B,_A))
<P></P>
<A NAME="84bfdea1"></A>
<P></P>
<A NAME="84bfdecd"></A>yes.
<P></P>
<A NAME="84bfdec4"></A><B>NOTES
<P></P>
<A NAME="84bfdec5"></A></B>copy_term/1 is useful in situations involving destructive assignment.  It is useful not
only for the obvious situation of making a copy which is then destructively
modified, but also for avoiding certain problems regarding structures becoming
uninstantiated upon backtracking when using access predicates created with either make_gv/1 or make_hashtable/1.  See make_gv/1 for further discussion.
<P></P>
<A NAME="84bfdec6"></A><B>SEE ALSO  
<P></P>
<A NAME="84bfdec7"></A></B>make_gv/1, make_hash_table/1, mangle/3.
<P></P>
</BODY>
</HTML>