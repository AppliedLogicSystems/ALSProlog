<HTML>
<HEAD>
<TITLE>forcePrologInterrupt/0</TITLE>
</HEAD><BODY>
<A NAME="7b647001"></A><B>forcePrologInterrupt/0
<P></P>
<A NAME="44071208"></A><A NAME="4227ce1e"></A></B>forcePrologInterrupt/0 | - force interrupt on next call
<P></P>
<A NAME="44071209"></A><A NAME="423189ec"></A>callWithDelayedInterrupt/1 | -  call goal, setting delayed interrupt
<P></P>
<A NAME="4407120a"></A>callWithDelayedInterrupt/2 | -  call goal, setting delayed interrupt 
<P></P>
<A NAME="4407120b"></A><B>FORMS
<P></P>
<A NAME="4407120c"></A></B>forcePrologInterrupt 
<P></P>
<A NAME="44071238"></A>callWithDelayedInterrupt(Call) 
<P></P>
<A NAME="44071232"></A>callWithDelayedInterrupt(Module,Call) <A NAME="4407122f"></A><A NAME="4407122f"></A> <A NAME="44071230"></A><A NAME="44071230"></A> <A NAME="44071231"></A><A NAME="44071231"></A> 
<P></P>
<A NAME="44071233"></A><B>DESCRIPTION  
<P></P>
<A NAME="44071234"></A></B>forcePrologInterrupt forces an interrupt on the next call by setting the heap safety margin to a
sufficiently large number which is guaranteed to be larger than the actual heap
margin. 
<P></P>
<A NAME="44071235"></A>callWithDelayedInterrupt(Call)acts like call/1, invoking Call.  However, it arranges the system so that an interrupt will take place on the
first call occurring after the invocation of Call. 
<P></P>
<A NAME="44071236"></A>callWithDelayedInterrupt(Module,Call) 
<P></P>
<A NAME="44071237"></A>acts like  
<P></P>
<A NAME="44071263"></A> callWithDelayedInterrupt/1, except that it invokes Call within module Module.  
<P></P>
<A NAME="4407125a"></A><B>SEE ALSO
<P></P>
<A NAME="4407125b"></A></B>setPrologInterrupt/1, getPrologInterrupt/1, <I>User Guide (Prolog Interrupts).
<P></P>
</I></BODY>
</HTML>
