/*================================================================*
|		ra_basis.pro
 |	Copyright (c) 1995-96 Applied Logic Systems, Inc.
 |	Copyright (c) 1995 Bell-Northern Research Ltd.
 |
 |	Builtin predicates for implementing the upper levels
 |	of the interval constraint subsystem in ALS Prolog
 |
 |	Original Author: William J. Older
 |	Original Creation Date: 08/27/92
 |      Relational Interval Arithmetic Subsystem of BNR Prolog V4.x
 |
 |  Revisions/Modifications: Ken Bowen
 |  Date begun: 05/10/95
 |
 | 		Integration into ALS Prolog
 |
 |  Formatting note: Tabstops =4
 *================================================================*/

module rel_arith.

/*------------------------------------------------------------------------*
 |  clp/1
 |  clp(Goals)
 |  clp(+)
 | 
 |	Top-level recursive interpreter/driver; 
 |		Note: "show" clauses will be suppressed 
 |			  when development is complete [:-)].
 |
 |	clp(...) is normally generated by the reader as a replacement for {...}
 |	as a macro [this is done by xbrace/6 in xconsult.pro]
 *------------------------------------------------------------------------*/
:- module_closure('{}',1,clp0).
:- module_closure(clp,1,clp0).


clp0(M, X)
	:-
	clp(X, M).

/*--------------------------------------------------------*
 |	clp/2
 |	clp(G, M)
 |	clp(+, +)
 |
 |	- drives the recursion through G:
 |
 |	G = clp goal to be run
 |	M = module
 *--------------------------------------------------------*/

clp( (L, Ls), M)
	:-!,
	clp_eval(L, M),
	clp( Ls, M).

clp(G, M)
	:- 
	clp_eval(G, M).

/*--------------------------------------------------------*
 |	clp_eval( Expr, M )
 |	clp_eval( Expr, M )
 |	clp_eval( Expr, M )
 |
 |	- drives clp evaluation of individual goals
 |
 |	G = goal to run
 |	M = module
 |
 |	Attempts to first run Expr as a CLP relation; if
 |	this fails, calls Expr as a Prolog goal in module M
 *--------------------------------------------------------*/
				%%%
				%%% For debugging:
				%%%
				clp_eval( show(VName, Var), M )
					:-!,
					show_variable(VName, Var).
				
clp_eval( Expr, M )
	:-
	Expr =.. [R, X, Y],
	clp_arithmetic_relation(R),
	!,
	ria_relation(R, X, Y).

clp_eval( F, M )
	:-
	call(M:F).  % escape to Prolog

clp_arithmetic_relation( is ).
clp_arithmetic_relation( == ).
clp_arithmetic_relation( =< ).
clp_arithmetic_relation( >= ).
clp_arithmetic_relation( <> ).
clp_arithmetic_relation( >  ).
clp_arithmetic_relation( <  ).
clp_arithmetic_relation( sub ).
/*	--- need to fix parser for these:
clp_arithmetic_relation( '|=' ).
clp_arithmetic_relation( '=|' ).
*/
clp_arithmetic_relation( 'i=' ).
clp_arithmetic_relation( '=i' ).

/*---------------------------------------------------------------
 |			SYMBOLIC CONSTANTS
 |	At the moment, adding additional requires adding a new token
 |	to the system.  Say you want to add constant "gg", whose value
 |	is (for descriptive purposes), defined by the #define M_GG ....
 |	Then here, you add:
 |
 |	symbolic_constant(gg, 		cnst_gg).
 |
 |	Then in ~/generic/tokini.h, in the group at the end, add:
 |
 |		TK(TK_GG,  "cnst_gg"),
 |	
 |	Then, in ~/generic/intaux.c, in the function
 |
 |		extract_bds(DelVar, DelVar_t, LB, UB, IKind)
 |
 |	in the case 
 |
 |		else if (DelVar_t == WTP_SYMBOL)
 |
 |	add a case to the switch statement:
 |
 |		 case TK_GG  :   t = M_GG;
 |						 break;
 *--------------------------------------------------------------*/

symbolic_constant(-C, 		-S)
	:-!, symbolic_constant(C, 		S).
symbolic_constant(pi, 		pi).
symbolic_constant(pi_2,		cnst_pi_2).
symbolic_constant(X/2,		cnst_pi_2)
	:-
	nonvar(X), X=pi.
symbolic_constant(e,		e ).
symbolic_constant(X/4,		cnst_pi_4)
	:-
	nonvar(X), X=pi.
symbolic_constant(1/X,		cnst_1_pi)
	:-
	nonvar(X), X=pi.
symbolic_constant(2/X,		cnst_2_pi)
	:-
	nonvar(X), X=pi.
symbolic_constant(2*sqrt(X),	cnst_2sqrtpi)
	:-
	nonvar(X), X=pi.
symbolic_constant(log2(X),	cnst_log2e)
	:-
	nonvar(X), X=e.
symbolic_constant(log10(X),	cnst_log10e)
	:-
	nonvar(X), X=e.
symbolic_constant(ln(X),	cnst_ln2)
	:-
	nonvar(X), X=2.
symbolic_constant(ln(X),	cnst_ln10)
	:-
	nonvar(X), X=10.
symbolic_constant(sqrt(X),	cnst_sqrt2)
	:-
	nonvar(X), X=2.
symbolic_constant(sqrt(1/X),	cnst_sqrt1_2)
	:-
	nonvar(X), X=2.
	
is_symbolic_constant(pi).
is_symbolic_constant(cnst_pi_2).
is_symbolic_constant(cnst_pi_2).
is_symbolic_constant(e ).
is_symbolic_constant(cnst_pi_4).
is_symbolic_constant(cnst_2_pi).
is_symbolic_constant(cnst_2sqrtpi).
is_symbolic_constant(cnst_log2e).
is_symbolic_constant(cnst_log10e).
is_symbolic_constant(cnst_ln2).
is_symbolic_constant(cnst_ln10).
is_symbolic_constant(cnst_sqrt2).
is_symbolic_constant(cnst_sqrt1_2).




	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%% Domain Declarations
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*---------------------------------------------------------------
 |	::/2
 |	Vars :: Type
 |	+ :: +
 |
 |  Parameters:
 |	Vars:  Either a single variable or number, or a list of such;
 |	Type:  A type descriptor, as given below;
 |
 |  If Vars is a list, recursively causes the single-entity behavior
 |	to apply to each element of the list;  
 |
 |  If Var is a single uninstatiated Prolog variable: 
 |	causes Var to be (frozen) to a binding to an interval of the correct type;
 |
 |  If the attempt to bind Var (above) fails (possibly after an
 |	unfreezing), calls domain/2 to test the domain X is "frozen" to;
 |
 |  If Var is not a variable, succeeds iff Var is point value of appropriate type.
 |
 |  Acceptable (user-level) type descriptors, where Min,Max are the 
 |	minimal/maximal values of the various types:
 |	
 |		real(L,U)
 |		real [= real(Min,Max)]
 |		integer(L,U)
 |		integer [= integer(Min,Max)]
 |		boolean(L,U)
 |		boolean [= boolean(0,1)]
 *--------------------------------------------------------------*/

export (::)/2.

	%% X is a variable; freeze it to a domain:
X :: Type 
	:- 
	var(X), 
	!,
	declare_variable(Type,X).

	%% Process lists of declarations:
[] :: _  :-!.

[X | Xs] :: Type
	:-!, 
	X  :: Type,
	Xs :: Type.

	%%-----------------------------------------
	%% X is neither a list, nor a variable;
	%% so, check that it is an entity of
	%% the correct type:
	%%-----------------------------------------

X :: Type
	:-
	check_type_match(Type, X).

check_type_match(real(L,U), X)
	:-
	float(X),
%	(var(L) -> true ; L =< X), 
%	(var(U) -> true ; X =< U).
	(var(L) -> L=X ; L =< X), 
	(var(U) -> U=X ; X =< U).

check_type_match(real, X)
	:-
	float(X).

check_type_match(integer(L,U), X)
	:-
	integer(X),
/*
%	(var(L) -> true ; L =< X), 
%	(var(U) -> true ; X =< U).
	(var(L) -> L=X ; L =< X), 
	(var(U) -> U=X ; X =< U).
*/
	new_type_interval(integer(L,U),Y),
	add_relation(==, X, Y).

check_type_match(integer, X)
	:-
	integer(X).

check_type_match(boolean(L,U), 0)
	:-
	(var(L) -> L=0 ; L =< 0), 
	(var(U) -> U=0 ; 0 =< U).
check_type_match(boolean(L,U), 1)
	:-
	(var(L) -> L=1 ; L =< 1), 
	(var(U) -> U=1 ; 0 =< 1).
check_type_match(boolean, 0).
check_type_match(boolean, 1).

is_type(0, boolean) :-!.
is_type(1, boolean) :-!.
is_type(X, real)
	:-
	float(X),
	!.
is_type(X, integer)
	:-
	integer(X),
	!.

/*---------------------------------------------------------------
 |	declare_variable/2
 |	declare_variable(Type,X)
 |	declare_variable(+,+)
 |
 |  A.  If X is an uninstatiated Prolog variable which is already
 |		frozen to some delayed goal, creates a new interval
 |		variable XX of type Type, and equates X = XX;
 |  B.  If X is an uninstatiated Prolog variable which is not a
 |		frozen delay variable, freezes X to an interval domain
 |		structure of type Type.
 |  C.  If X is an instatiated Prolog variable, tests that 
 |		X is frozen to an interval domain structure of type Type.
 *--------------------------------------------------------------*/

declare_variable(Type,X)
	:-
	var(X),
	'$is_delay_var'(X),
	!,
	restrict_interval(Type,X).

declare_variable(Type,X)
	:-
	var(X),
	!,
	new_type_interval(Type,X).

	%% nonvar(X):
declare_variable(Type,X)
	:-
	domain_check(Type, X).

/*----------------------------------------------------------*
 |	restrict_interval/2
 |	restrict_interval(RestType,X)
 |	restrict_interval(+,+)
 |
 |	X = an interval variable;
 |	RestType ("restriction type") = a type expression;
 |
 |	X is restricted to become an interval of type RestType,
 |	if this is meaningful.
 *----------------------------------------------------------*/
restrict_interval(RestType,X)
	:-
		%% '$domain'(X, XPrimType, LX, UX),
	'$domain_term'(X, DomainTerm),
	valid_domain(DomainTerm, XPrimType, LX, UX),
	restrict_interval(RestType, XPrimType, LX, UX, X, DomainTerm),
	!.

	%% Idempotent restriction is trivially ok, with no changes:

restrict_interval(Type,   Type,    _, _, _, _) :-!.

	%% If RestType is unbounded (RestType is an atom) and the restriction 
	%% is "outward" (RestType >= XPrimType), this is also trivially ok:
	%%  --- restrict_interval(RestType, XPrimType, LX, UX, X, DomainTerm),

restrict_interval(integer,boolean, _, _, _, _) :-!.
%restrict_interval(real,   boolean, _, _, _, _) :-!.
%restrict_interval(real,   integer, _, _, _, _) :-!.

	%% RestType is bounded (=.. [Type,L,U]); now the underlying
	%% primitive types of RestType and XPrimType must be identical;
	%% if they are, intersect & equate the intervals; 
	%% else raise an error: X=[XLB, XUB],  RT=[RL,RU]:

restrict_interval(RestType, XPrimType, XLB, XUB, X, DomainTerm)
	:-
	RestType =.. [XPrimType, RL, RU],
	(var(RL) -> 
		XLB = RL, NewL = XLB
		;
		RL =< XUB,
		max(XLB, RL, NewL)
	),
	(var(RU) ->
		XUB = RU, NewU = XUB
		;
		XLB =< RU,
		min(XUB, RU, NewU)
	),
	NewType =.. [XPrimType, NewL, NewU],
	new_type_interval(NewType,NewInterval),
	'$iterate'(equal(NewInterval, X)).

/*---NEED SOME SORT OF ERROR EXCEPTION ----
	%% Error: Improper type restriction
restrict_interval(RestType, XPrimType, XLB, XUB, X, DomainTerm)
	:-
 -------------------------------------------*/

restrict_interval(Type,X)
	:-
	new_type_interval(Type,XX),
	!,
	'$iterate'(equal(X,XX)).


export lower_bound/1.
lower_bound(X)
	:-
	X :: real(L,U),
	{X =< L}.

export upper_bound/1.
upper_bound(X)
	:-
	X :: real(L,U),
	{U =< X}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%           RIA Relations         %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*---------------------------------------------------------------
 |  ria_relation/3
 |  ria_relation(RelationName, Left, Right)
 |  ria_relation(+, +, +)
 | 
 |  Handles instances constraint arithmetic relations which
 |	must be added into the constraint network;
 |
 |  RelationName is the name of a clp relation 
 |  		(see clp_arithmetic_relation/1);
 |
 |  Left, Right are expressions which are the left and right
 |  arguments of the relational statement being processed;
 |	Note that the process of flattening the arguments to the
 |	relation will add network nodes corresponding to any
 |	functions/operations occurring in the arg expressions.
 *--------------------------------------------------------------*/
		%% Cases 1,2:
		%% Left is a variable, and the original relation expression
		%% is of one of the forms:
		%%		Left is Expr or Left == Expr
		%%
ria_relation(is, Left, Right)
	:- 
	ria_relation_is(Left, Right).

ria_relation(==, Left, Right)
	:- 
	var(Left),
	!, 
	define_interval(==, Left, Right).  

		%% All other cases:
ria_relation(Operator, Left, Right)
	:-
	flatten_expr(Left,  LeftExpr,  LeftType),
	flatten_expr(Right, RightExpr, RightType),
	relation_type_match(Operator,  LeftType, RightType),
	!,
	add_relation(Operator, LeftExpr, RightExpr).

is_defining_rel( is ).
is_defining_rel( == ).

/*
ria_relation_is(Left, Right)
	:-
	var(Left),
	!,
	flatten_expr(Right, RightExpr, RightType),
	(number(Left) ->
		true
		;
		declare_variable(Type,Left)
	).
*/

ria_relation_is(Left, Right)
	:-
	ria_relation(==, Left, Right).

/*---------------------------------------------------------------
 |	define_interval/3
 |	define_interval(Operator, Y, Expr)
 |	define_interval(+, +, +)
 *--------------------------------------------------------------*/
define_interval(is, Y, Expr)
	:-!,
	flatten_expr(Expr, Y, Type),
	declare_variable(Type,Y).

define_interval(==, Y, Expr)
	:-
	flatten_expr(Expr, YE, Type),
	declare_variable(Type,Y),
	add_relation(==, Y, YE).

relation_type_match( <> , T1, T2)
	:-!,
	discrete_type(T1),
	discrete_type(T2).
relation_type_match(_, _, _).

discrete_type(boolean).
discrete_type(integer).

/*---------------------------------------------------------------
 |	add_relation/3
 |	add_relation(Relation, Left, Right)
 |	add_relation(+, +, +)
 | 
 |  Adds a relation instance into the network; checks for 
 |  certain cases which can be eliminated.
 *--------------------------------------------------------------*/
	%% Arguments are identical, and relation is not <>
	%% (All other interval relations are reflexive?)
add_relation(Relation, Left, Right)
	:-
	Left == Right,		%% Identity in ISO Standard Prolog
	!,
	Relation \= ( <> ) .

	%% Both arguments are instantiated Prolog terms, so
	%% try to run the relation as an ordinary Prolog goal:
add_relation(Relation, Left, Right)
	:-
	nonvar(Left),
	nonvar(Right),
	!,
	Goal =.. [Relation, Left, Right],
	Goal.

	%% Otherwise, try to add the relation node into the network:
add_relation(Relation, Left, Right)
	:-
	fmap_rel(Relation, Left, Right, Node),
	!,
	'$iterate'( Node).

/*-----------------------------------------------------------------
 |	flatten_expr/3
 |	flatten_expr(Expr, Value, Type)
 |	flatten_expr(+, -, -)
 |
 |  Performs various symplifications on Expr, to yield Value, and
 |  also computes the Type of Value
 |
 |	Inputs:
 |	Expr	= an arithmetic expression with either variables or numeric 
 |			  constants at leaves
 |	Outputs:
 |	Value	= the result of flattening Expr;
 |	Type	= the type of Value;
 *----------------------------------------------------------------*/

flatten_expr(V, V, Type)
	:-
	var(V),		%% has to be a constraint delay var; look up its type
	!,
	flatten_expr_var(V, Type).

flatten_expr_var(V, Type)
	:-
	'$domain'(V, Type, _, _),
	!.
	%% Strong "contagion" model:  if X is a variable (not already an
	%% interval) which occurs in an expression being passed to 
	%% flatten_expr/3, then X should be an interval variable; 
	%% first guess that it is real; later occurrences may restrict
	%% the type to boolean or integer:
flatten_expr_var(V, Type)
	:-
	var(Type),
	!,
	Type = real,
	new_type_interval(real,V).

flatten_expr(C, Val, real) 
	:-
	symbolic_constant(C,Val0),
	!,
	point_interval(Val0, Val).

flatten_expr(N, N1, Type)
	:-
	number(N),
	!,
	is_type(N, Type),
	point_interval(N, N1).

	%% Monadic expressions - special:
flatten_expr(Expr, Y, Type)
	:-
	Expr =.. [Function, X],
	flatten_expr1(Function, X, Y, Type),
	!.

	%% Monadic expressions - general:
flatten_expr(Expr, Res, Type)
	:-
	Expr =.. [Function, X],
	down_type1(Function, Tp, Type),
	flatten_expr(X, XE, Tp),
	type1(Function, Tp, Type),
	add_fcn_node(Function, [XE], Res, Type).

	%% Dyadic expressions - special:
flatten_expr(X**0, 1, integer)
	:-!,
	flatten_expr(X, _, _).

flatten_expr(X**1, Res, Type)
	:-!,
	flatten_expr(X, Res, Type).

flatten_expr(X**N, Res, Type)
	:-!,
	N1 is N,
	integer(N1),
	!,
	finish_flatten_power(N1,X,N,Res,Type). 

finish_flatten_power(N1,X,N,Res,Type)
	:-
	N1 < 0,
	!,
	N2 is -N1,
	flatten_expr((1/X)**N2, Res, Type).

finish_flatten_power(N1,X,N,Res,Type)
	:-
	(nonvar(Type) -> type_of_power(N1, PreType, Type) ; true),
	flatten_expr(X, XE, PreType),
	type_of_power(N1, PreType, Type),
	odd_even_power_op(N, Opn),
	add_fcn_node(Opn, [XE, N1], Res, Type).

flatten_expr( X<>Y, Res, boolean)
	:-!,
	flatten_expr( '~'((X==Y)), Res, boolean).

flatten_expr( X<Y, Res, boolean)
	:-!,
	flatten_expr( '~'((X=>Y)), Res, boolean).

flatten_expr( X>Y, Res, boolean)
	:-!,
	flatten_expr( '~'((X=<Y)), Res, boolean).

flatten_expr( wrap(X,N), Res, real)
	:-!,
	number(N),
	N1 is N,
	flatten_expr(X, XE, real),
	add_fcn_node(wrap, [XE, N1], Res, real).
	
	%% Dyadic expressions - general:
flatten_expr(Expr, Res, Type)
	:-
	Expr =.. [Function, X, Y],
	Function \= wrap,
	Function \= '**',
	down_type2(Function, T1, T2, Type),
	flatten_expr(X, XE, T1),
	flatten_expr(Y, YE, T2),
	type2(Function, T1, T2, Type),
	normal_form(Function, [XE, YE], NF_Function, NF_Args),
	add_fcn_node(NF_Function, NF_Args, Res, Type).

odd_even_power_op(2, root) :-!. 
odd_even_power_op(N, qpow_even) 
	:-
	0 is N mod 2, !.

odd_even_power_op(N, pow_odd).

/*-----------------------------------------------------------------
 |	Flattening special monadic expressions
 *----------------------------------------------------------------*/

flatten_expr1( sin,     X,Y, real ) 
	:- 
	trigonometric(sin, X, Y, pi).

flatten_expr1( cos,     X,Y, real ) 
	:- 
	trigonometric(cos, X, Y, pi).

flatten_expr1( tan,     X,Y, real ) 
	:- 
	trigonometric(tan, X, Y, cnst_pi_half).

flatten_expr1( midpoint,X,Y, real) 
	:- 
	'$domain'(X, _, L, U),
	Y is (L + U)/2.0 .
flatten_expr1( delta,   X,Y, real) 
	:- 
	'$domain'(X, _, L, U),
	Y is (U - L) .
flatten_expr1( median,  X,Y, real) 
	:- 
	'$domain'(X, _, L, U),
	intv_median(L,U,Y).
flatten_expr1( float,   X,Y, real) 
	:- 
	number(X), 
	Y is float(X).
flatten_expr1( round,   X,Y, integer) 
	:- 
	ground(X),
	!, 
	Y is round(X).
flatten_expr1( round,   X,Y, integer) 
	:- 
	Y::integer, 
	Y - 0.5 =< X, 
	X =< Y + 0.5 .
flatten_expr1( floor,   X,Y, integer) 
	:- 
	number(X),
	!, 
	Y is floor(X).
flatten_expr1( floor,   X,Y, integer) 
	:- 
	Y::integer, 
	Y =< X, 
	X < Y + 1  .
flatten_expr1( ceiling, X,Y, integer) 
	:- 
	ground(X),
	!, 
	Y is ceiling(X).
flatten_expr1( ceiling, X,Y, integer) 
	:- 
	Y::integer, 
	Y - 1 < X, 
	X =< Y.

	/*--------------------------------------------------------------------*
	 |	Y==sin(X) --> Q==wrap(XE, pi),  Y==sin(Q)
	 |	Y==cos(X) --> Q==wrap(XE, pi),  Y==cos(Q)     
	 |									where flatten_expr(X,XE,real)
	 |	Y==tan(X) --> Q==wrap(XE, pi/2),Y==tan(Q)
	 *--------------------------------------------------------------------*/
trigonometric( F, X, Res, Period)
	:-
	flatten_expr( X, XE, real),
	add_fcn_node( wrap, [XE,Period], Y, real),
	add_fcn_node( F, [Y], Res, real).


/*-----------------------------------------------------------------
 |	Type Propagation & Inference
 *----------------------------------------------------------------*/

/*-----------------------------------------------------
 |	type_of_power/3
 |	type_of_power(N, InType, OutType)
 |	type_of_power(+, ?, ?)
 *----------------------------------------------------*/

type_of_power(N, integer, integer)
	:-
	N > 0.
type_of_power(N, _, real).

	/*-----------------------------------------------------
	 |	Upward type propagation: from arguments "upward to 
	 |	the type of the function result 
 	 *----------------------------------------------------*/

/*-----------------------------------------------------
 |	type1/3
 |	type1(Op, InType, OutType)
 |	type1(+, +, -)
 |
 |	upward type propagation for unary functions;
 *----------------------------------------------------*/

type1( '~',   boolean, boolean) :-!.
type1( -,   integer, integer) :-!.
type1( abs, integer, integer) :-!.
type1( floor,     _, integer) :-!.
type1( ceiling,   _, integer) :-!.
type1( Op,        _, real).

/*-----------------------------------------------------
 |	type2/4
 |	type2(Op, In1, In2, OutType)
 |	type2(+, ?, ?, ?)
 |		-- other modes??
 |
 |	upward type propagation for binary functions;
 *----------------------------------------------------*/

type2(or,   boolean, boolean, boolean).
type2(nor,  boolean, boolean, boolean).
type2(and,  boolean, boolean, boolean).
type2(nand, boolean, boolean, boolean).
type2(xor,  boolean, boolean, boolean).
type2( + ,  T1,  T2,     R) :- type2_real(T1, T2, R).
type2( - ,  T1,  T2,     R) :- type2_real(T1, T2, R).
type2( * ,  T1,  T2,     R) :- type2_real(T1, T2, R).
type2(min,  T1,  T2,     R) :- type2_real(T1, T2, R).
type2(max,  T1,  T2,     R) :- type2_real(T1, T2, R).
type2( ; ,  T1,  T2,     R) :- type2_real(T1, T2, R).
type2( == ,  _,  _,      boolean).
type2( >= ,  _,  _,      boolean).
type2( =< ,  _,  _,      boolean).
type2( / ,   _,  _,      real).    % division always produces real 
type2( // ,  _,  _,      integer). % int division always produces int 
type2(divf,  _,  T2,     R) :- type2_integer(T1, T2, R).
type2(divc,  _,  T2,     R) :- type2_integer(T1, T2, R).

type2_real(boolean, boolean, integer) :-!.
type2_real(boolean, integer, integer) :-!.
type2_real(integer, boolean, integer) :-!.
type2_real(integer, integer, integer) :-!.
type2_real(_,       _,       real).

type2_integer(boolean, boolean, integer).
type2_integer(boolean, integer, integer).
type2_integer(integer, boolean, integer).
type2_integer(integer, integer, integer).

	/*-----------------------------------------------------
	 |	Downward type propagation: from the type of the
	 |	output value of a given operation "downward" to
	 |	types for the arguments; Essentially these are
	 |	"reverse" versions of the predicates above.
 	 *----------------------------------------------------*/

/*-----------------------------------------------------
 |	down_type1/3
 |	down_type1( F, T1,  T)
 |	down_type1( +, -,  +)
 |
 |	- downward type propagation for unary functions;
 |
 |	Infers the type T1 of the argument to the unary 
 |	function F from the type of the output T of F
 *----------------------------------------------------*/
down_type1( '~', boolean, boolean):-!.
down_type1( F, T1,  T)
	:- 
	nonvar(T),
	!,
	type1(F,T1,T).  
down_type1( _, _, _).

/*-----------------------------------------------------
 |	down_type2/4
 |	down_type2( F, T1, T2, T)
 |	down_type2( +, -, -, +)
 |
 |	- downward type propagation for binary functions;
 |
 |	Infers the types T1,T2 of the arguments to the
 |	binary function F from the type of the output T of F
 *----------------------------------------------------*/
down_type2(and, boolean, boolean, boolean):-!.
down_type2(nand,boolean, boolean, boolean):-!.
down_type2(or,  boolean, boolean, boolean):-!.
down_type2(nor, boolean, boolean, boolean):-!.
down_type2(xor, boolean, boolean, boolean):-!.
down_type2( F, T1, T2, T)
	:- 
	nonvar(T),
	!,
	type2( F, T1, T2, T).
down_type2( _, _, _, _).

/************
combin_type(TypeList, real)
	:-
	dmember(real, TypeList), !.
combin_type(TypeList, integer)
	:-
	dmember(integer, TypeList), !.
combin_type(TypeList, boolean).
************/

/*-----------------------------------------------------------------
 |	NORMAL FORM
 *----------------------------------------------------------------*/

/*-----------------------------------------------------------------
 |	normal_form/4
 |	normal_form(Function, F_Args, NF_Function, NF_Args)
 |	normal_form(+, +, -, -)
 *----------------------------------------------------------------*/
normal_form( + , [X, Y], * , [X, 2])
	:-
	breadth_first_compare(X, Y, @= ), !.

normal_form( * , [X, Y], root , [X, 2])
	:-
	breadth_first_compare(X, Y, @= ), !.

normal_form( F , [X, Y], F , [Y, X])
	:-
	commutes(F),
	breadth_first_compare(X, Y, @> ), !.

normal_form( =<, [X, Y], >=, [Y, X]) :-!.

normal_form(F, F_Args, F, F_Args).

commutes( + ).
commutes( * ).
commutes( min ).
commutes( max ).
commutes( ; ).
commutes( or ).
commutes( nor ).
commutes( and ).
commutes( nand ).
commutes( == ).
commutes( <> ).
commutes( xor ).

/*-----------------------------------------------------------------
 |	add_fcn_node/4
 |	add_fcn_node(Function, F_Args, Res, Type)
 |	add_fcn_node(+, +, ?, ?)
 |
 |	- handles function nodes encountered in relation arguments
 |
 |	Strategy: 
 |	1. try to eliminate locally by symbolic rewriting (if enabled)
 |	2. try to locate previously computed expressions (if enabled)
 |	3. generate new node
 *----------------------------------------------------------------*/

	%% Try symbolic re-writing:
add_fcn_node(F, [X,Y], Res, Type)
	:-
	reduce(F, X, Y, Res),
	!.

:-dynamic(global_common_subexpressions_enabled/0).

	%% Look for common subexpr:
add_fcn_node(F, F_Args, Res, Type)
	:-
	global_common_subexpressions_enabled,
	find_existing_csx( F, F_Args, Res), 
	!. 

	%% Create new node:
add_fcn_node(F, F_Args, Res, Type)
	:-
	Res :: Type,
	eval_riax(F, F_Args, Res ).

/*-----------------------------------------------------------------
 |	reduce/4
 |	reduce(F, X, Y, Res)
 |	reduce(+, +, +, -)
 *----------------------------------------------------------------*/

:- dynamic(sym_eval/4).

reduce(F, X, Y, Res)
	:-
	number(X), number(Y),
	atom(F),
	!,
	sym_eval(F, X, Y, Z1),
	point_interval(Z1, Z).

reduce( -  , X, Y, 0) :- X @= Y.      % X - X = 0
reduce( +  , X, Z, X) :- Z @= 0.      % X + 0 = X
reduce( -  , X, Z, X) :- Z @= 0.      % X - 0 = X
reduce( /  , X, Y, 1) :- X @= Y.      % X / X = 1
reduce( // , X, Y, 1) :- X @= Y.      % X // X = 1
reduce( *  , Y, Z, 0) :- Z @= 0.      % Y *  0 = 0
reduce( *  , Y, U, Y) :- U @= 1.      % Y * 1 = Y
reduce( /  , Y, U, Y) :- U @= 1.      % Y / 1 = Y
reduce( // , Y, U, Y) :- U @= 1.      % Y // 1= Y
reduce( min, X, Y, X) :- X @= Y.      % min(X,X)=X
reduce( max, X, Y, X) :- X @= Y.      % max(X,X)=X
reduce( or , X, Z, 1) :- Z @= 1.      % X or 1 = 1
reduce( or , X, Z, X) :- Z @= 0.      % X or 0 = X
reduce( or , X, Y, X) :- X @= Y.      % X or X = X
reduce( and, X, Z, 0) :- Z @= 0.      % X and 0 = 0
reduce( and, X, Z, X) :- Z @= 1.      % X and 1 = X
reduce( and, X, Y, X) :- X @= Y.      % X and X = X
reduce( == , X, Y, B) :- eqop(X,Y,B).
reduce( xor, X, Y, B) :- neqop(X,Y,B).

X @= Y :- X == Y.

eqop(X,Y,1)  :- X@=Y,!.		% same const or same var
eqop(X,Y,0)  				% different constants
	:- 			
	number(X),
	number(Y).
neqop(X,Y,0) :- X@=Y,!.
neqop(X,Y,1) 
	:- 
	number(X),
	number(Y).

/*-----------------------------------------------------------------
 |	find_existing_csx/3
 |	find_existing_csx( F, F_Args, Res)
 |	find_existing_csx( +, +, -)
 |
 |	Searches for a node computing Oper in the interval constraint 
 |	network and returns the proper variable if found; else fails.
 |	(This predicate to be replaced largely by a primitive call.)
 *----------------------------------------------------------------*/

find_existing_csx( F, [X,Y], Z )
	:-
	ria_map2(F, X, Y, Z, G, N ),
	'$findCommonSubex'( G, N ).

find_existing_csx( F, [X], Z )
	:-
	ria_map1(F, X, Z, G, N ),
	!,
	'$findCommonSubex'( G, N ).

find_existing_csx( F, [X], Z )
	:-
	ria_map1r( F, X, Z, G, N, _ ),
	!,
	'$findCommonSubex'( G, N ).

/*-----------------------------------------------------------------
 |	EVALUATING RIA EXPRESSIONS:
 |
 |	Evaluate operations:
 |	- construct constraint network from list of primitive operations
 |	- periodic transcendental functions synthesized
 |	- find first fixed point (incrementally during construction)
 *----------------------------------------------------------------*/
/*-----------------------------------------------------------------
 |	eval_riax/3
 |	eval_riax( F, F_Args, Res )
 |	eval_riax( +, +, - )
 *----------------------------------------------------------------*/

	%% Unrestricted unary:
eval_riax(F, [X], Res )
	:-
	ria_map1(F, X, Res, Node, _ ),
	!,
	'$iterate'( Node).

	%% Unary with restricted range:
eval_riax(F, [X], Res )
	:-
	ria_map1r(F, X, Res, Node, _, Restrict ),
	!,
	call(Restrict),
	'$iterate'( Node).

	%% Unrestricted binary:
eval_riax(F, [X,Y], Res )
	:-
	ria_map2(F, X, Y, Res, Node, _ ),
	!,
	'$iterate'( Node).

/*
eval_riax(Rel, [X,Y], _ )
	:-
	fmap_rel(Rel, X, Y, Node),
	!,
	'$iterate'( Node).
*/

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%  Function Nodes  %%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%

ria_map1(  - , X, Z, add(0,X,Z),    1).
ria_map1( exp, X, Z, xp(Z,X),   1).
ria_map1( ln,  X, Z, xp(X,Z),   2).
ria_map1( abs, X, Z, vabs(Z,X), 1).
ria_map1( sq,  X, Z, root(Z,X), 1).    
ria_map1( sin, X, Z, sin(Z,X),  1).    
ria_map1( cos, X, Z, cos(Z,X),  1).    
ria_map1( tan, X, Z, tan(Z,X),  1).    
ria_map1(  '~' , X, Z, negation(Z, X),2).

ria_map1r(sqrt, X,     Z, root(X,Z),  2,  '$restrict'(Z,0,_) ).
ria_map1r(asin, X,     Z, sin(X,Z),   2,  '$restrict'(Z,-pi/2,pi/2) ).
ria_map1r(acos, X,     Z, cos(X,Z),   2,  '$restrict'(Z,0,pi) ).
ria_map1r(atan, X,     Z, tan(X,Z),   2,  '$restrict'(Z,-pi/2,pi/2) ).

/* ------- Binary Function Calls Format: -------*
	find_existing_csx( F, [X,Y], Z )
		:-
		ria_map2(F, X, Y, Z, G, N ),
 *----------------------------------------------*/
ria_map2( +  ,       X,Y, Z, add(Z,X,Y)  ,1).
ria_map2( *  ,       X,Y, Z, mul(Z,X,Y)  ,1).
ria_map2( min,       X,Y, Z, inf(Z,X,Y)  ,1).
ria_map2( max,       X,Y, Z, lub(Z,X,Y)  ,1).
ria_map2(  - ,       X,Y, Z, add(X,Y,Z)  ,3).
ria_map2(  / ,       X,Y, Z, mul(X,Y,Z)  ,3).
ria_map2( and,       X,Y, Z, conjunction(Z,X,Y) ,1).
ria_map2( or,        X,Y, Z, disjunction(Z,X,Y) ,1).
ria_map2( nand,      X,Y, Z, anynot(Z,X,Y) , 1).
ria_map2( nor,       X,Y, Z, bothnot(Z,X,Y) ,1).
ria_map2( xor,       X,Y, Z, exor(Z,X,Y),1).
ria_map2(  ; ,       X,Y, Z, or(Z,X,Y),   1).

ria_map2( root,      X,N, Z, rootsquare(Z,X),  1).
ria_map2( qpow_even, X,N, Z, qpow_even(Z,X,N), 1).
ria_map2( pow_odd,   X,N, Z, pow_odd(Z,X,N),   1).
ria_map2( wrap,      X,N, Z, wrap(Z,X,N),      1).

/*
ria_map2( ==,        X,Y, B, k_equal(X,Y,B),3).
ria_map2( >=,        X,Y, B, j_less(X,Y,B), 3).
ria_map2( =<,        Y,X, B, j_less(X,Y,B), 3).
*/
	%%--------------------------------------------------------
	%% Boolean functions:
	%% Warning: Unlike the other function nodes, for these
	%% nodes, the "result" argument is arg3 instead of arg 1
	%%--------------------------------------------------------
ria_map2( ==,        X,Y, Z, k_equal(X,Y,Z),3).
ria_map2( >=,        X,Y, Z, j_less(X,Y,Z), 3).
ria_map2( =<,        Y,X, Z, j_less(Y,X,Z), 3).

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%  Relation Nodes  %%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%

fmap_rel( ==,   X,Y, equal(X,Y)).
fmap_rel( >=,   X,Y, greatereq(X,Y)).
fmap_rel( =<,   X,Y, greatereq(Y,X)).
fmap_rel( <,    X,Y, higher(X,Y)).
fmap_rel( >,    X,Y, higher(Y,X)).
fmap_rel( <>,   X,Y, unequal(X,Y)).
fmap_rel( sub,   X,Y, narrower(Y,X)).
/*
fmap_rel( '|=', X,Y, begin_tog(X,Y)).
fmap_rel( '=|', X,Y, finish_tog(X,Y)).
*/
fmap_rel( 'i=', X,Y, begin_tog(X,Y)).
fmap_rel( '=i', X,Y, finish_tog(X,Y)).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%        SOLVE
%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*----------------------------------------------------------------------*
 |	solve/1
 |	solve(Var)
 |	solve(+)
 |
 |	solve/3
 |	solve(Var, Bnd, RelativeErr)
 |	solve(Var, Bnd, RelativeErr)
 |
 |	Var is a variable which has been frozen to an interval structure;
 |	Bnd = integer; 2^Bnd is the limit on the number of solutions;
 |	RelativeErr = bound for error size;
 |
 |  Note: solve(X) is intended only for cases where a fixed point is a 
 |  join of several smaller fix points, e.g. "points".  If a point in 
 |  the middle of the interval  ( e.g. median or midpoint) can be found 
 |	which is not a solution, the problem can be decomposed into two 
 |	smaller problems. This is applied recursively until the interval 
 |	becomes pointliike, the depth of recursion is exceeded, or no split 
 |	point can be found.
 *----------------------------------------------------------------------*/

export solve/1.
solve(X)
	:- 
	solve_epsilon(Epsilon),
	solve(X, Epsilon).

/*----------------------------------------------------------------------*
 |	solve/2
 |	solve(Var, Epsilon)
 |	solve(+, +)
 |
 |	Tim Hickey's version of solve/2 and friends:
 *----------------------------------------------------------------------*/

solve(X,E)
	:-
	nonvar(X),
	X = [A|As],
	!,
	solve_list([A|As],E).

solve(X,E) 
	:-
	small_enough(X,E),
	!.

solve(X,E) 
	:-
	split(X,E),
	solve(X,E).

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
solve_list(L,E) 
	:-
	solve_list(L,E,Changes),
	solve_list_cont(Changes,L,E).

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
solve_list_cont(0,_,_).

solve_list_cont(N,L,E) 
	:- 
	N>0,
	solve_list(L,E).

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
solve_list([],_,0).

solve_list([A|As],E,V) 
	:-
	small_enough(A,E),
	!,
	solve_list(As,E,V).

solve_list([A|As],E,V) 
	:-
	split(A,E),
	solve_list(As,E,W),
	V is W+1.

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
small_enough(X,E) 
	:-
	number(X),
	!.

small_enough(X,E) 
	:-
	'$domain'(X,_Type,Lo,Hi),
	Eps is Hi-Lo, 
	E >= Eps.

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
split(X,E) 
	:-
	'$domain'(X,_Type,Lo,Hi),
	Eps is Hi - Lo,
	Eps >= E,
	Mid is (Lo+Hi)/2,
	{ X < Mid }.

split(X,E) 
	:-
	'$domain'(X,_Type,Lo,Hi),
	Eps is Hi - Lo,
	Eps >= E,
	Mid is (Lo+Hi)/2,
	{ X >= Mid }.

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
%% default:
solve_epsilon(0.000001).

export set_solve_epsilon/1.
set_solve_epsilon(Value)
	:-
	(float(Value) -> TheValue = Value ; 
		(integer(Value) -> TheValue is float(Value)
			;
				%% raise exception here:
			fail
		) ),
	retract(solve_epsilon(OldValue)),
	assert(solve_epsilon(TheValue)).






/******************
solve(X)
	:- 
	solve(X, 6, 0.0001).			% upto 2**6 solutions


export solve/3.
solve( X, _, RelErr )
	:- 
	pointlike(X, RelErr), 			% bound or very small intervals
	!. 

solve( X, Bnd, RelErr ) 
	:- 
	var(X),
	!,
			%% What is this about? (Making sure it's an interval???):
%	$interval_type(X,_), 
	Bnd>=0, 
	'$domain'(X, _, L, U),
	D is U - L,
	min( 1.0e-100,  RelErr * D, Eps),
	i_solve(Bnd, X, Eps).


solve( [], _,  _ ).
solve( List, Bnd, RelErr ) 
	:-
	Bnd > 0,
	extract_intervals( List, Xs ),
	widest( Xs, X ), 
	not( pointlike( X, RelErr) ),
	'$domain'(X, _, L, U),
	D is U - L,
	min( 1.0e-100,  RelErr * D, Eps),
	!,
	multi_solve( Bnd, Xs, Eps).
******************/

/*----------------------------------------------------------------------*
 *----------------------------------------------------------------------*/
pointlike( X, _) 
	:- 
	number(X),
	!.

pointlike( X, RelErr) 
	:- 
	'$domain'(X, _, L, U),
	Delta is U - L,
	Midpoint is (U + L)/2,
	Delta < (RelErr * Midpoint).

/*------------------------------------------------------------------------------*
 |	i_solve/3
 |	i_solve(Bnd, X, Eps)
 |	i_solve(+, +, +)
 |
 |	Iteratively attempt to "bisect" X and seek a solution in each of the
 |	two resulting halves.
 |	Bnd	= limit in the depth of bisection;
 |	X	= the interval
 |	Eps = the error tolerance
 *------------------------------------------------------------------------------*/
		%% split if possible:
i_solve(Bnd, X, Eps)
	:- 
	0 < Bnd ,  		
	Bnd1 is Bnd - 1,
	choose_split(X, M, Eps),
	!,
		%% Put #ifdef wrapper corresponding to DEBUGSYS around this:
	(debug_system_on(cstrislv) ->
		'$domain'(X, _, XL, XU),
		'$domain'(X, _, ML, MU),
		printf('i_solve:bnd=%t X=[%t,%t] M=[%t,%t]\n',[Bnd,XL,XU,ML,MU])
		; true),

		%% Force:
	('$iterate'( greatereq(M, X) ) ; '$iterate'( greatereq(X, M) ) ),
	i_solve(Bnd1, X, Eps).

		%% N=0, too small, or no suitable split point found:
i_solve(Bnd,X,Eps).        

		%% fails if interval is too small or not splittable:
choose_split(X, M, RelErr)
	:-   			
	var(X),
	'$domain'(X, _, L, U),
	intv_median(L, U, M),
	(U - L)  >  RelErr * M,  	% interval is pointlike
		%% Change/Fix (??):
	not(X==M),
	!.

export intv_median/2.
intv_median(Interval, M)
	:-
	Interval::real(L,U),
	intv_median(L,U,M).

intv_median( L, U, 0  ) :- L<0,     U>0, !.
intv_median( L, U, 1  ) :- L<1.0,   U>  1.0, !.
intv_median( L, U, -1 ) :- L< -1.0, U> -1.0, !.
intv_median( L, U,  M ) :- L==0.0,  M is U/3.0, !.
intv_median( L, U,  M ) :- U==0.0,  M is L/3.0, !.  
intv_median( L, U,  M ) :- L>0,     U>0,  M is sqrt(L)*sqrt(U), !.
intv_median( L, U,  M ) :- L<0,     U<0,  M is -sqrt(-L)*sqrt(-U), !.
		%% default to midpoint:
intv_median( L, U,  M ) :- M is (L+U)/2.0 .   

multi_solve( 0, List, Eps) :-!.

multi_solve( Bnd, List, Eps)
	:-
	widest(List, X),
	!,
	multi_solve1( List, X, Eps, Bnd ).

multi_solve1( List, X, Eps, Bnd )
	:-
	pointlike( X, Eps ),
	!.

multi_solve1( List, X, Eps, Bnd )
	:-
	Bnd1 is Bnd - 1,
	i_solve( 1, X, Eps ),
	multi_solve( Bnd1, List, Eps ).

widest( [X | Xs], W)
	:-
	widest( Xs, X, W ).

widest( [], W, W ).

widest( [X | Xs], Y, W )
	:-
	'$domain'(X, _, XL, XU),
	DeltaX is XU - XL,
	'$domain'(Y, _, YL, YU),
	DeltaX is YU - YL,
	!,
	widest( Xs, X, W).

widest( [_ | Xs], Y, W )
	:-
	widest( Xs, Y, W ).

export enumerate/1.
enumerate( Var )
	:-
	var(Var),
	!,
	enumerate([Var]).

enumerate( List )
	:-
	classify_intervals( List, Bs, Ns, Rs ),
		%% do booleans first (smaller domains):
	boolean_enumerate( Bs ),   
	integer_enumerate(  Ns ),
	real_enumerate( Rs ).

classify_intervals( [], [], [], [] ).

classify_intervals( [X | List], Bs, Ns, Rs )
	:-
	var(X),
	'$domain'( X, Type, LB, UB ),
	!,
	dispatch_classify_intervals(Type, X, List, Bs, Ns, Rs ).

classify_intervals( [_ | List], Bs, Ns, Rs )
	:-
	classify_intervals( List, Bs, Ns, Rs ).

dispatch_classify_intervals(boolean, X, List, [X | Bs], Ns, Rs )
	:-
	classify_intervals( List, Bs, Ns, Rs ).

dispatch_classify_intervals(integer, X, List, Bs, [X | Ns], Rs )
	:-
	classify_intervals( List, Bs, Ns, Rs ).

dispatch_classify_intervals(real, X, List, Bs, Ns, [X | Rs] )
	:-
	classify_intervals( List, Bs, Ns, Rs ).

boolean_enumerate([]).
boolean_enumerate([ X | Xs ])
	:-
	boolean_generator( X ),
	boolean_enumerate( Xs ).

boolean_generator( B )
	:-
	'$iterate'( equal(B, 0)).

boolean_generator( B )
	:-
	'$iterate'( equal(B, 1)).


integer_enumerate([]).
integer_enumerate([ X | Xs ])
	:-
	integer_generator( X ),
	integer_enumerate( Xs ).

integer_generator( X )
	:-
	integer(X),
	!.

integer_generator( X )
	:-
	'$domain'( X, Type, LB, _ ),
	L1 is round( LB ),
	int_choice( X, L1 ).
	
int_choice( X, L )
	:-
	'$iterate'( equal(X, L)).

int_choice( X, L )
	:-
	'$iterate'( unequal(X, L)),
	integer_generator( X ).

real_enumerate([]).

real_enumerate( [X | Xs] )
	:-
	solve( X ),
	solve(Xs).



/*
export enumerate/2.
enumerate(List, Exec_on_Backtrack)
	:-
	classify_intervals( List, Bs, Ns, Rs ),
		%% do booleans first (smaller domains):
	bool_enumerate_act( Bs, Exec_on_Backtrack ),   
	int_enumerate_act(  Ns, Exec_on_Backtrack ),
	real_enumerate( Rs ).
*/







endmod.
