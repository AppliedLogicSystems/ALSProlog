/* #define trace  /* */
/* #define hex    /* */
/*******************************************************************************

This unit implements the interval arithmetic functions fuzz and iterate.
The body of iterate is generated by Prolog to produce the file interval.h,
which is included at the appropriate place (in our case it becomes a 
case table).

   fuzz/3 takes a floating point number in arg1, and returns the
          previous and next floating point numbers in r2 and r3.
		  
   iterate/1 takes a structure as described below, pulls it apart,
             and processes it.  Any intervals that change may cause
			 other structures to be processed, so it processes the
			 structures using a queue.
			 
The structure passed to iterate/1 looks like:

   +----------+-----------+---------+---------+---------+---------+
   |  header  |  functor  |    Z    |    X    |    Y    |    0    |
   +----------+-----------+---------+---------+---------+---------+
   
where:
   
   header    - is always 8CBE0004 (structure of arity 4)
             - used as a queue link when the structure is to be processed,
			   so must be restored prior to exit
			 - when a interval refers to it, it may already be on the queue
   functor   - symbol, representing the name of the action
             - first character is $, so we use the second character to index
   X, Y, Z   - possibly a symbol         - means argument unused
                        short integer \ 
			long integer   - means the argument is a point
			float         /  (lowerbound = upperbound)
			constrained variable
			
		+------------+---------------+---------------+
	   +--> |  variable  |  constraint   |  constraint   | 
	   |	|   (self)   |    marker     |  (structure)  | 
	   |	+------+-----+---------------+-------+-------+
	   |	       |			     |
	   +-----------+ <--------+ 		     |
				   \		     |
    +-------------------------------|----------------+
    |	                           /
    |    +--------+----------+-----+----+------------+------+------+-----+
    +--> | header | interval | variable |  list of   |  LB  |  UB  |  0  |
(a)	 |        |   type   |          | primitives |      |      |     |
         +--------+----------+----------+------------+------+------+-----+

	 +--------+----------+----------+------------+------+
(b)	 | header | interval | variable |  list of   |  0   |
	 |        |   type   |          | primitives |      |
	 +--------+----------+----------+------------+------+

(a) where:
   	header       - is always 8CBE0005 (structure of arity 5)
   	intervaltype - is $interval (intervalAtom) if the point should
     	             become a float, otherwise an integer $integral (integralAtom)
  	variable     - refers back to the variable with the constraint
	LB, UB       - lowerbound and upperbound of the interval respectively,
	                  always floats
				- when the interval changes, these values need to be
				  changed.  The value may be updated in place if the
				  value does not need to be trailed
   	primitives   - list of structures that use this variable.  Whenever
                  	changes to this variable or the constraint are made,
			the structures on this list need to be processed as well.
			Note that they already may be on the queue due to other
			operations.  This list is terminated by a tailvar, but
                  	we simply go until we hit a non structure.

(b) where:
	header	     - is always 8CBE0003 (structure of arity 3)
	intervaltype - is $boolean (booleanAtom) for representing booleans
	variable     - refers back to the variable with the constraint
	primitives   - same as (a).
	 
*******************************************************************************/

/*
#include "BNRProlog.h"
#include "base.h"
#include "core.h"
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <errno.h>
#include <values.h>			/* for DBL_MAX */
#include "interpreter.h"
#include "prim.h"
#include "hardware.h"
#include "utility.h"
*/

typedef union fpoverlay {
	long l[2];
	fp f;
	} fpoverlay;

#ifdef REVERSE_ENDIAN
#define FIRST	1
#define SECOND	0
#else
#define FIRST	0
#define SECOND	1
#endif	/* REVERSE_ENDIAN */

extern long BNRPflags; 

#ifdef Macintosh								/* Macintosh */
#include <SANE.h>
#include <float.h>		/* for DBL_MAX */
#ifdef applec			/* MPW C on the Macintosh */
environment BNRP_SANE_default_environment;
#define int_fp			extended
#define iszero(x)		(x EQ -0.0)
#define next(x)			x = nextdouble(x, maxfp)
#define prev(x)			x = nextdouble(x, -maxfp)
#define upperbd(y, x)	setround(UPWARD); x = y
#define lowerbd(y, x)	setround(DOWNWARD); x = y
#define upperbd2(y, x)	setenvironment(BNRP_SANE_default_environment); upperbd3(y, &x)
#define lowerbd2(y, x)	setenvironment(BNRP_SANE_default_environment); lowerbd3(y, &x)
#define initfpu()		procentry(&BNRP_SANE_default_environment); setprecision(DBLPRECISION); maxfp = DBL_MAX
#define resetfpu()		procexit(BNRP_SANE_default_environment)
#define dumpmemory(x)	{ unsigned char *_p = (unsigned char *)&x; \
				long _s = sizeof(x); \
				while (--_s GE 0) printf("%02x", *_p++); \
				printf("  (%1.10g)", x); \
				}
	
void upperbd3(int_fp x, int_fp *y)
{
	double _t;
	setround(UPWARD);
	setprecision(DBLPRECISION);
	_t = x;
	*y = _t;
	}
void lowerbd3(int_fp x, int_fp *y)
{
	double _t;
	setround(DOWNWARD);
	setprecision(DBLPRECISION);
	_t = x;
	*y = _t;
	}
#else				/* finish-MPW C on the Macintosh */
#ifdef THINK_C		/* THINK C on the Macintosh */
#define int_fp			long double
#define iszero(x)		(x EQ -0.0)
extended _maxfp, _maxnegfp;
#define next(x)			{ 	extended _x; \
					x96tox80(&x, &_x); \
					_x = nextdouble(_x, _maxfp); \
					x80tox96(&_x, &x); \
					}
#define prev(x)			{ 	extended _x; \
					x96tox80(&x, &_x); \
					_x = nextdouble(_x, _maxnegfp); \
					x80tox96(&_x, &x); \
					}
#define upperbd(y, x)	setround(UPWARD); x = y
#define lowerbd(y, x)	setround(DOWNWARD); x = y
#define upperbd2(y, x)	setenvironment(IEEEDEFAULTENV); upperbd3(y, &x)
#define lowerbd2(y, x)	setenvironment(IEEEDEFAULTENV); lowerbd3(y, &x)
void upperbd3(long double x, long double *y)
{ 
	extended _x;
	
	setprecision(DBLPRECISION);
	setround(UPWARD);
	x96tox80(&x, &_x);
	_x = nextdouble(_x, _maxfp);
	x80tox96(&_x, y);
	}
void lowerbd3(long double x, long double *y)
{ 
	extended _x;
	
	setprecision(DBLPRECISION);
	setround(DOWNWARD);
	x96tox80(&x, &_x);
	_x = nextdouble(_x, _maxnegfp);
	x80tox96(&_x, y);
	}
#define initfpu()		maxfp = BNRP_getMaxFP(); \
						{ long double maxnegfp = -maxfp; \
						  x96tox80(&maxfp, &_maxfp); \
						  x96tox80(&maxnegfp, &_maxnegfp); \
						  } \
						setprecision(DBLPRECISION)
#define resetfpu()		setenvironment(IEEEDEFAULTENV)

#else				/* finished-THINK C on the Macintosh */
#if defined(powerc) || defined (__powerc)		/* Macintosh PowerPC */
#define int_fp			fp
#define iszero(x)		(x EQ -0.0)
#define next(x)			if (x GE 0.0) { \
					if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
						++(((fpoverlay *)&x)->l[FIRST]); \
					} \
				else if (x LT 0.0) { \
					if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
						--(((fpoverlay *)&x)->l[FIRST]); \
							}
#define prev(x)			if (x GT 0.0) { \
					if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
						--(((fpoverlay *)&x)->l[FIRST]); \
					} \
				else if (x LT 0.0) { \
					if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
						++(((fpoverlay *)&x)->l[FIRST]); \
					} \
				else { /* x EQ 0.0 */ \
					((fpoverlay *)&x)->l[SECOND] = 1; \
					((fpoverlay *)&x)->l[FIRST] = 0x80000000; \
					}
#define upperbd(y, x)	x = y; next(x)
#define lowerbd(y, x)	x = y; prev(x)
#define upperbd2(y, x)	x = y; next(x)
#define lowerbd2(y, x)	x = y; prev(x)
#define initfpu()		
#define resetfpu()		
#endif				/* finished-Macintosh PowerPC */
#endif				/* finished-THINK C on the Macintosh */
#endif				/* finish-MPW C on the Macintosh */

#else											/* finish-Macintosh */


#ifdef sun										/* SUN SPARCSTATION */
#ifdef solaris		/* SOLARIS */
#include <ieeefp.h>
#define int_fp			fp
#define next(x)			x = nextafter(x, maxfp)
#define prev(x)			x = nextafter(x, -maxfp)
#define iszero(x)		(x EQ -0.0)
#define upperbd(y, x)	fpsetround(FP_RP); x = y
#define lowerbd(y, x)	fpsetround(FP_RM); x = y
#define upperbd2(y, x)	fpsetround(FP_RN); x = nextafter(y, maxfp)
#define lowerbd2(y, x)	fpsetround(FP_RN); x = nextafter(y, -maxfp)
#define initfpu()		maxfp = DBL_MAX
#define resetfpu()		fpsetround(FP_RN)
#else				/* SunOS (BSD) */
#include <sys/ieeefp.h>			/* for ieee_flags */
#define int_fp			fp
#define next(x)			x = nextafter(x, maxfp)
#define prev(x)			x = nextafter(x, -maxfp)
#define fpu(a,b,c)		{ char *out; (void)ieee_flags(a, b, c, &out); }
#define upperbd(y, x)	fpu("set", "direction", "positive"); x = y
#define lowerbd(y, x)	fpu("set", "direction", "negative"); x = y
#define upperbd2(y, x)	fpu("set", "direction", "nearest"); x = nextafter(y, maxfp)
#define lowerbd2(y, x)	fpu("set", "direction", "nearest"); x = nextafter(y, -maxfp)
#define initfpu()		fpu("set", "precision", "double"); maxfp = DBL_MAX
#define resetfpu()		fpu("clearall", "", "")
#endif

#else
#if ultrix 					/* DECstation 3100 */
#include <mips/fpu.h>
#define int_fp			fp
#define iszero(x)		(x EQ -0.0)
#define next(x)		if (x GE 0.0) { \
				if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
					++(((fpoverlay *)&x)->l[FIRST]); \
				} \
			else if (x LT 0.0) { \
				if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
					--(((fpoverlay *)&x)->l[FIRST]); \
				}
#define prev(x)		if (x GT 0.0) { \
				if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
					--(((fpoverlay *)&x)->l[FIRST]); \
				} \
			else if (x LT 0.0) { \
				if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
					++(((fpoverlay *)&x)->l[FIRST]); \
				} \
			else { /* x EQ 0.0 */ \
				((fpoverlay *)&x)->l[SECOND] = 1; \
				((fpoverlay *)&x)->l[FIRST] = 0x80000000; \
				}
#define upperbd(y, x)	(void)swapRM(ROUND_TO_PLUS_INFINITY); x = y
#define lowerbd(y, x)	(void)swapRM(ROUND_TO_MINUS_INFINITY); x = y
#define upperbd2(y, x)	upperbd(y, x)
#define lowerbd2(y, x)	lowerbd(y, x)
#define initfpu()		BNRP_oldRM = swapRM(ROUND_TO_PLUS_INFINITY)
#define resetfpu()		(void)swapRM(BNRP_oldRM)
int BNRP_oldRM;

#else
#if sgi 					/* Silicon Graphics */
#include <sys/fpu.h>
#define int_fp			fp
#define iszero(x)		(x EQ -0.0)
#define next(x)		if (x GE 0.0) { \
				if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
					++(((fpoverlay *)&x)->l[FIRST]); \
				} \
			else if (x LT 0.0) { \
				if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
					--(((fpoverlay *)&x)->l[FIRST]); \
				}
#define prev(x)		if (x GT 0.0) { \
				if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
					--(((fpoverlay *)&x)->l[FIRST]); \
				} \
			else if (x LT 0.0) { \
				if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
					++(((fpoverlay *)&x)->l[FIRST]); \
				} \
			else { /* x EQ 0.0 */ \
				((fpoverlay *)&x)->l[SECOND] = 1; \
				((fpoverlay *)&x)->l[FIRST] = 0x80000000; \
				}
#define upperbd(y, x)	(void)swapRM(ROUND_TO_PLUS_INFINITY); x = y
#define lowerbd(y, x)	(void)swapRM(ROUND_TO_MINUS_INFINITY); x = y
#define upperbd2(y, x)	upperbd(y, x)
#define lowerbd2(y, x)	lowerbd(y, x)
#define initfpu()		BNRP_oldRM = swapRM(ROUND_TO_PLUS_INFINITY)
#define resetfpu()		(void)swapRM(BNRP_oldRM)
int BNRP_oldRM;

#else
#ifdef hpux				/* HP 300/400/800 */
#define int_fp			fp
#define iszero(x)		(x EQ -0.0)
#define next(x)			if (x GE 0.0) { \
					if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
						++(((fpoverlay *)&x)->l[FIRST]); \
					} \
				else if (x LT 0.0) { \
					if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
						--(((fpoverlay *)&x)->l[FIRST]); \
							}
#define prev(x)			if (x GT 0.0) { \
					if (--(((fpoverlay *)&x)->l[SECOND]) EQ -1) \
						--(((fpoverlay *)&x)->l[FIRST]); \
					} \
				else if (x LT 0.0) { \
					if (++(((fpoverlay *)&x)->l[SECOND]) EQ 0) \
						++(((fpoverlay *)&x)->l[FIRST]); \
					} \
				else { /* x EQ 0.0 */ \
					((fpoverlay *)&x)->l[SECOND] = 1; \
					((fpoverlay *)&x)->l[FIRST] = 0x80000000; \
					}
#ifdef __HAVE_68881__
/* format of the %fpcr register is:
        pprr0000
   where:
        pp = precision (00 extended, 01 single, 10 double)
        rr = rounding  (00 nearest, 01 to zero, 10 to -inf, 11 to +inf)   */
#define upperbd(y, x)	asm("fmov.l &0xB0, %fpcr"); x = y
#define lowerbd(y, x)	asm("fmov.l &0xA0, %fpcr"); x = y
#define upperbd2(y, x)	resetfpu(); x = y; next(x)
#define lowerbd2(y, x)	resetfpu(); x = y; prev(x)
#define initfpu()		asm("fmov.l &0x80, %fpcr")
#define resetfpu()		asm("fmov.l &0, %fpcr")
#else						/* HP PA, currently unknown FPU */
#define upperbd(y, x)	x = y; next(x)
#define lowerbd(y, x)	x = y; prev(x)
#define upperbd2(y, x)	x = y; next(x)
#define lowerbd2(y, x)	x = y; prev(x)
#define initfpu()		
#define resetfpu()		
#endif	/* __HAVE_68881__ */
#endif
#endif
#endif
#endif
#endif

/*Variables used for encoding booleans*/
#define booleanZero		0x00
#define booleanOne		0x01
long booleanInput = booleanZero;
long booleanOutput = booleanZero;

/*Encodings:

booleanInput: 		|0, 0, ydef, y, xdef, x, zdef, z|
booleanOutput:		|1, 0, 0, 0, 0, 0, 0, 0| -> error
			|1, 1, 1, 1, 1, 1, 1, 1| -> failure
			|0, disable, ychg, y, xchg, x, zchg, z|
*/


/*Masks for boolean encodings*/
#define booleanError		0x80		/*booleanOutput*/
#define booleanFail		0xff		/*booleanOutput*/
#define booleanDisable		0x40		/*booleanOutput*/
#define boolean_ydef		0x20		/*booleanInput*/
#define boolean_ychg		0x20		/*booleanOutput*/
#define boolean_y		0x10		/*booleanInput and booleanOutput*/
#define boolean_xdef		0x08		/*booleanInput*/
#define boolean_xchg		0x08		/*booleanOutput*/
#define boolean_x		0x04		/*booleanInput and booleanOutput*/
#define boolean_zdef		0x02		/*booleanInput*/
#define boolean_zchg		0x02		/*booleanOutput*/
#define boolean_z		0x01		/*booleanInput and booleanOutput*/
	

#define trail(te, addr)		rpush(long, te, *(long *)addr); \
							rpush(long, te, (long)addr);

#define simplebind(v, new)	trail(tcb->te, v); \
							*(long *)v = (long)new;

#define heapcheck(n)		if ((tcb->heapend - tcb->hp) LE (n * sizeof(long))) \
					BNRP_error(HEAPOVERFLOW)

#define swap(x)			{ int_fp temp = x ## l; \
					x ## l = (x ## h NE 0.0) ? (- x ## h) : 0.0; \
					x ## h = (temp NE 0.0) ? (- temp) : 0.0; \
				} \
				x ## flipped();

#define getSimple(p, v)		{ long tag; \
					if ((tag = tagof(p)) EQ SYMBOLTAG) \
						v = 0.0; \
					else if (tag EQ INTTAG) { \
						li tt; \
						tt.l = p; \
						v = tt.i.b; \
					} \
					else if (tag EQ STRUCTTAG) { \
						long *tt = (long *)addrof(p); \
						li t1; \
						t1.l = *tt++; \
						if (t1.i.a EQ NUMBERIDshort) \
							if (t1.i.b EQ INTIDshort) \
								v = (fp)*tt; \
							else { \
								fpLWA(tt); \
								v = *(fp *)tt; \
								} \
						else \
							goto failure; \
						} \
					else \
						goto failure; \
					}

#define nextArg(p, x)		while (tagof(x = *p) EQ TVTAG) { \
					long _a = addrof(x); \
					if ((long)p EQ _a) break; \
					p = (long *)_a; \
					} \
				++p; \
				while (isVAR(x)) { \
					long _tt = derefVAR(x); \
					if (x EQ _tt) break; \
					x = _tt; \
					}

#define nextAddr(p, x, a)	while (tagof(x = *p) EQ TVTAG) { \
					long _a = addrof(x); \
					if ((long)p EQ _a) break; \
					p = (long *)_a; \
					} \
				a = (long)p; \
				++p; \
				while (isVAR(x)) { \
					long _tt = derefVAR(x); \
					if (x EQ _tt) break; \
					a = x; \
					x = _tt; \
					}

#define getValues(x)	if (tagof(x ## addr) EQ VARTAG) { \
				long s1, s2, *t = (long *)addrof(x ## addr); \
				if (t[1] NE CONSTRAINTMARK) goto failure; \
				s1 = t[2]; \
				if (tagof(s1) EQ LISTTAG) { \
					/* special case, constraint must be first in list */ \
					s1 = *(long *)addrof(s1); /* get first thing in list */ \
					} \
				if (tagof(s1) NE STRUCTTAG) goto failure; \
				t = (long *)addrof(s1); \
				if (*t EQ (STRUCTHEADER | 5))\
				{\
					t++;\
					nextArg(t, x ## type); \
					nextArg(t, s1); /* skip variable */ \
					nextArg(t, x ## constraints); \
					nextAddr(t, s1, x ## laddr); \
					nextAddr(t, s2, x ## haddr); \
					getSimple(s1, x ## l); \
					getSimple(s2, x ## h); \
				}\
				else if (*t++ EQ STRUCTHEADER | 3)\
				{/* x is a boolean.  Boolean structures are of arity 3*/\
					nextArg(t, x ## type);\
					nextArg(t, s1);\
					nextArg(t, x ## constraints);\
					x ## l = booleanZero; \
					x ## h = booleanOne; \
				} \
				else goto failure;\
			}\
			else { \
					x ## laddr = x ## haddr = x ## constraints = 0;\
					getSimple(x ## addr, x ## l = x ## h); \
			}

#define getBooleanValues(x)	if (tagof(x ## addr) EQ VARTAG){ \
					long s1, *t = (long *)addrof(x ## addr); \
					if (t[1] NE CONSTRAINTMARK) goto failure; \
					s1 = t[2]; \
					if (tagof(s1) EQ LISTTAG) { \
						/* special case, constraint must be first in list  */ \
						s1 = *(long *)addrof(s1);  /*get first thing in list */ \
					} \
					if (tagof(s1) NE STRUCTTAG) goto failure; \
					t = (long *)addrof(s1); \
					if (*t++ NE (STRUCTHEADER | 3)) goto failure; \
					nextArg(t, x ## type); \
					if (x ## type NE booleanAtom) goto failure;\
					nextArg(t, s1);   /* skip variable */ \
					nextArg(t, x ## constraints); /*since x is a variable no need to set anything in booleanInput*/\
				} \
				else{ /* x is a fixed point.  Get its value and set appropriate bits in booleanInput*/\
					if (tagof(x ## addr) EQ INTTAG)\
					{\
						li tt;\
						tt.l = x ## addr;\
						if (tt.i.b)\
							booleanInput |= boolean_ ## x; \
						booleanInput |= boolean_ ## x ## def;\
					}\
					else \
					{/*If x is a symbol do nothing otherwise fail*/\
						if (tagof(x ## addr) NE SYMBOLTAG) goto failure;\
					}\
				}

#define updateBoolean(x)	if (boolean_ ## x ## chg & booleanOutput) {\
					unifyQuick(tcb, x ## addr, makeint(&tcb->hp, ((booleanOutput & boolean_ ## x) ? booleanOne : booleanZero)));\
					if (tagof(x ## constraints) EQ LISTTAG) {\
						long *t = (long *)addrof(x ## constraints);\
						while (1) {\
							long tt, ttt;\
							nextArg(t, tt);\
							if (tagof(tt) NE STRUCTTAG) break;\
							if (*(long *)(ttt = addrof(tt)) NE (STRUCTHEADER | 4))\
								/* may already be on the queue, or garbage so ignore it */\
								continue;\
							tt = *(long *)(ttt + sizeof(long));\
							/* skip noopnode functors */\
							if (tt EQ noopnodeAtom) continue;\
							*qtail = ttt;\
							*(long *)ttt = 0;\
							qtail = (long *)ttt;\
						}\
					}\
				}
	
#define xflip		(1 << 0)
#define xlchange	(1 << 1)
#define xhchange	(1 << 2)
#define yflip		(1 << 3)
#define ylchange	(1 << 4)
#define yhchange	(1 << 5)
#define zflip		(1 << 6)
#define zlchange	(1 << 7)
#define zhchange	(1 << 8)
#define redonode	(1 << 9)	/*Used to check if a diophantine node needs to be redone*/
#define link		(1 << 10)	/*Used to check if the node needs to be linked into the network*/
#define unflip(x)	if (status & x ## flip) { \
				int_fp t = x ## l; \
				status ^= x ## flip; \
				x ## l = (x ## h NE 0.0) ? (- x ## h) : 0.0; \
				x ## h = (t NE 0.0) ? (- t) : 0.0; \
				switch (status & (x ## lchange | x ## hchange)) { \
					case x ## lchange: \
					case x ## hchange: \

/* Flips the xlchange & xhchange*/	status ^= (x ## lchange | x ## hchange); \
				} \
			}

#define updatehalf(x, b, m)	if (status & x ## b ## change) { \
					long _fpaddr = addrof(*(long *)(x ## b ## addr)); \
					fp _tt; \
					if (iszero(x ## b)) x ## b = 0.0; \
					if (sizeof(int_fp) > sizeof(fp)) { \
						m(x ## b, _tt); \
						} \
					else \
						_tt = x ## b; \
					if (_fpaddr LT criticalhp) { \
						/* need to make a new float and trail old one */ \
						BNRP_term t = makefloat(&tcb->hp, &_tt); \
						simplebind(addrof(x ## b ## addr), t); \
						limit += BNRP_IntervalIncrement; \
						} \
					else { \
						/* we can update the bound in place */ \
						long *t = (long *)_fpaddr; \
						++t; 			/* skip header */ \
						fpLWA(t); \
						*(fp *)t = _tt; \
						limit -= BNRP_IntervalDecrement; \
						} \
					}
#define update(x)	if (status & (x ## lchange + x ## hchange)){\
				if (x ## l GT x ## h) goto failure;\
/*NEW for booleans*/		if (x ## type EQ booleanAtom)\
				{\
					long t;\
					switch(status & (x ## lchange + x ## hchange))\
					{/* boolean becomes a fixed point.  If both bounds change, then fail*/\
						case (x ## lchange):\
							t = booleanOne;\
							break;\
						case (x ## hchange):\
							t = booleanZero;\
							break;\
						default: goto failure;\
					}\
/*End new code*/		unifyQuick(tcb, x ## addr, makeint(&tcb->hp, t));\
				}\
				else {\
					if (x ## laddr EQ 0) goto failure;  /* can't change a point interval */\
	/*NEW for diophantines */	if (x ## type EQ integralAtom) \
					{ /*Round bounds inwards to nearest integer*/\
						int_fp new_int;\
						new_int = ceiling(x ## l);\
						if (x ## l NE new_int) \
						{/*If node has changed then it must be redone*/\
							status |= redonode; \
  							x ## l = new_int;\
						}\
						new_int = floor(x ## h);\
						if (x ## h NE new_int)\
						{\
							status |= redonode;\
							x ## h = new_int;\
	/*End new code */			} \
					}\
					updatehalf(x, l, lowerbd);\
					updatehalf(x, h, upperbd);\
					if (x ## l EQ x ## h) {\
						/* interval becomes a point */\
						long l;\
						if (x ## type EQ intervalAtom) {\
							fp t = x ## l;\
							l = makefloat(&tcb->hp, &t);\
						}\
						else\
							l = makeint(&tcb->hp, (long) x ## l);\
						unifyQuick(tcb, x ## addr, l);\
					}\
				} \
				if (tagof(x ## constraints) EQ LISTTAG) {\
					long *t = (long *)addrof(x ## constraints);\
					while (1) {\
						long tt, ttt;\
						nextArg(t, tt); \
						if (tagof(tt) NE STRUCTTAG) break;\
						if (*(long *)(ttt = addrof(tt)) NE (STRUCTHEADER | 4))\
							/* may already be on the queue, or garbage so ignore it */\
							continue;\
						tt = *(long *)(ttt + sizeof(long));\
						/* skip noopnode functors */\
						if (tt EQ noopnodeAtom) continue;\
						*qtail = ttt;\
						*(long *)ttt = 0;\
						qtail = (long *)ttt;\
					}\
				}\
			}

/* This links a node into the network if necessary.  Adds the node at qhead to the constraint list associated
   with x, if x is valid and unbound*/
#define linknode(x) 	if (tagof(x ## addr) EQ VARTAG)\
			{\
				long tt, *t = (long *)addrof(x ## addr);\
				long *s2 = (long *)addrof(x ## constraints);\
				if (x ## addr EQ *t)\
				{\
					if (tagof(x ## constraints) NE LISTTAG) goto failure;\
					nextArg(s2,tt);\
					while (tagof(tt) NE TVTAG)/*Last item in constraint list is always a tail variable*/\
					{\
						nextArg(s2, tt);\
					}\
					s2 = (long *)addrof(tt);\
					if ((long)s2 LT criticalhp)\
					{\
						trail(tcb->te, s2);\
					}\
					*s2 = maketerm(TVTAG, tcb->hp);\
					push(long,tcb->hp,maketerm(STRUCTTAG,(long)qhead));\
					push(long,tcb->hp,maketerm(TVTAG,tcb->hp));\
				}\
			}
				  
#define flushqueue()	while (qhead NE NULL) { \
				long l = *qhead; \
				*qhead = STRUCTHEADER | 4; \
				qhead = (long *)l; \
			}

#define interval_op(f)		case case_ ## f : \
							f:
#define end_op(f)
#define success()			break
#define fail()				goto failure
#define iaerror()			goto error
#define schedy()
#undef pi
#define pi()				M_PI
#define ln(x)				log(x)
#define ceiling(x)			ceil(x)
#define case_add			'a'
#define case_begin_tog		'b'
#define case_cos			'c'
#define case_equal			'e'
#define case_finish_tog		'f'
#define case_greatereq		'g'
#define case_higher			'h'
#define case_inf			'i'
#define case_j_less			'j'
#define case_k_equal		'k'
#define case_lub			'l'
#define case_mul			'm'
#define case_narrower		'n'
#define case_or				'o'
#define case_pow_odd		'p'
#define case_qpow_even		'q'
#define case_rootsquare		'r'
#define case_sin			's'
#define case_tan			't'
#define case_unequal		'u'
#define case_vabs			'v'
#define case_ydelta			'y'
#define case_xp				'x'

/*NEW definitions for boolean case statement */
#define do_nand			'a'
#define do_nor				'b'
#define do_and			'c'
#define do_or				'd'
#define do_xor			'e'
#define do_not				'f'


#define xlchng()			status |= xlchange
#define xhchng()			status |= xhchange
#define ylchng()			status |= ylchange
#define yhchng()			status |= yhchange
#define zlchng()			status |= zlchange
#define zhchng()			status |= zhchange
#define xflipped()			status |= xflip
#define yflipped()			status |= yflip
#define zflipped()			status |= zflip

#define deact()		{ long *p = qhead; \
				++p;				/* skip link */ \
				simplebind(p, noopnodeAtom); \
				}

#ifdef trace
#define dump(m, x)		displaymsg(m, x ## l, x ## h)
#ifdef hex
void displaymsg(char *m, fp xl, fp xh)
{
#define HEX(x)		((fpoverlay *)&x)->l[FIRST], ((fpoverlay *)&x)->l[SECOND]
	printf("\n%8s = %08lx%08lx  %08lx%08lx  [%1.20g %1.20g]", m, HEX(xl), HEX(xh), xl, xh);
	}
#else
void displaymsg(char *m, int_fp xl, int_fp xh)
{
	printf(", %s = [%1.20g %1.20g]", m, xl, xh);
	}
#endif
#endif

BNRP_Boolean BNRP_fuzz(TCB *tcb)
{
	long l;
	
	if ((tcb->numargs EQ 3) && (checkArg(tcb->args[1], &l) EQ FLOATT)) {
		fp n, ub, lb, maxfp;
		int_fp t;

		initfpu();
		n = *(fp *)l;
		t = n; next(t); ub = t;
		t = n; prev(t); lb = t;
		resetfpu();
		return(unify(tcb, tcb->args[2], makefloat(&tcb->hp, &lb)) &&
			   unify(tcb, tcb->args[3], makefloat(&tcb->hp, &ub)));
		}
	return(FALSE);
	}

extern long BNRP_handleIntervalErrors;
	
BNRP_Boolean BNRP_iterate(TCB *tcb)
{
	long status, *qhead, *qtail, functor, criticalhp, limit;
	long xaddr, yaddr, zaddr;
	long xladdr, xhaddr, yladdr, yhaddr, zladdr, zhaddr, xtype, ytype, ztype;
	long xconstraints, yconstraints, zconstraints;
	int_fp xl, xh, yl, yh, zl, zh, maxfp;
	int_fp ul, uh, vl, vh;

/*Boolean operation tables to convert booleanInput --> booleanOutput*/
	static int op_anynot[64] = {0x00,0x80,0x3c,0x00,0x80,0x80,0x80,0x80,
				0x43,0x80,0xff,0x40,0x00,0x80,0x30,0x20,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x43,0x80,0xff,0x40,0x80,0x80,0x80,0x80,
				0x03,0x80,0xff,0x00,0x03,0x80,0xff,0x00,
				0x00,0x80,0x0c,0x08,0x80,0x80,0x80,0x80,
				0x03,0x80,0xff,0x00,0x02,0x80,0x00,0xff};

	static int op_bothnot[64] = {0x00,0x80,0x00,0x28,0x80,0x80,0x80,0x80,
				0x00,0x80,0x30,0x20,0x42,0x80,0x40,0xff,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x00,0x80,0x0c,0x08,0x80,0x80,0x80,0x80,
				0x03,0x80,0xff,0x00,0x02,0x80,0x00,0xff,
				0x42,0x80,0x40,0xff,0x80,0x80,0x80,0x80,
				0x02,0x80,0x00,0xff,0x02,0x80,0x00,0xff};

	static int op_conjunction[64]={0x00,0x80,0x00,0x3c,0x80,0x80,0x80,0x80,
				0x42,0x80,0x40,0xff,0x00,0x80,0x20,0x30,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x42,0x80,0x40,0xff,0x80,0x80,0x80,0x80,
				0x02,0x80,0x00,0xff,0x02,0x80,0x00,0xff,
				0x00,0x80,0x08,0x0c,0x80,0x80,0x80,0x80,
				0x02,0x80,0x00,0xff,0x03,0x80,0xff,0x00};

	static int op_disjunction[64]={0x00,0x80,0x28,0x00,0x80,0x80,0x80,0x80,
				0x00,0x80,0x20,0x30,0x43,0x80,0xff,0x40,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x00,0x80,0x08,0x0c,0x80,0x80,0x80,0x80,
				0x02,0x80,0x00,0xff,0x03,0x80,0xff,0x00,
				0x43,0x80,0xff,0x40,0x80,0x80,0x80,0x80,
				0x03,0x80,0xff,0x00,0x03,0x80,0xff,0x00};

	static int op_exclusiveor[64]={0x00,0x80,0x00,0x00,0x80,0x80,0x80,0x80,
				0x00,0x80,0x20,0x30,0x00,0x80,0x30,0x20,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x00,0x80,0x08,0x0c,0x80,0x80,0x80,0x80,
				0x02,0x80,0x00,0xff,0x03,0x80,0xff,0x00,
				0x00,0x80,0x0c,0x08,0x80,0x80,0x80,0x80,
				0x03,0x80,0xff,0x00,0x02,0x80,0x00,0xff};

	static int op_negation[64]={0x00,0x80,0x0c,0x08,0x80,0x80,0x80,0x80,
		    		0x03,0x80,0xff,0x00,0x02,0x80,0x00,0xff,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
				0x00,0x80,0x0c,0x08,0x80,0x80,0x80,0x80,
				0x03,0x80,0xff,0x00,0x02,0x80,0x00,0xff,
				0x00,0x80,0x0c,0x08,0x80,0x80,0x80,0x80,
				0x03,0x80,0xff,0x00,0x02,0x80,0x00,0xff};

	if ((tcb->numargs NE 1) && (tcb->numargs NE 2)) return(FALSE);
	{
		long t;
		switch(checkArg(tcb->args[1], &functor))
		{/* If tcb->args[1] is a list, place all items in the list on the queue*/
			case STRUCTT:
				qhead = qtail = (long *)functor;
				if (*qhead NE (STRUCTHEADER | 4)) return(FALSE);
				*(long *)functor = (long)NULL;
				break;
			case LISTT:
				qhead = NULL;
				qtail = (long *)&qhead;
				nextArg((long *)functor,t);
				while((*(long *)(t = addrof(t))) EQ (STRUCTHEADER | 4)) /*While object at the front of the list is a structure, queue it*/
				{
					long ttt;
					long *tt = (long *)t;
					++tt;
					nextArg(tt,ttt);
					if(ttt NE noopnodeAtom) /*noopnode's are not queued*/
					{
						*qtail = t;
						*(long *)t = 0;
						qtail = (long *)t;
					}
					nextArg((long *)functor,t);
				}
				break;
			default: return(FALSE);
		}
	}
	status = 0;
	/* If two arguements are passed to iterate, then link first node on queue into network, if operation is successful */
	if (tcb->numargs EQ 2) status |= link;
	criticalhp = (tcb->lcp EQ tcb->cpbase) ? tcb->heapbase : 
		((choicepoint *)tcb->lcp)->hp;
	initfpu();
	++BNRP_intervalIterations;
#ifdef trace
	printf("Interval iteration %ld\n", BNRP_intervalIterations);
#endif
	limit = BNRP_MaxOperations;
	errno = 0;
	BNRP_handleIntervalErrors = 1;
	while (qhead NE NULL) 
	{
		heapcheck(100);
		if (BNRPflags & 0x01) goto abandon;
		if (limit LT 0) goto abandon;
		{		
			long *p = qhead;
			++p;			/* skip link*/
			nextArg(p, functor);
			if (functor EQ noopnodeAtom) goto success;
#ifdef trace
			printf("Interval op %ld %s", BNRP_intervalOperations, nameof(functor));
#endif
			++BNRP_intervalOperations;
			nextArg(p, zaddr);
			nextArg(p, xaddr);
			nextArg(p, yaddr);
		}
		if (nameof(functor)[1] EQ '$')		/*NEW Handles boolean operations*/
		{
			booleanInput = 0;
			booleanOutput = 0;
			getBooleanValues(x);
			getBooleanValues(y);
			getBooleanValues(z);
#ifdef trace
	dump("bx", x);
	dump("by", y);
	dump("bz", z);
#endif
			switch (nameof(functor)[2]) {
				case do_nand:
					booleanOutput=op_anynot[booleanInput];
					break;
				case do_nor:
					booleanOutput=op_bothnot[booleanInput];
					break;
				case do_and:
					booleanOutput=op_conjunction[booleanInput];
					break;
				case do_or:
					booleanOutput=op_disjunction[booleanInput];
					break;
				case do_xor:
					booleanOutput=op_exclusiveor[booleanInput];
					break;
				case do_not:
					booleanOutput=op_negation[booleanInput];
					break;
				default:
					goto error;
			}
			if(booleanOutput EQ booleanError) goto error;
			if(booleanOutput EQ booleanFail) goto failure;
			/*successful boolean operation, update x, y, and z */
			if (booleanOutput)
			{
				updateBoolean(z);
				updateBoolean(x);
				updateBoolean(y);
				if (booleanOutput & booleanDisable) deact();
#ifdef trace
				if (booleanOutput & boolean_xchg) dump("newbx", x);
				if (booleanOutput & boolean_ychg) dump("newby", y);
				if (booleanOutput & boolean_zchg) dump("newbz", z);
#endif
			}
		}
		else
		{
   			getValues(x);
			getValues(y);
			getValues(z);
redo:
#ifdef trace
			dump("x", x);
			dump("y", y);
			dump("z", z);
#endif		
			switch (nameof(functor)[1]) {
#include "interval.h"
				default:
					goto error;
				}
			if (errno NE 0) goto error;
			 /*successful operation, update x, y, and z */
			if (status & ~link) {		 /*something changed*/
				unflip(z);
				update(z);
				unflip(x);
				update(x);
				unflip(y);
				update(y);
#ifdef trace
				if (status & (xlchange + xhchange)) dump("newx", x);
				if (status & (ylchange + yhchange)) dump("newy", y);
				if (status & (zlchange + zhchange)) dump("newz", z);
#endif
			}
			if (status & redonode)
			{
				long * p = qhead;
				status &= link;
				++p;
				nextArg(p,functor);
				if (functor NE noopnodeAtom) goto redo;
			}
			/*If a diophantine node was evaluated, and its bounds were rounded in, then re-evaluate the node*/
		}
success:
#ifdef trace
		printf("\n");
#endif
		if(status & link) /*Link item at top of queue to the end of the constraint lists for all three variables*/
		{
			linknode(x);
			linknode(y);
			linknode(z);
		}
		status = *qhead;
		*qhead = STRUCTHEADER | 4;
		qhead = (long *)status;
		status = 0;
	}
	goto done;
abandon:
#ifdef trace
	printf("  abandon\n");
#endif
	flushqueue();
done:
	resetfpu();
	BNRP_handleIntervalErrors = 0;
	return(TRUE);
error:
#ifdef trace
	printf("  error\n");
#endif
	flushqueue();
	resetfpu();
	BNRP_error(ARITHERROR);
failure:
#ifdef trace
	printf("\n*** FAILURE ");
#ifndef Macintosh
	unflip(x);
	unflip(y);
	unflip(z);
	dump("finalx", x);
	dump("finaly", y);
	dump("finalz", z);
#endif
	printf("\n");
#endif
	flushqueue();
	resetfpu();
	BNRP_handleIntervalErrors = 0;
	return(FALSE);
	}
