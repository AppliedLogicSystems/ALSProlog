/*=====================================================================* |		pimain.c |	Copyright (c) 1988-1995, Applied Logic Systems, Inc. | |		-- default main() that initializes prolog and starts |			the development shell. | | 11/20/94 - C. Houpt -- Added Think/MetroWerks ccommand() call to allow |			      command line arguments for non-MPW versions. |			   -- Added include of pi_init header file to provide prototype. |			   -- Added PI_yield_time() to give other programs time. *=====================================================================*/#ifdef HAVE_CONFIG_H	/* In ALS-Prolog source tree */#include "defs.h"#else /* !HAVE_CONFIG_H */	/* Not in ALS-Prolog source tree... */#include "alspi.h"#include <stdio.h>#ifdef HAVE_STDLIB_H#include <stdlib.h>#endif#ifndef NO_STDARG_H#define HAVE_STDARG_H#endif#ifdef HAVE_STDARG_H#include <stdarg.h>#else#include <varargs.h>#endif#endif /* !HAVE_CONFIG_H */#include "pi_init.h"#include "pi_cfg.h"#ifdef APP_PRINTF_CALLBACKvoid app_printf(int messtype, va_list args);#endif#include <windows.h>#include <winsock.h>static int ConsoleIO(int port, char *buf, size_t size){    HANDLE f;    int result;        switch(port) {    case CONSOLE_READ:    	f = GetStdHandle(STD_INPUT_HANDLE);    	if (ReadFile(f, buf, size, &result, NULL)) return result;    	else return -1;     	break;    case CONSOLE_WRITE:    	f = GetStdHandle(STD_OUTPUT_HANDLE);    	if (WriteFile(f, buf, size, &result, NULL)) return result;    	else return -1;    	break;    case CONSOLE_ERROR:    	f = GetStdHandle(STD_ERROR_HANDLE);    	if (WriteFile(f, buf, size, &result, NULL)) return result;    	else return -1;    	break;    }    }static int ProcessCmdLine(HINSTANCE hInstance, LPSTR lpCmdLine, char ***argh){	char *line, *w;	int s, c;	char filename[1000];		GetModuleFileName(hInstance, filename, 1000);	s = strlen(lpCmdLine) + strlen(filename);	line = malloc(s+1);	strcpy(line, filename);	strcat(line, " ");	strcat(line, lpCmdLine);		*argh = malloc(50*sizeof(char *));	c = 0;	w = strtok(line, " ");	while (w) {	    c++;	    *argh = realloc(*argh, c*sizeof(char *));	    (*argh)[c-1] = w;	    w = strtok(NULL, " ");	}		return c;}extern HINSTANCE WindowInstance;int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){    int   exit_status;    int argc;    char **argv;        WindowInstance = hInstance;        argc = ProcessCmdLine(hInstance, lpCmdLine, &argv);#ifdef APP_PRINTF_CALLBACK     PI_set_app_printf_callback(app_printf);#endif    if (!AllocConsole()) exit(1);    printf("hi there\n");    PI_set_console_callback(ConsoleIO);#ifdef WIN32    {	WORD wVersionRequested = MAKEWORD(1, 1);	WSADATA wsaData;	int success = 1;		success = (WSAStartup(wVersionRequested, &wsaData) == 0);		if (success && wsaData.wVersion != wVersionRequested) {	    WSACleanup();	    success = 0;	}	if (!success) PI_app_printf(PI_app_printf_warning, "WinSock init failed !\n");    }    #endif    if ((exit_status = PI_prolog_init(WIN_STR, argc, argv)) != 0) {	PI_app_printf(PI_app_printf_error, "Prolog init failed !\n");	exit(1);    }#ifdef EXP_DATE    if ((unsigned long) time(0) >= EXP_DATE) {	PI_app_printf(PI_app_printf_error, "System validity date passed !\n");	exit(1);	}#endif    pi_init();    if ((exit_status = PI_toplevel()) != 0) {	PI_app_printf(PI_app_printf_error, "Prolog shell crashed !\n");	exit(1);    }    PI_shutdown();    #ifdef WIN32    if (WSACleanup() != 0) {	PI_app_printf(PI_app_printf_warning, "WinSock cleanup failed !\n");    }#endif        #if defined(__MWERKS__) && !defined(MPW_TOOL)    printf("Exiting ALS Prolog.\n");#endif    exit(0);}/* PI_get_options returns a string containing option settings for ALSPro.   Usually this string comes from getenv(), except on the Mac where it   is stored in a preferences file.*/const char *PI_get_options(void){    return getenv("ALS_OPTIONS");}/* * PI_app_printf is called from the prolog environment to display error and * warning messages.  The first parameter, messtype, describes the type * of message.  These types are defined in alspi.h.  The message type may be * used to route the message supplied in va_alist to the place appropriate * for the application. * * Kev's note to ALS implementers:   *	We should be careful to only call PI_app_printf once for each *	particular message from Prolog.  Also, we should not make *	too many assumptions about what kind of device we are writing *	to.  In other words, line control information such as \n should *	probably be removed from most of our messages.  It will then *	be the responsiblity of PI_app_printf to output newlines or *	pop up windows or whatever.  It should also be the responsiblity *	of PI_app_printf to prepend information about the type of message. *	See the fatal error case (below) as an example. *//*VARARGS0 */void app_printf(int messtype, va_list args){    char *fmt;    char msg[255], err[255];    fmt = va_arg(args, char *);    switch (messtype) {	case PI_app_printf_banner :	case PI_app_printf_informational :	    vsprintf(msg, fmt, args);	    break;	case PI_app_printf_fatal_error :	    sprintf(msg,"\nFatal Error: ");	    vsprintf(err, fmt, args);	    strcat(msg, err);	    break;	case PI_app_printf_warning :	case PI_app_printf_error :	default :	    vsprintf(msg, fmt, args);	    break;    }        MessageBox (GetFocus(), msg, "ALS Prolog", 0);}