/*===================================================================
 |		cfiles.pro
 |	Copyright(c) 1991-94 Applied Logic Systems Inc.
 |
 |		File operations
 |
 | Author : P.Raman
 | Created : 9/23/91
 | Revision History :
 |
 | Module : fileops
 |
 | Exported predicates :
 |	parsePathStr/4	-- parse a path string into a list of files
 |	parsePathTokList/4	-- parse a token list into a list of files
 |	addIncludePath/1-- add a path for search of system include files
 |	findUserFile/2	-- search for a user file ( see comment for search order )
 |	findSysFile/4	-- search for a system file
 *==================================================================*/

module c2pro.

	% 
	% parsePathStr/4.
	% parsePathStr/5.
	%	parse a Path string and return a File list
	%	the first argument returns a flag that is set to 'abs'
	%	if the pathname is absolute, otherwise it is set to 'rel'.
	% 

parsePathStr(PathStr,Disk,CompList,Type) :-
	parsePathStr(PathStr,Disk,CompList,Type,Rest).

parsePathStr(PathStr,Disk,CompList,Type,Rest) :-
	diskOfPathStr(Disk,PathStr,PathStr1), 
	compsOfPathStr(CompList,PathStr1,Rest),
	typeOfPathStr(Disk,PathStr1,Type).

%
% parsePathTokList/4.
% parsePathTokList/5.
% 	parse a token list and return a File list (second arg).
%	First argument is bound to 'abs' if input token list
%	represents an absolute path name, otherwise it is bound 
%	to 'rel'.
%

parsePathTokList(TokList,Disk,CompList,Type) :-
	parsePathTokList(TokList,Disk,CompList,Type,Rest).

parsePathTokList(TokList,Disk,CompList,Type,Rest) :-
	diskOfPathTokList(Disk,TokList,TokList1),
	compsOfPathTokList(CompList,TokList1,Rest),
	typeOfPathTokList(Disk,TokList1,Type).

%
% addIncludePath/1
%	Argument is a string representing an include search path
%   The input serach path is added as the first search path,
%	and therefore if there are more than one search paths
%	to be included, they must be presented in reverse order.
%

addIncludePath(Str) :- 
	parsePathStr(Str,Disk,CompList,PathType),
	asserta(includePath(Disk,CompList,PathType)).
%	pathsyntax:asserta(includePath(Disk,CompList,PathType)).

%
% findUserFile/2
%	search for the named file in the current directory, then
%	in the system include directories
%

findUserFile(FileName,FileName) 
	:-	
	exists_file(FileName),			% abs pathname or found locally
	!.
findUserFile(PathName,ExpandedName) 		% use possiblePath
	:-		
	name(PathName,PathStr),
	parsePathStr(PathStr,Disk1,CompList1,PathType1),
	CompList1 \= [],
	PathType1 \= abs,
	possiblePath(Disk2,CompList2,PathType2),
	dappend(CompList2,CompList1,CompList),
	pathListToName(Disk2,CompList,PathType2,ExpandedName),
	exists_file(ExpandedName),
	!.
findUserFile(File,ExpandedName) 
	:-		
	sourcePath(Path),
	pathPlusFile(Path,File,ExpandedName),
	exists_file(ExpandedName).

%
%	search for a system file. If it is an absolute pathname
%	then we dont have to search for it, otherwise search in
%	in the system include paths.
%

findSysFile(Disk,CompList,abs,AbsName) 
	:-
	!,
	pathListToName(Disk,CompList,abs,AbsName),
	exists_file(AbsName).
findSysFile(Disk1,CompList1,rel,AbsName) :-
	CompList1 \= [],
	possiblePath(Disk2,CompList2,PathType),
	dappend(CompList2,CompList1,CompList),
	pathListToName(Disk2,CompList,PathType,AbsName),
	exists_file(AbsName),
	!.

possiblePath(Disk,Comps,PathType) :- includePath(Disk,Comps,PathType).
possiblePath(Disk,Comps,PathType) :- currentPath(Disk,Comps,PathType), !.

%
%	if a file that has just been opened has non-trvial
%	path components, then we assert it as the current path
%	and when that file is closed we retract it.
%

addto_searchPath(FName) :-
	name(FName,FStr),
	parsePathStr(FStr,Disk,Comps,PathType),
	deleteLast(Comps,PathComps),
	PathComps \= [],
	!,
	asserta(currentPath(Disk,PathComps,PathType)).
addto_searchPath( _).


dropfrom_searchPath(FName) :-
	name(FName,FStr),
	parsePathStr(FStr,Disk,Comps,PathType),
	deleteLast(Comps,PathComps),
	PathComps \= [],
	retract(currentPath(_,_,_)),		% remove the top assertion
	!.
dropfrom_searchPath( _).


endmod.
